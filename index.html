<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standoff Online</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #1a1a2e; 
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #game-container { width: 100vw; height: 100vh; }
        
        /* Menu */
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            z-index: 1000;
            overflow-y: auto;
            padding: 32px 0 120px;
        }
        #menu h1 {
            font-size: 72px; color: #e94560; text-transform: uppercase;
            letter-spacing: 8px; margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }
        #menu p { color: #888; margin-bottom: 40px; font-size: 18px; }
        .primary-btn {
            padding: 18px 56px; font-size: 22px; font-weight: bold;
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white; border: none; border-radius: 10px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 3px;
            transition: all 0.3s ease; box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }
        .primary-btn:hover {
            transform: translateY(-3px); box-shadow: 0 15px 40px rgba(233, 69, 96, 0.6);
        }
        #mp-menu-btn { margin-top: 18px; }
        
        /* Multiplayer Menu */
        #mp-menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a3e 100%);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1001;
            gap: 15px;
        }
        #mp-menu h1 {
            font-size: 48px; color: #00d4ff; text-transform: uppercase;
            letter-spacing: 6px; margin-bottom: 10px;
            text-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }
        #mp-menu p { color: #888; margin-bottom: 30px; font-size: 16px; }
        .mp-mode-btn {
            width: 320px;
            padding: 20px 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            background: linear-gradient(135deg, #1e3a5f, #2d5a87);
            border: 2px solid #00d4ff;
            transition: all 0.3s ease;
        }
        .mp-mode-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #2d5a87, #3d7ab7);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 212, 255, 0.4);
        }
        .mp-mode-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #444;
        }
        .mp-mode-btn .mode-icon { font-size: 32px; }
        .mp-mode-btn .mode-name { font-size: 18px; font-weight: bold; }
        .mp-mode-btn .mode-desc { font-size: 12px; color: #aaa; text-transform: none; letter-spacing: 0; }
        .secondary-btn {
            padding: 12px 30px; font-size: 16px;
            background: transparent;
            color: #888; border: 1px solid #444;
            border-radius: 8px; cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s ease;
        }
        .secondary-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #fff;
            border-color: #666;
        }
        #mp-status {
            margin-top: 20px;
            padding: 10px 20px;
            color: #00d4ff;
            font-size: 14px;
            min-height: 20px;
        }
        #map-editor-btn {
            margin-top: 10px;
        }
        
        /* Map Editor */
        #map-editor {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 10, 21, 0.25);
            display: none;
            z-index: 1002;
        }
        /* Sandbox tools */
        #sandbox-tools {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 260px;
            padding: 14px;
            background: rgba(12, 12, 20, 0.9);
            border: 1px solid #333;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.35);
            display: none;
            z-index: 1200;
            color: #fff;
        }
        #sandbox-tools h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #f97316;
        }
        .sandbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }
        .sandbox-shape-btn {
            flex: 1 1 48%;
            padding: 8px;
            border: 1px solid #444;
            background: rgba(255,255,255,0.04);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        .sandbox-shape-btn.active {
            border-color: #f97316;
            background: rgba(249, 115, 22, 0.25);
            box-shadow: 0 0 12px rgba(249,115,22,0.3);
        }
        #sandbox-size {
            flex: 1;
        }
        #sandbox-color {
            width: 60px;
            height: 32px;
            border: none;
            border-radius: 6px;
            padding: 0;
            background: transparent;
        }
        .sandbox-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .sandbox-actions button {
            flex: 1;
            padding: 10px;
            border: 1px solid #444;
            background: linear-gradient(135deg, #2d2d40, #1a1a2e);
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .sandbox-actions button:hover {
            border-color: #f97316;
            box-shadow: 0 0 12px rgba(249,115,22,0.25);
        }
        #editor-toolbar {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1003;
        }
        #editor-toolbar h3 {
            color: #fff;
            font-size: 14px;
            margin: 0 0 10px 0;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        #editor-map-mode {
            width: 100%;
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            margin-bottom: 10px;
            cursor: pointer;
        }
        #editor-map-mode option {
            background: #1a1a2e;
            color: #fff;
        }
        #editor-spawns-info {
            color: #aaa;
            font-size: 11px;
            text-align: center;
            margin-bottom: 10px;
            padding: 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
        }
        #editor-spawns-info span {
            color: #4ade80;
            font-weight: bold;
        }
        .editor-shape-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.1);
            border: 2px solid #444;
            border-radius: 10px;
            color: #fff;
            font-size: 28px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .editor-shape-btn:hover {
            background: rgba(255,255,255,0.2);
            border-color: #6b5b95;
        }
        .editor-shape-btn.active {
            background: rgba(107, 91, 149, 0.5);
            border-color: #8b7bb5;
            box-shadow: 0 0 15px rgba(107, 91, 149, 0.5);
        }
        .editor-shape-btn span {
            font-size: 10px;
            display: block;
        }
        #editor-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 140px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #444;
        }
        .editor-color-btn {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .editor-color-btn:hover {
            transform: scale(1.1);
        }
        .editor-color-btn.active {
            border-color: #fff;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        #editor-color-picker {
            width: 28px;
            height: 28px;
            border: 2px solid #333;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            background: transparent;
        }
        #editor-color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }
        #editor-color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 2px;
        }
        #editor-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 15px 25px;
            display: flex;
            gap: 15px;
            z-index: 1003;
        }
        .editor-ctrl-btn {
            padding: 10px 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .editor-ctrl-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        .editor-ctrl-btn.danger {
            border-color: #e94560;
            color: #e94560;
        }
        .editor-ctrl-btn.danger:hover {
            background: rgba(233, 69, 96, 0.2);
        }
        #editor-info {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #333;
            border-radius: 10px;
            padding: 12px 25px;
            color: #888;
            font-size: 13px;
            z-index: 1003;
        }
        #editor-info kbd {
            background: rgba(255,255,255,0.1);
            padding: 2px 8px;
            border-radius: 4px;
            margin: 0 3px;
        }
        #editor-preview {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 15px;
            z-index: 1003;
            min-width: 150px;
        }
        #editor-preview h4 {
            color: #fff;
            font-size: 12px;
            margin: 0 0 10px 0;
            text-align: center;
        }
        #editor-preview-canvas {
            width: 120px;
            height: 120px;
            background: #000;
            border-radius: 8px;
        }
        #editor-size-controls {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .editor-size-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .editor-size-row label {
            color: #888;
            font-size: 11px;
            width: 20px;
        }
        .editor-size-row input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            border-radius: 4px;
            color: #fff;
            padding: 4px 8px;
            font-size: 12px;
            width: 60px;
        }
        #secret-wrapper {
            margin-top: 24px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            color: #aaa;
        }
        #secret-code {
            width: 240px;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid #444;
            background: rgba(255,255,255,0.05);
            color: #fff;
            text-align: center;
            transition: box-shadow 0.3s ease, transform 0.2s ease;
        }
        #secret-wrapper.unlocked #secret-code {
            box-shadow: 0 0 12px rgba(74, 222, 128, 0.7);
            transform: translateY(-2px);
        }
        #cheat-panel {
            display: none;
            width: 260px;
            padding: 12px;
            background: rgba(0,0,0,0.35);
            border: 1px solid #444;
            border-radius: 8px;
            color: #ddd;
            font-size: 13px;
            gap: 8px;
        }
        #cheat-panel.active { display: flex; flex-direction: column; }
        .cheat-row { display: flex; align-items: center; gap: 8px; }
        .cheat-row input { transform: scale(1.1); }
        .cheat-slider {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
        }
        .cheat-slider input[type=range] { flex: 1; }
        #admin-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 9998;
            cursor: default;
        }
        #admin-overlay.active { display: block; }
        #admin-panel {
            display: none;
            flex-direction: column;
            gap: 12px;
            width: 350px;
            padding: 20px;
            background: rgba(20,20,25,0.95);
            border: 1px solid #555;
            border-radius: 12px;
            color: #ddd;
            font-size: 14px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 9999;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
        }
        #admin-panel.active { display: flex; }
        #admin-panel h3 {
            margin: 0 0 10px 0;
            color: #4ade80;
            font-size: 18px;
            text-align: center;
        }
        
        /* Admin Tabs */
        .admin-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden;
            background: rgba(255,255,255,0.05);
        }
        .admin-tab {
            flex: 1;
            padding: 12px 15px;
            border: none;
            background: transparent;
            color: #888;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        .admin-tab:hover {
            color: #ccc;
            background: rgba(255,255,255,0.05);
        }
        .admin-tab.active {
            color: #fff;
            background: rgba(74,222,128,0.2);
        }
        .admin-tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
        }
        .admin-tab .tab-icon {
            margin-right: 6px;
        }
        
        /* Tab Content */
        .admin-tab-content {
            position: relative;
            overflow: hidden;
        }
        .admin-tab-pane {
            display: none;
            animation: fadeSlideIn 0.3s ease;
        }
        .admin-tab-pane.active {
            display: block;
        }
        @keyframes fadeSlideIn {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        .admin-scope-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 10px;
        }
        .admin-scope-badge.global {
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: #000;
        }
        .admin-scope-badge.local {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: #fff;
        }
        
        #admin-panel textarea {
            width: 100%;
            min-height: 80px;
            border-radius: 8px;
            border: 1px solid #444;
            background: rgba(255,255,255,0.08);
            color: #fff;
            padding: 10px;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }
        #admin-panel textarea:focus {
            outline: none;
            border-color: #4ade80;
        }
        #admin-panel button {
            padding: 10px 15px;
            border: none;
            background: linear-gradient(135deg, #4ade80, #22c55e);
            color: #000;
            font-weight: bold;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.1s;
        }
        #admin-panel button:hover {
            transform: scale(1.02);
            box-shadow: 0 4px 15px rgba(74,222,128,0.4);
        }
        #admin-panel .admin-close {
            background: rgba(255,255,255,0.1);
            color: #aaa;
            font-weight: normal;
            margin-top: 10px;
        }
        #admin-panel .admin-close:hover {
            background: rgba(255,255,255,0.2);
            box-shadow: none;
        }
        #admin-panel small {
            text-align: center;
            color: #666;
        }
        #admin-panel .btn-global {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        #admin-panel .btn-global:hover {
            box-shadow: 0 4px 15px rgba(245,158,11,0.4);
        }
        #admin-panel .btn-local {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: #fff;
        }
        #admin-panel .btn-local:hover {
            box-shadow: 0 4px 15px rgba(59,130,246,0.4);
        }
        #admin-panel .admin-divider {
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            margin: 15px 0;
        }
        #admin-panel .btn-party {
            background: linear-gradient(135deg, #ec4899, #8b5cf6, #06b6d4);
            background-size: 200% 200%;
            animation: partyGradient 3s ease infinite;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        #admin-panel .btn-party:hover {
            box-shadow: 0 4px 20px rgba(236,72,153,0.5);
            transform: scale(1.02);
        }
        #admin-panel .btn-party.active {
            box-shadow: 0 0 25px rgba(236,72,153,0.8), inset 0 0 20px rgba(255,255,255,0.2);
        }
        #admin-panel .btn-sandbox-clear {
            width: 100%;
            padding: 12px;
            border: 1px solid #f97316;
            background: linear-gradient(135deg, #fb923c, #f97316);
            color: #000;
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        #admin-panel .btn-sandbox-clear:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 20px rgba(249, 115, 22, 0.35);
        }
        @keyframes partyGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        #party-notification {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(90deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #1dd1a1, #ff6b6b);
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            text-shadow: none;
            white-space: nowrap;
        }
        #party-notification.show {
            opacity: 1;
            animation: partyTextShimmer 2s linear infinite;
        }
        @keyframes partyTextShimmer {
            0% { background-position: 0% 50%; }
            100% { background-position: 300% 50%; }
        }
        #admin-banner {
            position: fixed;
            top: 52px;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 12px;
            text-align: center;
            font-weight: bold;
            color: #fff;
            background: rgba(0,0,0,0.55);
            border-radius: 8px;
            z-index: 1500;
            display: none;
            max-width: 80vw;
            pointer-events: none;
        }
        #footer-note {
            position: fixed;
            bottom: 10px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            pointer-events: none;
            z-index: 1200;
        }
        #sense-panel {
            margin-top: 14px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 260px;
            color: #ccc;
            font-size: 13px;
        }
        #sense-panel .row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #sense-panel input[type=range] { flex: 1; }
        @keyframes unlockPulse {
            0% { box-shadow: 0 0 0 rgba(74,222,128,0.0); }
            50% { box-shadow: 0 0 20px rgba(74,222,128,0.8); }
            100% { box-shadow: 0 0 0 rgba(74,222,128,0.0); }
        }
        #secret-wrapper.unlocked {
            animation: unlockPulse 1s ease;
        }
        #controls-info {
            margin-top: 40px; color: #666; text-align: center; line-height: 1.8;
        }
        
        /* HUD */
        #hud {
            position: fixed; bottom: 0; left: 0; width: 100%; padding: 20px;
            display: none; pointer-events: none;
        }
        #health-bar {
            position: absolute; bottom: 30px; left: 30px;
            width: 200px; height: 8px; background: rgba(0,0,0,0.6);
            border-radius: 4px; overflow: hidden;
        }
        #health-fill {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            transition: width 0.3s ease;
        }
        #health-text {
            position: absolute; bottom: 45px; left: 30px;
            color: white; font-size: 14px; font-weight: bold;
        }
        #ammo {
            position: absolute; bottom: 30px; right: 30px;
            color: white; font-size: 32px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #ammo span { font-size: 18px; color: #888; }
        #kills {
            position: absolute; bottom: calc(100vh - 50px); left: 30px;
            color: white; font-size: 18px;
        }
        #grenades-count {
            position: absolute; bottom: 70px; right: 30px;
            color: white; font-size: 20px; font-weight: bold;
        }
        
        /* Crosshair */
        #crosshair {
            position: fixed; top: 50%; left: 50%;
            pointer-events: none; display: none;
        }
        .cross-line {
            position: absolute; background: rgba(255,255,255,0.9);
        }
        .cross-h { }
        .cross-v { }
        .cross-top { }
        .cross-bottom { }
        .cross-left { }
        .cross-right { }
        #crosshair-dot {
            background: rgba(255,255,255,0.8);
            border-radius: 50%; position: absolute;
        }
        
        /* Hit marker */
        #hitmarker {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0;
            transition: opacity 0.1s ease;
        }
        .hit-line {
            position: absolute; width: 15px; height: 2px;
            background: #e94560;
        }
        .hit-1 { transform: rotate(45deg) translate(8px, 0); }
        .hit-2 { transform: rotate(-45deg) translate(8px, 0); }
        .hit-3 { transform: rotate(135deg) translate(8px, 0); }
        .hit-4 { transform: rotate(-135deg) translate(8px, 0); }
        
        /* Damage overlay */
        #damage-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(233,69,96,0.4) 100%);
            transition: opacity 0.2s ease;
        }
        
        /* Sniper scope */
        #scope-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; z-index: 50;
        }
        #scope-overlay.active { display: block; }
        .scope-black {
            position: absolute; background: #000;
        }
        .scope-top { top: 0; left: 0; right: 0; height: calc(50% - 150px); }
        .scope-bottom { bottom: 0; left: 0; right: 0; height: calc(50% - 150px); }
        .scope-left { top: 0; bottom: 0; left: 0; width: calc(50% - 150px); }
        .scope-right { top: 0; bottom: 0; right: 0; width: calc(50% - 150px); }
        #scope-circle {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 300px; height: 300px;
            border: 3px solid #000; border-radius: 50%;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.95);
        }
        #scope-crosshair {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        .scope-line {
            position: absolute; background: #000;
        }
        .scope-h { width: 140px; height: 1px; top: 0; }
        .scope-v { width: 1px; height: 140px; left: 0; }
        .scope-h.left { right: 5px; }
        .scope-h.right { left: 5px; }
        .scope-v.top { bottom: 5px; }
        .scope-v.bottom { top: 5px; }
        
        /* Bomb UI */
        #bomb-status {
            position: fixed; top: 80px; left: 50%;
            transform: translateX(-50%);
            color: white; font-size: 20px; font-weight: bold;
            text-align: center; display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #bomb-status.danger { color: #e94560; }
        #bomb-status.success { color: #4ade80; }
        #mp-score {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0,0,0,0.4);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            font-weight: bold;
            color: #fff;
            backdrop-filter: blur(4px);
        }
        .score-badge {
            padding: 6px 10px;
            border-radius: 8px;
            min-width: 80px;
            text-align: center;
        }
        .score-blue { background: rgba(59,130,246,0.6); }
        .score-red { background: rgba(239,68,68,0.6); }
        #weapon-name {
            position: absolute; bottom: 110px; right: 30px;
            color: #888; font-size: 14px;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        .mobile #mobile-controls.active { display: block; }
        .mobile #hud { pointer-events: none; }
        .mobile #health-bar { bottom: 10px; left: 10px; width: 100px; }
        .mobile #health-text { bottom: 22px; left: 10px; font-size: 11px; }
        .mobile #ammo { bottom: 10px; right: 10px; font-size: 18px; }
        .mobile #weapon-name { bottom: 32px; right: 10px; font-size: 10px; }
        .mobile #grenades-count { bottom: 50px; right: 10px; font-size: 12px; }
        .mobile #kills { position: fixed; top: 50px; left: 10px; font-size: 14px; }
        
        .joystick-container {
            position: absolute;
            pointer-events: auto;
            touch-action: none;
        }
        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .joystick-stick {
            position: absolute;
            width: 40%; height: 40%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .mobile-btn {
            position: absolute;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .mobile-btn:active { background: rgba(255,255,255,0.5); }
        #btn-shoot { background: rgba(233, 69, 96, 0.4); border-color: rgba(233, 69, 96, 0.6); }
        
        #look-area {
            position: absolute;
            top: 0; left: 30%; right: 0; bottom: 40%;
            pointer-events: auto;
            touch-action: none;
        }
        
        .mobile #menu h1 { font-size: 32px; letter-spacing: 3px; }
        .mobile #menu p { font-size: 12px; margin-bottom: 20px; }
        .mobile #play-btn { padding: 12px 30px; font-size: 16px; }
        .mobile #controls-info { display: none; }
        .mobile #menu { justify-content: flex-start; padding-top: 30px; }
        
        /* Edit Controls Button */
        #edit-controls-btn {
            display: none;
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 15px;
        }
        .mobile #edit-controls-btn { display: block; }
        
        #edit-hud-btn {
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 10px;
        }
        #edit-hud-btn:hover { background: rgba(255,255,255,0.2); }
        .mobile #edit-hud-btn { display: block; }
        #exit-btn {
            position: fixed;
            top: 14px; left: 14px;
            z-index: 1200;
            padding: 10px 14px;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            cursor: pointer;
            display: none;
        }
        
        #hud-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        #hud-editor.active { display: block; }
        #hud-editor-header {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 15px; background: #1a1a2e;
            display: flex; justify-content: space-between; align-items: center;
        }
        #hud-editor-header h2 { color: #e94560; font-size: 18px; margin: 0; }
        #hud-editor-buttons button {
            padding: 8px 16px; margin-left: 10px;
            border: none; border-radius: 4px; font-size: 12px; cursor: pointer;
        }
        #save-hud { background: #4ade80; color: #000; }
        #reset-hud { background: #666; color: #fff; }
        .hud-draggable {
            position: absolute;
            cursor: move;
            border: 2px dashed rgba(255,255,255,0.5);
            padding: 10px 15px;
            background: rgba(0,0,0,0.7);
            color: white;
            user-select: none;
            font-size: 14px;
        }
        .hud-draggable:hover { border-color: #e94560; }
        .hud-draggable.dragging { border-color: #4ade80; background: rgba(74,222,128,0.2); }
        
        /* Controls Editor */
        #controls-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            flex-direction: column;
        }
        #controls-editor.active { display: flex; }
        #editor-header {
            padding: 15px; background: #1a1a2e;
            display: flex; justify-content: space-between; align-items: center;
        }
        #editor-header h2 { color: #e94560; font-size: 18px; }
        #editor-buttons button {
            padding: 8px 16px; margin-left: 10px;
            border: none; border-radius: 4px; font-size: 12px; cursor: pointer;
        }
        #save-controls { background: #4ade80; color: #000; }
        #reset-controls { background: #666; color: #fff; }
        #editor-area {
            flex: 1; position: relative;
            background: linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .editor-btn {
            position: absolute;
            background: rgba(255,255,255,0.2);
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 50%;
            color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
            touch-action: none;
        }
        .editor-btn.selected { border-color: #e94560; border-style: solid; }
        .resize-handle {
            position: absolute; bottom: -8px; right: -8px;
            width: 20px; height: 20px;
            background: #e94560; border-radius: 50%;
            display: none;
        }
        .editor-btn.selected .resize-handle { display: block; }
        #size-indicator {
            position: fixed; bottom: 80px; left: 50%;
            transform: translateX(-50%);
            color: white; font-size: 14px;
            background: rgba(0,0,0,0.7); padding: 8px 16px;
            border-radius: 4px; display: none;
        }
        /* Crosshair Editor */
        #crosshair-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(26,26,46,0.98) 0%, rgba(22,33,62,0.98) 100%);
            z-index: 2000;
            flex-direction: column;
            overflow-y: auto;
        }
        #crosshair-editor.active { display: flex; }
        #crosshair-editor-header {
            padding: 20px; background: linear-gradient(90deg, #1a1a2e, #16213e);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid #e94560;
        }
        #crosshair-editor-header h2 { 
            color: #e94560; font-size: 20px; margin: 0; 
            text-transform: uppercase; letter-spacing: 2px;
        }
        #crosshair-editor-buttons button {
            padding: 10px 20px; margin-left: 10px;
            border: none; border-radius: 6px; font-size: 13px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        #save-crosshair { background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; }
        #save-crosshair:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(74,222,128,0.4); }
        #reset-crosshair { background: #444; color: #fff; }
        #reset-crosshair:hover { background: #555; }
        #crosshair-editor-content {
            display: flex; flex-direction: row; flex: 1; padding: 20px; gap: 20px;
        }
        @media (max-width: 768px) {
            #crosshair-editor-content { flex-direction: column; }
        }
        #crosshair-preview-section {
            flex: 1; display: flex; flex-direction: column; align-items: center;
        }
        #crosshair-preview {
            display: flex; align-items: center; justify-content: center;
            width: 100%; max-width: 300px; height: 200px;
            background: radial-gradient(circle, #2a2a4a 0%, #1a1a2e 100%);
            border-radius: 12px; border: 2px solid #333;
            position: relative; box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }
        #preview-cross { position: relative; }
        .preview-line { position: absolute; background: white; transition: all 0.1s ease; }
        .preview-dot {
            width: 4px; height: 4px; background: white;
            border-radius: 50%; position: absolute;
            top: -2px; left: -2px; transition: all 0.1s ease;
        }
        #crosshair-editor-controls {
            flex: 1; color: white; display: flex; flex-direction: column; gap: 12px;
            max-width: 400px;
        }
        .control-group {
            background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group-title {
            font-size: 12px; color: #e94560; text-transform: uppercase;
            letter-spacing: 1px; margin-bottom: 12px; font-weight: bold;
        }
        .control-row {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-row label { font-size: 13px; color: #aaa; }
        .control-row .value { 
            font-size: 12px; color: #e94560; min-width: 40px; text-align: right;
            font-weight: bold;
        }
        .control-row input[type=range] {
            flex: 1; margin: 0 12px; height: 6px; -webkit-appearance: none;
            background: #333; border-radius: 3px; cursor: pointer;
        }
        .control-row input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #e94560; border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 8px rgba(233,69,96,0.5);
        }
        .control-row input[type=color] {
            width: 50px; height: 32px; border: 2px solid #444;
            border-radius: 6px; cursor: pointer; background: transparent;
        }
        .control-row input[type=color]::-webkit-color-swatch-wrapper { padding: 2px; }
        .control-row input[type=color]::-webkit-color-swatch { border-radius: 4px; border: none; }
        .style-presets {
            display: flex; gap: 10px; flex-wrap: wrap;
        }
        .preset-btn {
            padding: 8px 14px; background: rgba(255,255,255,0.1);
            border: 1px solid #444; border-radius: 6px; color: #aaa;
            font-size: 12px; cursor: pointer; transition: all 0.2s ease;
        }
        .preset-btn:hover { background: rgba(233,69,96,0.2); border-color: #e94560; color: #fff; }
        .preset-btn.active { background: #e94560; border-color: #e94560; color: #fff; }
        .toggle-switch {
            position: relative; width: 50px; height: 26px;
            background: #333; border-radius: 13px; cursor: pointer;
            transition: background 0.2s ease;
        }
        .toggle-switch.active { background: #e94560; }
        .toggle-switch::after {
            content: ''; position: absolute; width: 22px; height: 22px;
            background: #fff; border-radius: 50%; top: 2px; left: 2px;
            transition: transform 0.2s ease;
        }
        .toggle-switch.active::after { transform: translateX(24px); }
        #edit-crosshair-btn {
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 10px;
        }
        #edit-crosshair-btn:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="admin-banner"></div>
    
    <!-- Admin Panel Overlay -->
    <div id="admin-overlay"></div>
    <div id="admin-panel">
        <h3>🛠️ Админ панель</h3>
        
        <!-- Tabs -->
        <div class="admin-tabs">
            <button class="admin-tab active" data-tab="global">
                <span class="tab-icon">🌍</span>Глобально
            </button>
            <button class="admin-tab" data-tab="local">
                <span class="tab-icon">🖥️</span>Локально
            </button>
        </div>
        
        <!-- Tab Content -->
        <div class="admin-tab-content">
            <!-- Global Tab -->
            <div class="admin-tab-pane active" id="tab-global">
                <span class="admin-scope-badge global">🌍 Все серверы</span>
                <textarea id="admin-message-global" placeholder="Сообщение для всех серверов..."></textarea>
                <button id="admin-send-global" class="btn-global">📢 Отправить глобально</button>
                <div class="admin-divider"></div>
                <button id="admin-party-global" class="btn-party">🎆 Праздник</button>
                <button id="admin-sandbox-clear" class="btn-sandbox-clear">🧹 Очистить песочницу</button>
            </div>
            
            <!-- Local Tab -->
            <div class="admin-tab-pane" id="tab-local">
                <span class="admin-scope-badge local">🖥️ Только этот сервер</span>
                <textarea id="admin-message-local" placeholder="Сообщение для этого сервера..."></textarea>
                <button id="admin-send-local" class="btn-local">📢 Отправить локально</button>
                <div class="admin-divider"></div>
                <button id="admin-party-local" class="btn-party">🎆 Праздник</button>
            </div>
        </div>
        
        <!-- Party notification -->
        <div id="party-notification"></div>
        
        <button class="admin-close" id="admin-close">Закрыть (J)</button>
        <small>Нажмите J или ESC чтобы закрыть</small>
    </div>
    
    <div id="game-container"></div>
    
    <!-- Menu -->
    <div id="menu">
        <h1>Standoff Online</h1>
        <p>Браузерный шутер</p>
        <button id="play-btn" class="primary-btn">Играть</button>
        <button id="mp-menu-btn" class="primary-btn">Мультиплеер</button>
        <button id="map-editor-btn" class="primary-btn">Редактор карт</button>
        <button id="edit-controls-btn">Настроить управление</button>
        <button id="edit-hud-btn">Настроить HUD</button>
        <button id="edit-crosshair-btn">Настроить прицел</button>
        <div id="secret-wrapper">
            <span>Secret code</span>
            <input id="secret-code" type="text" placeholder="Введите код">
            <div id="sense-panel">
                <div class="row">
                    <label for="sens-desktop">Чувств. мыши</label>
                    <input id="sens-desktop" type="range" min="0.0005" max="0.01" step="0.0005" value="0.002">
                    <span id="sens-desktop-val">0.002</span>
                </div>
                <div class="row">
                    <label for="sens-mobile">Чувств. взгляд (моб)</label>
                    <input id="sens-mobile" type="range" min="0.001" max="0.02" step="0.0005" value="0.004">
                    <span id="sens-mobile-val">0.004</span>
                </div>
            </div>
            <div id="cheat-panel">
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-god">
                    <label for="cheat-god">Бессмертие</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-ammo">
                    <label for="cheat-ammo">Бесконечные патроны</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-recoil">
                    <label for="cheat-recoil">Без отдачи</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-speed">
                    <label for="cheat-speed">Скорость x2</label>
                </div>
                <div class="cheat-slider">
                    <label for="cheat-speed-mul">Множитель</label>
                    <input type="range" id="cheat-speed-mul" min="1" max="5" step="0.1" value="2">
                    <span id="cheat-speed-mul-val">2.0x</span>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-fly">
                    <label for="cheat-fly">Fly</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-noclip">
                    <label for="cheat-noclip">Noclip</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-wallbang">
                    <label for="cheat-wallbang">Стрельба через стены</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-rapid">
                    <label for="cheat-rapid">Очень быстрый огонь</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-esp">
                    <label for="cheat-esp">ESP подсветка</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-aimbot">
                    <label for="cheat-aimbot">Aimbot</label>
                </div>
                <div class="cheat-row">
                    <input type="checkbox" id="cheat-admin-toggle">
                    <label for="cheat-admin-toggle">Админ панель</label>
                </div>
            </div>
        </div>
        <div id="controls-info">
            <p>WASD - Движение | ПРОБЕЛ - Прыжок | ЛКМ - Стрельба | ПКМ - Прицел | R - Перезарядка | G - Граната</p>
            <p>1/2 - Смена оружия | B - Установить бомбу</p>
        </div>
    </div>
    
    <!-- Multiplayer Menu -->
    <div id="mp-menu">
        <h1>Мультиплеер</h1>
        <p>Выберите режим игры</p>
        <button id="mp-duel-btn" class="primary-btn mp-mode-btn">
            <span class="mode-icon">⚔️</span>
            <span class="mode-name">Дуэли 1v1</span>
            <span class="mode-desc">Сражение один на один</span>
        </button>
        <button id="mp-team-btn" class="primary-btn mp-mode-btn">
            <span class="mode-icon">👥</span>
            <span class="mode-name">Команды 5v5</span>
            <span class="mode-desc">Командный бой</span>
        </button>
        <button id="mp-ffa-btn" class="primary-btn mp-mode-btn">
            <span class="mode-icon">🎯</span>
            <span class="mode-name">Все против всех</span>
            <span class="mode-desc">Каждый сам за себя</span>
        </button>
        <button id="mp-sandbox-btn" class="primary-btn mp-mode-btn">
            <span class="mode-icon">🛠️</span>
            <span class="mode-name">Песочница</span>
            <span class="mode-desc">Один сервер для всех</span>
        </button>
        <button id="mp-back-btn" class="secondary-btn">← Назад</button>
        <div id="mp-status"></div>
    </div>
    
    <!-- Map Editor -->
    <div id="map-editor">
        <div id="editor-toolbar">
            <h3>Режим карты</h3>
            <select id="editor-map-mode">
                <option value="1v1">1v1 (2 спавна)</option>
                <option value="5v5">5v5 (10 спавнов)</option>
                <option value="ffa">FFA (∞ спавнов)</option>
                <option value="sandbox">Песочница (∞)</option>
            </select>
            <div id="editor-spawns-info">Спавнов: <span id="spawns-placed">0</span> / <span id="spawns-needed">2</span></div>
            <h3>Инструменты</h3>
            <button class="editor-shape-btn" data-shape="spawn" title="Точка спавна">🚩</button>
            <h3>Фигуры</h3>
            <button class="editor-shape-btn active" data-shape="box" title="Куб">📦</button>
            <button class="editor-shape-btn" data-shape="sphere" title="Сфера">🔮</button>
            <button class="editor-shape-btn" data-shape="cylinder" title="Цилиндр">🥫</button>
            <button class="editor-shape-btn" data-shape="cone" title="Конус">🔺</button>
            <button class="editor-shape-btn" data-shape="plane" title="Плоскость">📄</button>
            <button class="editor-shape-btn" data-shape="ramp" title="Рампа">📐</button>
            <div id="editor-colors">
                <button class="editor-color-btn active" data-color="#e94560" style="background:#e94560"></button>
                <button class="editor-color-btn" data-color="#00d4ff" style="background:#00d4ff"></button>
                <button class="editor-color-btn" data-color="#4ecdc4" style="background:#4ecdc4"></button>
                <button class="editor-color-btn" data-color="#ffe66d" style="background:#ffe66d"></button>
                <button class="editor-color-btn" data-color="#ff6b6b" style="background:#ff6b6b"></button>
                <button class="editor-color-btn" data-color="#c44dff" style="background:#c44dff"></button>
                <button class="editor-color-btn" data-color="#95e1d3" style="background:#95e1d3"></button>
                <button class="editor-color-btn" data-color="#f38181" style="background:#f38181"></button>
                <button class="editor-color-btn" data-color="#aa96da" style="background:#aa96da"></button>
                <button class="editor-color-btn" data-color="#fcbad3" style="background:#fcbad3"></button>
                <button class="editor-color-btn" data-color="#ffffff" style="background:#ffffff"></button>
                <button class="editor-color-btn" data-color="#888888" style="background:#888888"></button>
                <button class="editor-color-btn" data-color="#333333" style="background:#333333"></button>
                <button class="editor-color-btn" data-color="#1a1a2e" style="background:#1a1a2e"></button>
                <button class="editor-color-btn" data-color="#2d3436" style="background:#2d3436"></button>
                <button class="editor-color-btn" data-color="#6c5ce7" style="background:#6c5ce7"></button>
                <input type="color" id="editor-color-picker" value="#e94560" title="Выбрать цвет">
            </div>
        </div>
        
        <div id="editor-info">
            <kbd>ЛКМ</kbd> Поставить · <kbd>ПКМ+Drag</kbd> Вращать камеру · <kbd>СКМ</kbd> Удалить · <kbd>WASD</kbd> Движение · <kbd>Scroll</kbd> Размер/Зум · <kbd>R</kbd> Вращение · <kbd>ESC</kbd> Выход
        </div>
        
        <div id="editor-preview">
            <h4>Превью объекта</h4>
            <canvas id="editor-preview-canvas"></canvas>
            <div id="editor-size-controls">
                <div class="editor-size-row">
                    <label>W</label>
                    <input type="number" id="editor-size-w" value="2" min="0.5" max="50" step="0.5">
                </div>
                <div class="editor-size-row">
                    <label>H</label>
                    <input type="number" id="editor-size-h" value="2" min="0.5" max="50" step="0.5">
                </div>
                <div class="editor-size-row">
                    <label>D</label>
                    <input type="number" id="editor-size-d" value="2" min="0.5" max="50" step="0.5">
                </div>
            </div>
        </div>
        
        <div id="editor-controls">
            <button class="editor-ctrl-btn" id="editor-undo" title="Отменить (Ctrl+Z)">↩️</button>
            <button class="editor-ctrl-btn" id="editor-redo" title="Повторить (Ctrl+Y)">↪️</button>
            <button class="editor-ctrl-btn" id="editor-clear">🗑️ Очистить</button>
            <button class="editor-ctrl-btn" id="editor-save">💾 Сохранить</button>
            <button class="editor-ctrl-btn" id="editor-load">📂 Загрузить</button>
            <button class="editor-ctrl-btn" id="editor-test">▶️ Тест</button>
            <button class="editor-ctrl-btn danger" id="editor-exit">✕ Выход</button>
        </div>
    </div>
    
    <!-- Controls Editor -->
    <div id="controls-editor">
        <div id="editor-header">
            <h2>Настройка управления</h2>
            <div id="editor-buttons">
                <button id="reset-controls">Сброс</button>
                <button id="save-controls">Сохранить</button>
            </div>
        </div>
        <div id="editor-area"></div>
        <div id="size-indicator">Размер: <span id="size-value">50</span>px</div>
    </div>
    
    <!-- HUD Editor -->
    <!-- Crosshair Editor -->
    <div id="crosshair-editor">
        <div id="crosshair-editor-header">
            <h2>Настройка прицела</h2>
            <div id="crosshair-editor-buttons">
                <button id="reset-crosshair">Сброс</button>
                <button id="save-crosshair">Сохранить</button>
            </div>
        </div>
        <div id="crosshair-editor-content">
            <div id="crosshair-preview-section">
                <div id="crosshair-preview">
                    <div id="preview-cross">
                        <div class="preview-line preview-top"></div>
                        <div class="preview-line preview-bottom"></div>
                        <div class="preview-line preview-left"></div>
                        <div class="preview-line preview-right"></div>
                        <div class="preview-dot"></div>
                    </div>
                </div>
            </div>
            <div id="crosshair-editor-controls">
                <div class="control-group">
                    <div class="control-group-title">Стиль</div>
                    <div class="style-presets">
                        <button class="preset-btn" data-style="cross">Крест</button>
                        <button class="preset-btn" data-style="dot">Точка</button>
                        <button class="preset-btn" data-style="circle">Круг</button>
                        <button class="preset-btn" data-style="t">T-образный</button>
                    </div>
                </div>
                <div class="control-group" id="lines-controls">
                    <div class="control-group-title">Линии</div>
                    <div class="control-row">
                        <label>Длина</label>
                        <input id="cross-length" type="range" min="4" max="40">
                        <span class="value" id="cross-length-val">12px</span>
                    </div>
                    <div class="control-row">
                        <label>Толщина</label>
                        <input id="cross-thickness" type="range" min="1" max="8">
                        <span class="value" id="cross-thickness-val">2px</span>
                    </div>
                    <div class="control-row">
                        <label>Отступ</label>
                        <input id="cross-gap" type="range" min="0" max="60">
                        <span class="value" id="cross-gap-val">20px</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-group-title">Точка</div>
                    <div class="control-row">
                        <label>Показать точку</label>
                        <div id="cross-dot-toggle" class="toggle-switch active"></div>
                    </div>
                    <div class="control-row">
                        <label>Размер точки</label>
                        <input id="cross-dot-size" type="range" min="2" max="20">
                        <span class="value" id="cross-dot-size-val">4px</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-group-title">Цвет</div>
                    <div class="control-row">
                        <label>Цвет прицела</label>
                        <input id="cross-color" type="color" value="#ffffff">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="hud-editor">
        <div id="hud-editor-header">
            <h2>Настройка HUD</h2>
            <div id="hud-editor-buttons">
                <button id="reset-hud">Сброс</button>
                <button id="save-hud">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div id="health-text" data-ctrl="hudHealth">HP</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo" data-ctrl="hudAmmo"><span id="current-ammo">30</span> / <span id="reserve-ammo">90</span></div>
        <div id="weapon-name">AK-47</div>
        <div id="grenades-count" data-ctrl="hudGrenades">🧨 <span id="grenade-num">3</span></div>
        <div id="kills" data-ctrl="hudKills">Убийства: <span id="kill-count">0</span></div>
    </div>

    <!-- Sandbox tools -->
    <div id="sandbox-tools">
        <h4>Песочница</h4>
        <div class="sandbox-row">
            <button class="sandbox-shape-btn active" data-shape="box">Куб</button>
            <button class="sandbox-shape-btn" data-shape="plane">Плоскость</button>
            <button class="sandbox-shape-btn" data-shape="ramp">Рампа</button>
            <button class="sandbox-shape-btn" data-shape="cylinder">Цилиндр</button>
        </div>
        <div class="sandbox-row">
            <label>Размер</label>
            <input id="sandbox-size" type="range" min="0.5" max="8" step="0.5" value="2">
            <span id="sandbox-size-val">2.0</span>
        </div>
        <div class="sandbox-row">
            <label>Цвет</label>
            <input id="sandbox-color" type="color" value="#e94560">
        </div>
        <div class="sandbox-actions">
            <button id="sandbox-place">Поставить блок</button>
            <button id="sandbox-clear-local">Очистить у себя</button>
        </div>
    </div>
    
    <!-- Crosshair -->
    <div id="crosshair">
        <div id="crosshair-dot"></div>
        <div class="cross-line cross-v cross-top"></div>
        <div class="cross-line cross-v cross-bottom"></div>
        <div class="cross-line cross-h cross-left"></div>
        <div class="cross-line cross-h cross-right"></div>
    </div>
    
    <!-- Hit marker -->
    <div id="hitmarker">
        <div class="hit-line hit-1"></div>
        <div class="hit-line hit-2"></div>
        <div class="hit-line hit-3"></div>
        <div class="hit-line hit-4"></div>
    </div>
    
    <!-- Damage overlay -->
    <div id="damage-overlay"></div>
    
    <!-- Sniper scope -->
    <div id="scope-overlay">
        <div id="scope-circle"></div>
        <div id="scope-crosshair">
            <div class="scope-line scope-h left"></div>
            <div class="scope-line scope-h right"></div>
            <div class="scope-line scope-v top"></div>
            <div class="scope-line scope-v bottom"></div>
        </div>
    </div>
    
    <div id="mp-score">
        <div class="score-badge score-blue" id="score-me">You: 0</div>
        <div class="score-badge score-red" id="score-enemy">Enemy: 0</div>
    </div>
    <button id="exit-btn">Выйти</button>
    
    <!-- Bomb status -->
    <div id="bomb-status"></div>
    <div id="footer-note">с любовью от феди</div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="look-area"></div>
        <div id="joystick-move" class="joystick-container" data-ctrl="joystick">
            <div class="joystick-base">
                <div class="joystick-stick" id="move-stick"></div>
            </div>
        </div>
        <div id="btn-shoot" class="mobile-btn" data-ctrl="shoot"></div>
        <div id="btn-jump" class="mobile-btn" data-ctrl="jump"></div>
        <div id="btn-crouch" class="mobile-btn" data-ctrl="crouch">↓</div>
        <div id="btn-reload" class="mobile-btn" data-ctrl="reload"></div>
        <div id="btn-grenade" class="mobile-btn" data-ctrl="grenade"></div>
        <div id="btn-weapon" class="mobile-btn" data-ctrl="weapon"></div>
        <div id="btn-scope" class="mobile-btn" data-ctrl="scope"></div>
        <div id="btn-bomb" class="mobile-btn" data-ctrl="bomb">?</div>
        <div id="btn-hammer" class="mobile-btn" data-ctrl="hammer">🔨</div>
        <div id="admin-mobile-btn" class="mobile-btn" style="display:none;">🛠️</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
    <script>

// ==================== MOBILE DETECTION ====================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
    || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);

if (isMobile) {
    document.body.classList.add('mobile');
}

// ==================== GAME CONFIG ====================
const CONFIG = {
    player: {
        height: 1.7,
        speed: 8,
        sprintMultiplier: 1.5,
        jumpForce: 8,
        gravity: 25,
        health: 100
    },
    weapon: {
        damage: 25,
        fireRate: 100,
        recoil: 0.008,
        magazineSize: 30,
        reserveAmmo: 90,
        reloadTime: 2000
    },
    sniper: {
        damage: 200,
        fireRate: 1500,
        recoil: 0.025,
        magazineSize: 5,
        reserveAmmo: 20,
        reloadTime: 3000,
        scopeZoom: 3
    },
    knife: {
        damage: 55,
        fireRate: 500,
        range: 2.5
    },
    enemy: {
        health: 80,
        speed: 2.5,
        damage: 6,
        fireRate: 1200,
        accuracy: 0.4,
        attackRange: 30,
        detectionRange: 35
    },
    map: {
        size: 40
    }
};

const DEFAULT_MAP_SIZE = CONFIG.map.size;
const AIM_MAP_SIZE = 32;
const AIM_SPAWNS = [
    { x: -1, y: 1.7, z: 14.5 },
    { x: -1.5, y: 1.7, z: -14.5 }
];

// ==================== GAME STATE ====================
const state = {
    isPlaying: false,
    isMultiplayer: false,
    isSearchingMatch: false,
    mpSpawnIndex: 0,
    mpOpponentId: null,
    mpRoom: null,
    mpTeam: null,
    health: CONFIG.player.health,
    currentWeapon: 'rifle', // rifle, sniper or knife
    savedWeaponBeforeHammer: null,
    ammo: CONFIG.weapon.magazineSize,
    reserveAmmo: CONFIG.weapon.reserveAmmo,
    sniperAmmo: CONFIG.sniper.magazineSize,
    sniperReserve: CONFIG.sniper.reserveAmmo,
    grenades: 3,
    kills: 0,
    isReloading: false,
    canShoot: true,
    canThrowGrenade: true,
    isScoped: false,
    velocity: new THREE.Vector3(),
    isGrounded: true,
    moveForward: false,
    moveBackward: false,
    moveLeft: false,
    moveRight: false,
    isMoving: false,
    isSprinting: false,
    isCrouching: false,
    jumpHeld: false,
    flyUp: false,
    flyDown: false,
    crosshairSpread: 0,
    cheats: {
        enabled: false,
        godMode: false,
        infiniteAmmo: false,
        noRecoil: false,
        speedBoost: false,
        speedMultiplier: 2,
        fly: false,
        noclip: false,
        wallbang: false,
        rapidFire: false,
        esp: false,
        aimbot: false
    },
    cheatsUnlocked: false,
    adminUnlocked: false,
    settings: {
        desktopSensitivity: 0.002,
        mobileLookSensitivity: 0.004
    },
    sounds: {
        sniperShot: null,
        rifleShot: null,
        knifeSwing: null,
        footsteps: null,
        jump: null,
        firework: null
    },
    soundTimers: {},
    knifeCooldown: false,
    partyMode: false,
    partyFireworks: [],
    partyEffects: {
        discoBalls: [],
        spotlights: [],
        originalBackground: null,
        originalFog: null,
        originalAmbient: null
    },
    savedWeaponBeforeParty: null,
    mpKills: 0,
    mpDeaths: 0,
    // Bomb state
    bombPlanted: false,
    bombPosition: null,
    bombTimer: 0,
    bombDefuseTimer: 0,
    enemyDefusing: false,
    regenTimer: 0,
    mpMode: null, // duel | team | ffa | sandbox
    sandbox: {
        active: false,
        objects: [],
        tool: { shape: 'box', color: '#e94560', size: 2 }
    }
};

// ==================== THREE.JS SETUP ====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0xd4a574, 20, 80);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, CONFIG.player.height, 15);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('game-container').appendChild(renderer.domElement);

// Explicit click-to-lock for desktop
const gameContainer = document.getElementById('game-container');
if (gameContainer) {
    gameContainer.addEventListener('click', () => {
        if (!isMobile && state.isPlaying && !mapEditor.active && !isSandboxPanelOpen()) {
            (renderer?.domElement || gameContainer)?.requestPointerLock?.();
        }
    });
}

// ==================== AUDIO ====================
function loadSounds() {
    try {
        state.sounds.sniperShot = new Audio('sounds/sniper.mp3');
        state.sounds.sniperShot.volume = 0.7;
        state.sounds.rifleShot = new Audio('sounds/kalash.mp3');
        state.sounds.rifleShot.volume = 0.6;
        state.sounds.knifeSwing = new Audio('sounds/knife.mp3');
        state.sounds.knifeSwing.volume = 0.5;
        state.sounds.footsteps = new Audio('sounds/walk.mp3');
        state.sounds.footsteps.volume = 0.4;
        state.sounds.footsteps.loop = true;
        state.sounds.jump = new Audio('sounds/jump.mp3');
        state.sounds.jump.volume = 0.5;
        state.sounds.firework = new Audio('sounds/firework.mp3');
        state.sounds.firework.volume = 0.6;
    } catch (e) { console.warn('Failed to load sounds'); }
}

function startWeaponSound(key, durationSec) {
    const sound = state.sounds[key];
    if (!sound) return;
    try {
        // If already playing, don't restart; just extend stop timer.
        if (sound.paused) {
            sound.currentTime = 0;
            sound.play();
        }
        if (state.soundTimers[key]) clearTimeout(state.soundTimers[key]);
        state.soundTimers[key] = setTimeout(() => {
            try {
                sound.pause();
                sound.currentTime = 0;
            } catch (e) {}
        }, durationSec * 1000);
    } catch (e) {}
}

loadSounds();

// ==================== POINTER LOCK CONTROLS ====================
class FPSControls {
    constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.isLocked = false;
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.sensitivity = 0.002;
        this.maxStep = 0.05; // clamp per-event to avoid acceleration spikes
        
        this.connect();
    }
    
    connect() {
        document.addEventListener('pointerlockchange', () => {
            this.isLocked = document.pointerLockElement === this.domElement;
        });
        
        document.addEventListener('mousemove', (e) => {
            // Allow camera movement if playing (even without pointer lock for smoother experience)
            if (isMobile) return;
            if (!state.isPlaying) return;
            
            // Only use movementX/Y when pointer is locked
            if (!this.isLocked) return;
            
            this.euler.setFromQuaternion(this.camera.quaternion);
            const stepX = THREE.MathUtils.clamp(e.movementX * this.sensitivity, -this.maxStep, this.maxStep);
            const stepY = THREE.MathUtils.clamp(e.movementY * this.sensitivity, -this.maxStep, this.maxStep);
            this.euler.y -= stepX;
            this.euler.x -= stepY;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.camera.quaternion.setFromEuler(this.euler);
        });
    }
    
    lock() {
        if (!isMobile) {
            this.domElement.requestPointerLock();
        }
    }
    
    getDirection() {
        const direction = new THREE.Vector3(0, 0, -1);
        return direction.applyQuaternion(this.camera.quaternion);
    }
}

const controls = new FPSControls(camera, renderer.domElement);

// ==================== LIGHTING ====================
const ambientLight = new THREE.AmbientLight(0xffeedd, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(50, 100, 50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 200;
sunLight.shadow.camera.left = -100;
sunLight.shadow.camera.right = 100;
sunLight.shadow.camera.top = 100;
sunLight.shadow.camera.bottom = -100;
scene.add(sunLight);

// ==================== MATERIALS ====================
const materials = {
    sand: new THREE.MeshLambertMaterial({ color: 0xdcc08a }),
    sandDark: new THREE.MeshLambertMaterial({ color: 0xc8a56c }),
    stone: new THREE.MeshLambertMaterial({ color: 0xb98d58 }),
    concrete: new THREE.MeshLambertMaterial({ color: 0xa07a54 }),
    plaster: new THREE.MeshLambertMaterial({ color: 0xddd8cf }),
    metal: new THREE.MeshLambertMaterial({ color: 0x555555 }),
    wood: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
    enemy: new THREE.MeshLambertMaterial({ color: 0xe94560 })
};

// ==================== MAP CREATION ====================
const mapGroup = new THREE.Group();
scene.add(mapGroup);
const colliders = [];
const obstacles = [];
let floor = null;
const sandboxObjects = [];

function requestGamePointerLock() {
    if (isMobile) return;
    if (mapEditor.active || mapEditor.testMode || isSandboxPanelOpen()) return;
    const target = renderer?.domElement || document.getElementById('game-container');
    target?.requestPointerLock?.();
}

function isSandboxPanelOpen() {
    const panel = document.getElementById('sandbox-tools');
    return panel && panel.style.display !== 'none';
}

function setSandboxPanelVisible(show) {
    const panel = document.getElementById('sandbox-tools');
    if (panel) panel.style.display = show ? 'block' : 'none';
    if (show && !isMobile) {
        document.exitPointerLock?.();
    } else if (!show && !isMobile && state.isPlaying && !mapEditor.active) {
        const target = renderer?.domElement || document.getElementById('game-container');
        target?.requestPointerLock?.();
    }
}

function clearMap() {
    mapGroup.visible = true;
    colliders.length = 0;
    while (mapGroup.children.length > 0) {
        const child = mapGroup.children.pop();
        mapGroup.remove(child);
        if (child.geometry && child.geometry.dispose) {
            child.geometry.dispose();
        }
    }
}

function createBox(w, h, d, x, y, z, material, isCollider = true) {
    const geometry = new THREE.BoxGeometry(w, h, d);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mapGroup.add(mesh);
    
    if (isCollider) {
        colliders.push({
            mesh,
            box: new THREE.Box3().setFromObject(mesh)
        });
    }
    return mesh;
}

function createDefaultMap() {
    mapGroup.visible = true;
    CONFIG.map.size = 40;
    clearMap();
    createSandstoneMap();
}

// Sandstone map - based on original minimap layout
function createSandstoneMap() {
    const sand = 0xC9A86C;       // Main walls
    const sandDark = 0xA6845A;   // Darker areas
    const sandLight = 0xDDC49A;  // Light floor
    const wood = 0x7A5230;       // Crates
    const site = 0xB87333;       // Bomb sites
    const window = 0x4A3520;     // Window color
    const palm = 0x228B22;       // Palm leaves
    const trunk = 0x8B4513;      // Palm trunk
    const fence = 0x8B7355;      // Fence color
    
    // Ground
    const groundGeo = new THREE.PlaneGeometry(90, 90);
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: sandDark }));
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    mapGroup.add(ground);
    floor = ground;
    
    // === BOUNDARY WALLS ===
    createColorBox(90, 5, 1, 0, 2.5, -45, sand);
    createColorBox(90, 5, 1, 0, 2.5, 45, sand);
    createColorBox(1, 5, 90, -45, 2.5, 0, sand);
    createColorBox(1, 5, 90, 45, 2.5, 0, sand);
    
    // === T SPAWN (bottom-left) ===
    createColorBox(12, 0.2, 10, -35, 0.1, 30, sandLight);
    
    // === CT SPAWN (top-right) ===
    createColorBox(12, 0.2, 10, 35, 0.1, -30, sandLight);
    
    // === MID (center) ===
    createColorBox(14, 0.2, 14, 0, 0.1, 0, sandLight);
    // Fountain
    createColorCylinder(2, 0.4, 0, 0.2, 0, sandDark);
    
    // === SITE A (top-left) ===
    createColorBox(12, 0.2, 10, -28, 0.1, -20, site);
    createColorBox(1, 4, 14, -22, 2, -20, sand);
    createColorBox(10, 4, 1, -28, 2, -13, sand);
    
    // === ГРОБЫ / Graveyard ===
    createColorBox(8, 0.2, 8, -10, 0.1, -25, sandDark);
    createColorBox(2, 1.5, 4, -12, 0.75, -25, sand);
    createColorBox(2, 1.5, 4, -8, 0.75, -25, sand);
    
    // === SITE B (bottom-right) ===
    createColorBox(12, 0.2, 10, 28, 0.1, 20, site);
    createColorBox(1, 4, 14, 22, 2, 20, sand);
    createColorBox(10, 4, 1, 28, 2, 13, sand);
    
    // === ЧЕТВЕРКА ===
    createColorBox(8, 0.2, 8, 10, 0.1, 25, sandDark);
    
    // === ЦЕМЕНТ ===
    createColorBox(8, 0.2, 8, 25, 0.1, -5, sandDark);
    
    // === BUILDINGS WITH DETAILS ===
    // Building 1 (top-left) - 2 floors with windows
    createColorBox(14, 5, 10, -35, 2.5, -15, sand);
    createColorBox(14, 2, 10, -35, 6, -15, sandDark); // Roof
    createColorBox(2, 1.5, 0.3, -30, 2.5, -10, window); // Window
    createColorBox(2, 1.5, 0.3, -35, 2.5, -10, window);
    createColorBox(2, 1.5, 0.3, -40, 2.5, -10, window);
    
    // Building 2 (top-right) - tall
    createColorBox(14, 6, 10, 35, 3, -15, sand);
    createColorBox(14, 1.5, 10, 35, 6.75, -15, sandDark);
    createColorBox(2, 1.5, 0.3, 30, 3, -10, window);
    createColorBox(2, 1.5, 0.3, 35, 3, -10, window);
    createColorBox(2, 1.5, 0.3, 40, 3, -10, window);
    
    // Building 3 (bottom-left)
    createColorBox(14, 4, 10, -35, 2, 15, sand);
    createColorBox(14, 1.5, 10, -35, 4.75, 15, sandDark);
    createColorBox(2, 1.5, 0.3, -30, 2.5, 20, window);
    createColorBox(2, 1.5, 0.3, -40, 2.5, 20, window);
    
    // Building 4 (bottom-right)
    createColorBox(14, 5, 10, 35, 2.5, 15, sand);
    createColorBox(14, 1.5, 10, 35, 5.75, 15, sandDark);
    createColorBox(2, 1.5, 0.3, 30, 3, 20, window);
    createColorBox(2, 1.5, 0.3, 40, 3, 20, window);
    
    // === CENTER BUILDINGS ===
    // Left of mid
    createColorBox(8, 4, 8, -18, 2, 0, sand);
    createColorBox(8, 1, 8, -18, 4.5, 0, sandDark);
    // Right of mid
    createColorBox(8, 4, 8, 18, 2, 0, sand);
    createColorBox(8, 1, 8, 18, 4.5, 0, sandDark);
    // Above mid
    createColorBox(8, 4, 6, 0, 2, -15, sand);
    // Below mid
    createColorBox(8, 4, 6, 0, 2, 15, sand);
    
    // === CORRIDOR WALLS ===
    createColorBox(1, 4, 20, -10, 2, -28, sand);
    createColorBox(1, 4, 20, 10, 2, -28, sand);
    createColorBox(1, 4, 20, -10, 2, 28, sand);
    createColorBox(1, 4, 20, 10, 2, 28, sand);
    
    // === PALM TREES ===
    // Palm 1 near T spawn
    createColorCylinder(0.4, 5, -38, 2.5, 35, trunk);
    createColorBox(4, 0.3, 0.6, -38, 5.2, 35, palm);
    createColorBox(0.6, 0.3, 4, -38, 5.2, 35, palm);
    createColorBox(3, 0.2, 3, -38, 5, 35, 0x2E8B2E);
    
    // Palm 2 near CT spawn
    createColorCylinder(0.4, 5, 38, 2.5, -35, trunk);
    createColorBox(4, 0.3, 0.6, 38, 5.2, -35, palm);
    createColorBox(0.6, 0.3, 4, 38, 5.2, -35, palm);
    createColorBox(3, 0.2, 3, 38, 5, -35, 0x2E8B2E);
    
    // Palm 3 near mid
    createColorCylinder(0.35, 4, -8, 2, 8, trunk);
    createColorBox(3, 0.2, 0.5, -8, 4.2, 8, palm);
    createColorBox(0.5, 0.2, 3, -8, 4.2, 8, palm);
    
    // Palm 4
    createColorCylinder(0.35, 4, 8, 2, -8, trunk);
    createColorBox(3, 0.2, 0.5, 8, 4.2, -8, palm);
    createColorBox(0.5, 0.2, 3, 8, 4.2, -8, palm);
    
    // === FENCES ===
    // Fence near A site
    createColorBox(8, 1.2, 0.2, -28, 0.6, -26, fence);
    createColorBox(0.15, 1.2, 0.15, -32, 0.6, -26, wood);
    createColorBox(0.15, 1.2, 0.15, -28, 0.6, -26, wood);
    createColorBox(0.15, 1.2, 0.15, -24, 0.6, -26, wood);
    
    // Fence near B site
    createColorBox(8, 1.2, 0.2, 28, 0.6, 26, fence);
    createColorBox(0.15, 1.2, 0.15, 32, 0.6, 26, wood);
    createColorBox(0.15, 1.2, 0.15, 28, 0.6, 26, wood);
    createColorBox(0.15, 1.2, 0.15, 24, 0.6, 26, wood);
    
    // Low wall/fence mid area
    createColorBox(6, 0.8, 0.3, -5, 0.4, -10, fence);
    createColorBox(6, 0.8, 0.3, 5, 0.4, 10, fence);
    
    // === COVER CRATES ===
    createColorBox(2, 1.2, 2, -5, 0.6, -5, wood);
    createColorBox(2, 1.2, 2, 5, 0.6, 5, wood);
    createColorBox(2, 1.2, 2, -25, 0.6, -18, wood);
    createColorBox(2, 1.2, 2, 25, 0.6, 18, wood);
    createColorBox(2, 1.2, 2, 0, 0.6, -8, wood);
    createColorBox(2, 1.2, 2, 0, 0.6, 8, wood);
    createColorBox(1.5, 0.9, 1.5, -15, 0.45, 10, wood);
    createColorBox(1.5, 0.9, 1.5, 15, 0.45, -10, wood);
    // Stacked crates
    createColorBox(1.8, 1, 1.8, -25, 0.5, -18, wood);
    createColorBox(1.3, 0.8, 1.3, -25, 1.4, -18, wood);
    createColorBox(1.8, 1, 1.8, 25, 0.5, 18, wood);
    createColorBox(1.3, 0.8, 1.3, 25, 1.4, 18, wood);
    
    // === BARRELS ===
    createColorCylinder(0.5, 1, -20, 0.5, -5, wood);
    createColorCylinder(0.5, 1, 20, 0.5, 5, wood);
    createColorCylinder(0.5, 1, -3, 0.5, 20, 0x555555);
    createColorCylinder(0.5, 1, 3, 0.5, -20, 0x555555);
}

function createAimMap() {
    mapGroup.visible = true;
    CONFIG.map.size = AIM_MAP_SIZE;
    clearMap();
    
    // Hide enemies in 1v1 mode
    enemies.forEach(e => { 
        if (e.mesh) e.mesh.visible = false; 
        if (e.group) e.group.visible = false; 
    });

    // Floor tiles around perimeter
    const floorColor = 0x9e8c0a;
    const floorMat = new THREE.MeshStandardMaterial({ color: floorColor });
    
    // Create invisible ground for physics
    const groundGeo = new THREE.PlaneGeometry(32, 32);
    const ground = new THREE.Mesh(groundGeo, new THREE.MeshStandardMaterial({ color: 0x1a1a2e }));
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    ground.receiveShadow = true;
    mapGroup.add(ground);
    floor = ground;
    
    // Main floor platform
    createColorBox(26, 0.5, 28, -1, 0.25, 0, 0x9e8c0a);
    
    // Perimeter floor tiles (left side: x = -15)
    for (let z = -15; z <= 15; z += 2) {
        createColorBox(2, 0.5, 2, -15, 0.25, z, floorColor);
    }
    // Bottom side (z = 15)
    for (let x = -13; x <= 13; x += 2) {
        createColorBox(2, 0.5, 2, x, 0.25, 15, floorColor);
    }
    // Right side (x = 13)
    for (let z = -15; z <= 13; z += 2) {
        createColorBox(2, 0.5, 2, 13, 0.25, z, floorColor);
    }
    // Top side (z = -15)
    for (let x = -13; x <= 11; x += 2) {
        createColorBox(2, 0.5, 2, x, 0.25, -15, floorColor);
    }
    
    // Walls
    const wallColor = 0x74420c;
    createColorBox(1, 13.5, 32, -15.5, 7.25, 0, wallColor); // Left wall
    createColorBox(1, 13.5, 32, 13.5, 7.25, 0, wallColor);  // Right wall
    createColorBox(30, 13.5, 1, -1, 7.25, 15.5, wallColor); // Bottom wall
    createColorBox(30, 13.5, 1, -1, 7.25, -15.5, wallColor); // Top wall
    
    // Cover boxes (yellow/gold)
    createColorBox(3.5, 3.5, 3.5, 8.5, 2.25, 8, 0xd7ac1a);
    createColorBox(3.5, 3.5, 3.5, -10, 2.25, 9, 0xd7ac1a);
    createColorBox(3.5, 3.5, 3.5, -1, 2.25, 8.5, 0xd7ac1a);
    
    // Cylinders (black)
    createColorCylinder(2, 3, 4.5, 2, 0.5, 0x000000);
    createColorCylinder(2, 3, -6.5, 2, -6, 0x000000);
    
    // Light yellow boxes (bottom area)
    createColorBox(3.5, 3.5, 3.5, 8, 2.25, -10, 0xffe66d);
    createColorBox(3.5, 3.5, 3.5, -1, 2.25, -10, 0xffe66d);
    createColorBox(3.5, 3.5, 3.5, -10, 2.25, -10, 0xffe66d);
}

// Helper to create colored box
function createColorBox(w, h, d, x, y, z, color) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mapGroup.add(mesh);
    obstacles.push(mesh);
    colliders.push({ mesh, box: new THREE.Box3().setFromObject(mesh) });
    return mesh;
}

// Helper to create colored cylinder
function createColorCylinder(radius, height, x, y, z, color) {
    const geo = new THREE.CylinderGeometry(radius, radius, height, 16);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mapGroup.add(mesh);
    obstacles.push(mesh);
    colliders.push({ mesh, box: new THREE.Box3().setFromObject(mesh) });
    return mesh;
}

function createSandboxMap() {
    mapGroup.visible = true;
    CONFIG.map.size = 50;
    clearMap();
    const S = CONFIG.map.size;
    // Ground as collider box
    const ground = createBox(S * 2, 0.4, S * 2, 0, -0.2, 0, materials.sand, true);
    floor = ground;
    // Low walls to keep players inside
    createBox(S * 2, 3, 1, 0, 1.5, -S, materials.stone);
    createBox(S * 2, 3, 1, 0, 1.5, S, materials.stone);
    createBox(1, 3, S * 2, -S, 1.5, 0, materials.stone);
    createBox(1, 3, S * 2, S, 1.5, 0, materials.stone);
}

function getTeamSpawn(index = 0) {
    const team = index < 5 ? 'blue' : 'red';
    const offset = index % 5;
    const base = team === 'blue' ? { x: -20, z: -20 } : { x: 20, z: 20 };
    return new THREE.Vector3(base.x + offset * 2, CONFIG.player.height, base.z + offset * 2);
}

function getFfaSpawn(index = 0) {
    const angle = (index % 16) / 16 * Math.PI * 2;
    const radius = 22;
    return new THREE.Vector3(
        Math.cos(angle) * radius,
        CONFIG.player.height,
        Math.sin(angle) * radius
    );
}

function getSandboxSpawn() {
    return new THREE.Vector3(0, CONFIG.player.height, 0);
}

createDefaultMap();

// ==================== SANDBOX HELPERS ====================
function clearSandboxObjectsLocal() {
    sandboxObjects.forEach(obj => {
        if (obj.mesh) {
            scene.remove(obj.mesh);
            const obsIdx = obstacles.indexOf(obj.mesh);
            if (obsIdx !== -1) obstacles.splice(obsIdx, 1);
            const colIdx = colliders.findIndex(c => c.mesh === obj.mesh);
            if (colIdx !== -1) colliders.splice(colIdx, 1);
            if (obj.mesh.geometry) obj.mesh.geometry.dispose();
            if (obj.mesh.material) obj.mesh.material.dispose();
        }
    });
    sandboxObjects.length = 0;
}

function addSandboxObject(data, emitToServer = false) {
    if (!data) return;
    const shape = data.shape || 'box';
    const size = data.size || { w: 2, h: 2, d: 2 };
    const color = data.color || '#e94560';
    const pos = data.position || { x: 0, y: size.h / 2, z: 0 };
    const rot = data.rotation || { x: 0, y: 0, z: 0 };
    const id = data.id || (`sbx-${Date.now()}-${Math.random().toString(16).slice(2)}`);
    
    const geo = createEditorGeometry(shape, size);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(pos.x, pos.y, pos.z);
    mesh.rotation.set(rot.x || 0, rot.y || 0, rot.z || 0);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    scene.add(mesh);
    obstacles.push(mesh);
    colliders.push({ mesh, box: new THREE.Box3().setFromObject(mesh) });
    sandboxObjects.push({ id, mesh });
    
    if (emitToServer && mpSocket && mpSocket.connected && state.mpMode === 'sandbox') {
        mpSocket.emit('sandboxPlace', { ...data, id });
    }
}

function sandboxPlaceBlock() {
    if (!state.sandbox.active) return;
    const size = state.sandbox.tool.size || 2;
    const shape = state.sandbox.tool.shape || 'box';
    const color = state.sandbox.tool.color || '#e94560';
    
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    
    const targetPos = camera.position.clone().add(forward.multiplyScalar(4));
    const groundY = getGroundHeight(targetPos.x, targetPos.z);
    targetPos.y = groundY + size / 2;
    
    const data = {
        shape,
        color,
        size: { w: size, h: size, d: size },
        position: { x: targetPos.x, y: targetPos.y, z: targetPos.z },
        rotation: { x: 0, y: camera.rotation.y, z: 0 }
    };
    
    addSandboxObject(data, true);
}

function toggleHammer(forceState = null) {
    if (!state.sandbox.active) return;
    const shouldEnable = forceState !== null ? forceState : state.currentWeapon !== 'hammer';
    
    if (shouldEnable) {
        if (state.currentWeapon !== 'hammer') {
            state.savedWeaponBeforeHammer = state.currentWeapon;
        }
        switchWeapon('hammer');
        // Панель открываем только по U (ниже), курсор не освобождаем
        setSandboxPanelVisible(false);
    } else {
        setSandboxPanelVisible(false);
        const back = state.savedWeaponBeforeHammer || 'rifle';
        state.savedWeaponBeforeHammer = null;
        switchWeapon(back);
        if (!isMobile && state.isPlaying && !mapEditor.active) {
            document.getElementById('game-container')?.requestPointerLock();
        }
    }
}

function removeSandboxObject(id, emit = false) {
    const idx = sandboxObjects.findIndex(o => o.id === id);
    if (idx === -1) return;
    const obj = sandboxObjects[idx];
    if (obj.mesh) {
        scene.remove(obj.mesh);
        const obsIdx = obstacles.indexOf(obj.mesh);
        if (obsIdx !== -1) obstacles.splice(obsIdx, 1);
        const colIdx = colliders.findIndex(c => c.mesh === obj.mesh);
        if (colIdx !== -1) colliders.splice(colIdx, 1);
        if (obj.mesh.geometry) obj.mesh.geometry.dispose();
        if (obj.mesh.material) obj.mesh.material.dispose();
    }
    sandboxObjects.splice(idx, 1);
    if (emit && mpSocket && mpSocket.connected && state.mpMode === 'sandbox') {
        mpSocket.emit('sandboxRemove', { id });
    }
}

function removeSandboxAtRay() {
    if (!state.sandbox.active || sandboxObjects.length === 0) return;
    const meshes = sandboxObjects.map(o => o.mesh);
    const ray = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()).normalize(), 0, 200);
    const hits = ray.intersectObjects(meshes);
    if (hits.length > 0) {
        const hitMesh = hits[0].object;
        const found = sandboxObjects.find(o => o.mesh === hitMesh);
        if (found && found.id) {
            removeSandboxObject(found.id, true);
        }
    }
}

// ==================== WEAPON MODEL ====================
const weaponGroup = new THREE.Group();
const sniperGroup = new THREE.Group();
const knifeGroup = new THREE.Group();
const rocketLauncherGroup = new THREE.Group();
const hammerGroup = new THREE.Group();
const weaponPivot = new THREE.Group();

function createWeapon() {
    // === AK-47 (Rifle) ===
    // Main body
    const bodyGeo = new THREE.BoxGeometry(0.08, 0.12, 0.6);
    const body = new THREE.Mesh(bodyGeo, materials.metal);
    body.position.set(0, 0, -0.2);
    weaponGroup.add(body);
    
    // Barrel
    const barrelGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.4, 8);
    const barrel = new THREE.Mesh(barrelGeo, materials.metal);
    barrel.rotation.x = Math.PI / 2;
    barrel.position.set(0, 0.02, -0.7);
    weaponGroup.add(barrel);
    
    // Stock
    const stockGeo = new THREE.BoxGeometry(0.06, 0.1, 0.25);
    const stock = new THREE.Mesh(stockGeo, materials.wood);
    stock.position.set(0, -0.02, 0.15);
    weaponGroup.add(stock);
    
    // Magazine
    const magGeo = new THREE.BoxGeometry(0.04, 0.15, 0.08);
    const mag = new THREE.Mesh(magGeo, materials.metal);
    mag.position.set(0, -0.12, -0.15);
    mag.rotation.x = 0.2;
    weaponGroup.add(mag);
    
    // Grip
    const gripGeo = new THREE.BoxGeometry(0.05, 0.1, 0.06);
    const grip = new THREE.Mesh(gripGeo, materials.wood);
    grip.position.set(0, -0.1, 0);
    grip.rotation.x = 0.3;
    weaponGroup.add(grip);
    
    // Front grip
    const frontGripGeo = new THREE.BoxGeometry(0.04, 0.08, 0.04);
    const frontGrip = new THREE.Mesh(frontGripGeo, materials.metal);
    frontGrip.position.set(0, -0.08, -0.4);
    weaponGroup.add(frontGrip);
    
    // Sight
    const sightGeo = new THREE.BoxGeometry(0.03, 0.04, 0.06);
    const sight = new THREE.Mesh(sightGeo, materials.metal);
    sight.position.set(0, 0.08, -0.1);
    weaponGroup.add(sight);
    
    // Muzzle flash light
    const muzzleFlash = new THREE.PointLight(0xffaa00, 0, 5);
    muzzleFlash.position.set(0, 0.02, -0.9);
    muzzleFlash.name = 'muzzleFlash';
    weaponGroup.add(muzzleFlash);
    
    weaponGroup.position.set(0.25, -0.2, -0.5);
    weaponPivot.add(weaponGroup);
    
    // === AWP (Sniper) ===
    // Long body
    const sniperBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.06, 0.1, 0.9),
        materials.metal
    );
    sniperBody.position.set(0, 0, -0.3);
    sniperGroup.add(sniperBody);
    
    // Long barrel
    const sniperBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.02, 0.6, 8),
        materials.metal
    );
    sniperBarrel.rotation.x = Math.PI / 2;
    sniperBarrel.position.set(0, 0.02, -1.0);
    sniperGroup.add(sniperBarrel);
    
    // Scope
    const scopeBody = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8),
        materials.metal
    );
    scopeBody.rotation.x = Math.PI / 2;
    scopeBody.position.set(0, 0.1, -0.2);
    sniperGroup.add(scopeBody);
    
    // Scope lens front
    const scopeLens = new THREE.Mesh(
        new THREE.CircleGeometry(0.025, 8),
        new THREE.MeshBasicMaterial({ color: 0x4488ff })
    );
    scopeLens.position.set(0, 0.1, -0.1);
    sniperGroup.add(scopeLens);
    
    // Stock
    const sniperStock = new THREE.Mesh(
        new THREE.BoxGeometry(0.05, 0.12, 0.3),
        materials.wood
    );
    sniperStock.position.set(0, -0.02, 0.25);
    sniperGroup.add(sniperStock);
    
    // Grip
    const sniperGrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.04, 0.1, 0.05),
        materials.wood
    );
    sniperGrip.position.set(0, -0.1, 0.05);
    sniperGrip.rotation.x = 0.3;
    sniperGroup.add(sniperGrip);
    
    // Magazine
    const sniperMag = new THREE.Mesh(
        new THREE.BoxGeometry(0.03, 0.1, 0.06),
        materials.metal
    );
    sniperMag.position.set(0, -0.1, -0.1);
    sniperGroup.add(sniperMag);
    
    // Muzzle flash
    const sniperFlash = new THREE.PointLight(0xffaa00, 0, 8);
    sniperFlash.position.set(0, 0.02, -1.3);
    sniperFlash.name = 'muzzleFlash';
    sniperGroup.add(sniperFlash);
    
    sniperGroup.position.set(0.25, -0.2, -0.5);
    sniperGroup.visible = false;
    weaponPivot.add(sniperGroup);
    

    
    // === KNIFE ===
    const bladeGeo = new THREE.BoxGeometry(0.02, 0.04, 0.25);
    const bladeMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
    const blade = new THREE.Mesh(bladeGeo, bladeMat);
    blade.position.set(0, 0, -0.15);
    knifeGroup.add(blade);
    
    const edgeGeo = new THREE.BoxGeometry(0.005, 0.045, 0.25);
    const edgeMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    const edge = new THREE.Mesh(edgeGeo, edgeMat);
    edge.position.set(-0.01, 0, -0.15);
    knifeGroup.add(edge);
    
    const handleGeo = new THREE.BoxGeometry(0.03, 0.05, 0.12);
    const handle = new THREE.Mesh(handleGeo, materials.wood);
    handle.position.set(0, 0, 0.05);
    knifeGroup.add(handle);
    
    const guardGeo = new THREE.BoxGeometry(0.05, 0.06, 0.015);
    const guard = new THREE.Mesh(guardGeo, materials.metal);
    guard.position.set(0, 0, -0.02);
    knifeGroup.add(guard);
    
    knifeGroup.position.set(0.3, -0.15, -0.3);
    knifeGroup.rotation.x = -0.3;
    knifeGroup.visible = false;
    weaponPivot.add(knifeGroup);
    
    // Create Rocket Launcher for Party Mode
    // Main tube
    const tubeGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 16);
    const tubeMat = new THREE.MeshPhongMaterial({ 
        color: 0x2d2d2d,
        shininess: 80 
    });
    const tube = new THREE.Mesh(tubeGeo, tubeMat);
    tube.rotation.x = Math.PI / 2;
    tube.position.z = -0.2;
    rocketLauncherGroup.add(tube);
    
    // Front opening (bright)
    const frontRingGeo = new THREE.TorusGeometry(0.08, 0.015, 8, 16);
    const frontRingMat = new THREE.MeshPhongMaterial({ 
        color: 0xff6b6b,
        emissive: 0x331111 
    });
    const frontRing = new THREE.Mesh(frontRingGeo, frontRingMat);
    frontRing.position.z = -0.6;
    rocketLauncherGroup.add(frontRing);
    
    // Handle/grip
    const rlHandleGeo = new THREE.BoxGeometry(0.04, 0.15, 0.08);
    const rlHandleMat = new THREE.MeshPhongMaterial({ color: 0x4a3728 });
    const rlHandle = new THREE.Mesh(rlHandleGeo, rlHandleMat);
    rlHandle.position.set(0, -0.12, 0.1);
    rocketLauncherGroup.add(rlHandle);
    
    // Colorful stripes for party feel
    const stripeColors = [0xff6b6b, 0xfeca57, 0x48dbfb, 0xff9ff3, 0x1dd1a1];
    for (let i = 0; i < 5; i++) {
        const stripeGeo = new THREE.CylinderGeometry(0.082, 0.082, 0.04, 16);
        const stripeMat = new THREE.MeshPhongMaterial({ 
            color: stripeColors[i],
            emissive: stripeColors[i],
            emissiveIntensity: 0.3
        });
        const stripe = new THREE.Mesh(stripeGeo, stripeMat);
        stripe.rotation.x = Math.PI / 2;
        stripe.position.z = -0.5 + i * 0.15;
        rocketLauncherGroup.add(stripe);
    }
    
    rocketLauncherGroup.position.set(0.35, -0.2, -0.4);
    rocketLauncherGroup.rotation.x = -0.1;
    rocketLauncherGroup.visible = false;
    weaponPivot.add(rocketLauncherGroup);

    // Hammer (simple model)
    const hammerHandleGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 8);
    const hammerHandleMat = new THREE.MeshPhongMaterial({ color: 0x8b5a2b });
    const hammerHandle = new THREE.Mesh(hammerHandleGeo, hammerHandleMat);
    hammerHandle.position.set(0, -0.2, 0);
    hammerGroup.add(hammerHandle);
    const hammerHeadGeo = new THREE.BoxGeometry(0.16, 0.12, 0.24);
    const hammerHeadMat = new THREE.MeshPhongMaterial({ color: 0x555555 });
    const hammerHead = new THREE.Mesh(hammerHeadGeo, hammerHeadMat);
    hammerHead.position.set(0, 0.1, -0.05);
    hammerGroup.add(hammerHead);
    hammerGroup.position.set(0.25, -0.1, -0.4);
    hammerGroup.rotation.x = -0.3;
    hammerGroup.visible = false;
    weaponPivot.add(hammerGroup);
    
    camera.add(weaponPivot);
}

function switchWeapon(weapon) {
    if (state.isReloading) return;
    if (state.currentWeapon === weapon) return;
    if (weapon === 'hammer' && !state.sandbox.active) return;
    // In party mode, only allow switching to rocketLauncher
    if (state.partyMode && weapon !== 'rocketLauncher') return;
    
    state.currentWeapon = weapon;
    state.canShoot = true; // reset fire lock on weapon switch
    state.knifeCooldown = false;
    state.isScoped = false;
    document.getElementById('scope-overlay').classList.remove('active');
    document.getElementById('crosshair').style.display = 'block';
    camera.fov = 75;
    camera.updateProjectionMatrix();
    
    // Hide all weapons
    weaponGroup.visible = false;
    sniperGroup.visible = false;
    knifeGroup.visible = false;
    rocketLauncherGroup.visible = false;
    hammerGroup.visible = false;
    if (weapon !== 'hammer') {
        setSandboxPanelVisible(false);
    }
    
    if (weapon === 'rifle') {
        weaponGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'AK-47';
        document.getElementById('current-ammo').textContent = state.ammo;
        document.getElementById('reserve-ammo').textContent = state.reserveAmmo;
        document.getElementById('ammo').style.display = 'block';
    } else if (weapon === 'sniper') {
        sniperGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'AWP';
        document.getElementById('current-ammo').textContent = state.sniperAmmo;
        document.getElementById('reserve-ammo').textContent = state.sniperReserve;
        document.getElementById('ammo').style.display = 'block';
    } else if (weapon === 'knife') {
        knifeGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'Нож';
        document.getElementById('ammo').style.display = 'none';
    } else if (weapon === 'rocketLauncher') {
        rocketLauncherGroup.visible = true;
        document.getElementById('weapon-name').textContent = '🎆 Ракетница';
        document.getElementById('ammo').style.display = 'none';
    } else if (weapon === 'hammer') {
        hammerGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'Молоток';
        document.getElementById('ammo').style.display = 'none';
        const panel = document.getElementById('sandbox-tools');
        if (panel) panel.style.display = 'block';
    } else {
        document.getElementById('ammo').style.display = 'none';
    }
}

function toggleScope() {
    if (state.currentWeapon !== 'sniper') return;
    
    state.isScoped = !state.isScoped;
    
    if (state.isScoped) {
        document.getElementById('scope-overlay').classList.add('active');
        document.getElementById('crosshair').style.display = 'none';
        sniperGroup.visible = false;
        camera.fov = 75 / CONFIG.sniper.scopeZoom;
    } else {
        document.getElementById('scope-overlay').classList.remove('active');
        document.getElementById('crosshair').style.display = 'block';
        sniperGroup.visible = true;
        camera.fov = 75;
    }
    camera.updateProjectionMatrix();
}

createWeapon();
scene.add(camera);

// Weapon sway variables
let weaponSwayTime = 0;
let weaponRecoil = 0;
let targetWeaponRecoil = 0;

// ==================== ENEMIES ====================
const enemies = [];

class Enemy {
    constructor(x, z) {
        this.health = CONFIG.enemy.health;
        this.maxHealth = CONFIG.enemy.health;
        this.speed = CONFIG.enemy.speed;
        this.isAlive = true;
        this.lastShot = 0;
        this.state = 'idle'; // idle, patrol, chase, attack, cover
        this.stateTimer = 0;
        this.coverPos = null;
        this.patrolTarget = new THREE.Vector3(x, 0, z);
        
        // Smooth movement variables
        this.currentDirection = new THREE.Vector3(0, 0, 1);
        this.stuckTimer = 0;
        this.lastPosition = new THREE.Vector3(x, 0, z);
        
        // Jump variables
        this.velocityY = 0;
        this.isGrounded = true;
        this.jumpCooldown = 0;
        
        // Pathfinding - waypoints
        this.waypoints = [];
        this.currentWaypoint = 0;
        this.pathfindTimer = 0;
        
        // Burst fire (automatic)
        this.isFiring = false;
        this.burstShotsLeft = 0;
        this.burstTimer = 0;
        this.burstCooldown = 0;
        this.fireworkCooldown = 0; // Cooldown for party mode fireworks
        
        // Body
        this.group = new THREE.Group();
        
        // Torso
        const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.1, 8);
        this.mesh = new THREE.Mesh(torsoGeo, materials.enemy);
        this.mesh.position.y = 1;
        this.mesh.castShadow = true;
        this.group.add(this.mesh);
        
        // Head (хитбокс)
        const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
        this.head = new THREE.Mesh(headGeo, materials.enemy);
        this.head.position.y = 1.8;
        this.head.castShadow = true;
        this.head.name = 'head';
        this.group.add(this.head);
        
        // Weapon
        this.weaponGroup = new THREE.Group();
        const gunBody = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.08, 0.4),
            materials.metal
        );
        gunBody.position.z = -0.2;
        this.weaponGroup.add(gunBody);
        
        const gunBarrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.02, 0.25, 6),
            materials.metal
        );
        gunBarrel.rotation.x = Math.PI / 2;
        gunBarrel.position.z = -0.5;
        this.weaponGroup.add(gunBarrel);
        
        // Muzzle flash for enemy
        this.muzzleFlash = new THREE.PointLight(0xffaa00, 0, 3);
        this.muzzleFlash.position.z = -0.6;
        this.weaponGroup.add(this.muzzleFlash);
        
        this.weaponGroup.position.set(0.3, 1.1, 0);
        this.group.add(this.weaponGroup);
        
        // Health bar background
    const hbBgGeo = new THREE.PlaneGeometry(0.8, 0.08);
    const hbBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide, depthTest: true, depthWrite: true });
        this.healthBarBg = new THREE.Mesh(hbBgGeo, hbBgMat);
        this.healthBarBg.position.y = 2.3;
    this.healthBarBg.renderOrder = 5;
        this.group.add(this.healthBarBg);
        
        // Health bar fill
    const hbFillGeo = new THREE.PlaneGeometry(0.78, 0.06);
    const hbFillMat = new THREE.MeshBasicMaterial({ color: 0xe94560, side: THREE.DoubleSide, depthTest: true, depthWrite: true });
        this.healthBarFill = new THREE.Mesh(hbFillGeo, hbFillMat);
        this.healthBarFill.position.y = 2.3;
        this.healthBarFill.position.z = 0.01;
    this.healthBarFill.renderOrder = 6;
        this.group.add(this.healthBarFill);
        
        this.group.position.set(x, 0, z);
        scene.add(this.group);
        
        this.velocity = new THREE.Vector3();
        
        // Enemy gunshot sound (individual per enemy)
        this.gunSound = new Audio('sounds/kalash.mp3');
        this.gunSound.volume = 0.5;
        this.gunSoundTimer = null;
    }
    
    playGunSound() {
        try {
            const maxDistance = 50;
            const distance = this.group.position.distanceTo(camera.position);
            if (distance > maxDistance) return;
            
            // Calculate volume based on distance (closer = louder)
            const volume = Math.max(0.1, 1 - (distance / maxDistance)) * 0.6;
            this.gunSound.volume = volume;
            
            // If not playing, start from beginning
            if (this.gunSound.paused) {
                this.gunSound.currentTime = 0;
                this.gunSound.play().catch(() => {});
            }
            
            // Extend stop timer (each shot = ~0.5 sec of sound)
            if (this.gunSoundTimer) clearTimeout(this.gunSoundTimer);
            this.gunSoundTimer = setTimeout(() => {
                try {
                    this.gunSound.pause();
                    this.gunSound.currentTime = 0;
                } catch (e) {}
            }, 500);
        } catch (e) {}
    }
    
    canSeePlayer(playerPos) {
        const dir = new THREE.Vector3().subVectors(playerPos, this.group.position).normalize();
        const ray = new THREE.Raycaster(
            new THREE.Vector3(this.group.position.x, 1.5, this.group.position.z),
            dir
        );
        const hits = ray.intersectObjects(colliders.map(c => c.mesh));
        const distToPlayer = this.group.position.distanceTo(playerPos);
        
        if (hits.length === 0 || hits[0].distance > distToPlayer) {
            return true;
        }
        return false;
    }
    
    findCover(playerPos) {
        let bestCover = null;
        let bestScore = -Infinity;
        
        colliders.forEach(c => {
            const coverPos = c.mesh.position.clone();
            const dirFromPlayer = new THREE.Vector3().subVectors(coverPos, playerPos).normalize();
            const testPos = coverPos.clone().add(dirFromPlayer.multiplyScalar(2));
            testPos.y = 0;
            
            const distToPlayer = testPos.distanceTo(playerPos);
            const distToSelf = testPos.distanceTo(this.group.position);
            
            if (distToPlayer > 8 && distToPlayer < 30) {
                const score = distToPlayer - distToSelf * 0.5;
                if (score > bestScore) {
                    bestScore = score;
                    bestCover = testPos;
                }
            }
        });
        
        return bestCover;
    }
    
    // Check if can move in direction
    canMoveInDirection(dir, distance = 1.5) {
        const origin = new THREE.Vector3(this.group.position.x, 1, this.group.position.z);
        const ray = new THREE.Raycaster(origin, dir.clone().normalize(), 0, distance);
        const hits = ray.intersectObjects(colliders.map(c => c.mesh));
        return hits.length === 0;
    }
    
    // Get steering direction to avoid obstacles
    getSteeringDirection(targetDir) {
        // If direct path is clear, go straight
        if (this.canMoveInDirection(targetDir, 2)) {
            return targetDir.clone();
        }
        
        // Try to find clear path by checking angles
        const angles = [25, 50, 75, 100, 125, 150];
        for (const angle of angles) {
            // Try right
            const rightDir = targetDir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), -angle * Math.PI / 180);
            if (this.canMoveInDirection(rightDir, 2)) {
                return rightDir;
            }
            // Try left
            const leftDir = targetDir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle * Math.PI / 180);
            if (this.canMoveInDirection(leftDir, 2)) {
                return leftDir;
            }
        }
        
        // All blocked - go back
        return targetDir.clone().negate();
    }
    
    // Check if stuck
    checkStuck(delta) {
        const moved = this.group.position.distanceTo(this.lastPosition);
        if (moved < 0.05) {
            this.stuckTimer += delta;
        } else {
            this.stuckTimer = Math.max(0, this.stuckTimer - delta * 2);
        }
        this.lastPosition.copy(this.group.position);
        return this.stuckTimer > 0.4;
    }
    
    // Check if severely stuck (for teleport)
    isSeverelyStuck() {
        return this.stuckTimer > 2.0;
    }
    
    // Get unstuck by finding nearest valid position
    getUnstuckPosition() {
        const pos = this.group.position;
        const angles = [0, 30, 60, 90, 120, 150, 180, -30, -60, -90, -120, -150];
        const distances = [2, 3, 5, 7, 10];
        
        for (const dist of distances) {
            for (const angle of angles) {
                const rad = angle * Math.PI / 180;
                const testPos = new THREE.Vector3(
                    pos.x + Math.cos(rad) * dist,
                    0,
                    pos.z + Math.sin(rad) * dist
                );
                if (this.isPositionValid(testPos)) {
                    // Check if we can reach it OR if we're severely stuck just teleport
                    if (this.hasDirectPath(pos, testPos) || this.stuckTimer > 1.5) {
                        return testPos;
                    }
                }
            }
        }
        return null;
    }
    
    // Force teleport to valid position when stuck too long
    forceUnstuck() {
        const pos = this.group.position;
        
        // Try to find any valid position
        const angles = [0, 45, 90, 135, 180, 225, 270, 315];
        const distances = [3, 5, 8, 12, 15];
        
        for (const dist of distances) {
            for (const angle of angles) {
                const rad = angle * Math.PI / 180;
                const testPos = new THREE.Vector3(
                    pos.x + Math.cos(rad) * dist,
                    0,
                    pos.z + Math.sin(rad) * dist
                );
                if (this.isPositionValid(testPos)) {
                    // Teleport!
                    this.group.position.x = testPos.x;
                    this.group.position.z = testPos.z;
                    this.group.position.y = 0;
                    this.stuckTimer = 0;
                    this.waypoints = [];
                    this.pathfindTimer = 0;
                    return true;
                }
            }
        }
        
        // Last resort - teleport to random spawn position
        const bound = CONFIG.map.size - 10;
        this.group.position.set(
            (Math.random() - 0.5) * bound,
            0,
            (Math.random() - 0.5) * bound
        );
        this.stuckTimer = 0;
        this.waypoints = [];
        return true;
    }
    
    // Check if position is on ground (not floating)
    isOnGround() {
        return this.group.position.y <= 0.1;
    }
    
    // Fix floating enemies
    fixFloating() {
        if (this.group.position.y > 0.5 && this.isGrounded) {
            this.group.position.y = 0;
        }
    }
    
    // A*-like pathfinding
    findPathTo(targetPos) {
        const start = this.group.position.clone();
        const end = targetPos.clone();
        start.y = 0;
        end.y = 0;
        
        // Direct path check
        if (this.hasDirectPath(start, end)) {
            return [end];
        }
        
        // Grid-based A* pathfinding
        const gridSize = 2; // Grid cell size
        const maxNodes = 200; // Max nodes to explore
        
        // Convert position to grid coords
        const toGrid = (pos) => ({
            x: Math.round(pos.x / gridSize),
            z: Math.round(pos.z / gridSize)
        });
        const toWorld = (grid) => new THREE.Vector3(grid.x * gridSize, 0, grid.z * gridSize);
        const gridKey = (g) => `${g.x},${g.z}`;
        
        const startGrid = toGrid(start);
        const endGrid = toGrid(end);
        
        // A* data structures
        const openSet = [{ grid: startGrid, f: 0, g: 0, parent: null }];
        const closedSet = new Set();
        const gScores = new Map();
        gScores.set(gridKey(startGrid), 0);
        
        // Heuristic - Manhattan distance
        const heuristic = (a, b) => Math.abs(a.x - b.x) + Math.abs(a.z - b.z);
        
        // Neighbors (8 directions)
        const neighbors = [
            {x: 1, z: 0}, {x: -1, z: 0}, {x: 0, z: 1}, {x: 0, z: -1},
            {x: 1, z: 1}, {x: 1, z: -1}, {x: -1, z: 1}, {x: -1, z: -1}
        ];
        
        let iterations = 0;
        let foundPath = null;
        
        while (openSet.length > 0 && iterations < maxNodes) {
            iterations++;
            
            // Get node with lowest f score
            openSet.sort((a, b) => a.f - b.f);
            const current = openSet.shift();
            const currentKey = gridKey(current.grid);
            
            // Check if reached goal (within 1 cell)
            if (Math.abs(current.grid.x - endGrid.x) <= 1 && 
                Math.abs(current.grid.z - endGrid.z) <= 1) {
                foundPath = current;
                break;
            }
            
            closedSet.add(currentKey);
            
            // Explore neighbors
            for (const dir of neighbors) {
                const neighborGrid = {
                    x: current.grid.x + dir.x,
                    z: current.grid.z + dir.z
                };
                const neighborKey = gridKey(neighborGrid);
                
                if (closedSet.has(neighborKey)) continue;
                
                const neighborWorld = toWorld(neighborGrid);
                
                // Check if valid position
                if (!this.isPositionValid(neighborWorld)) continue;
                
                // Check if can walk there
                const currentWorld = toWorld(current.grid);
                if (!this.hasDirectPath(currentWorld, neighborWorld)) continue;
                
                // Calculate scores
                const moveCost = (dir.x !== 0 && dir.z !== 0) ? 1.414 : 1; // Diagonal cost
                const tentativeG = current.g + moveCost;
                
                const existingG = gScores.get(neighborKey);
                if (existingG !== undefined && tentativeG >= existingG) continue;
                
                gScores.set(neighborKey, tentativeG);
                const h = heuristic(neighborGrid, endGrid);
                const f = tentativeG + h;
                
                // Add to open set
                const existingIndex = openSet.findIndex(n => gridKey(n.grid) === neighborKey);
                if (existingIndex >= 0) {
                    openSet[existingIndex] = { grid: neighborGrid, f, g: tentativeG, parent: current };
                } else {
                    openSet.push({ grid: neighborGrid, f, g: tentativeG, parent: current });
                }
            }
        }
        
        // Reconstruct path
        if (foundPath) {
            const path = [];
            let node = foundPath;
            while (node) {
                path.unshift(toWorld(node.grid));
                node = node.parent;
            }
            // Simplify path - remove unnecessary waypoints
            const simplified = this.simplifyPath(path);
            simplified.push(end); // Add final destination
            return simplified;
        }
        
        // Fallback - try simple waypoint system
        return this.findSimplePath(start, end);
    }
    
    // Simplify path by removing points that have direct line of sight
    simplifyPath(path) {
        if (path.length <= 2) return path;
        
        const simplified = [path[0]];
        let current = 0;
        
        while (current < path.length - 1) {
            let furthest = current + 1;
            
            // Find furthest point with direct path
            for (let i = current + 2; i < path.length; i++) {
                if (this.hasDirectPath(path[current], path[i])) {
                    furthest = i;
                }
            }
            
            simplified.push(path[furthest]);
            current = furthest;
        }
        
        return simplified;
    }
    
    // Simple fallback pathfinding
    findSimplePath(start, end) {
        const dir = end.clone().sub(start).normalize();
        const waypoints = [];
        
        // Try multiple angles and distances
        const angles = [30, 60, 90, 120, 150, -30, -60, -90, -120, -150];
        const distances = [4, 8, 12, 16];
        
        let bestPath = null;
        let bestScore = Infinity;
        
        for (const angle of angles) {
            for (const dist of distances) {
                const radians = angle * Math.PI / 180;
                const sideDir = dir.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), radians);
                const waypoint = start.clone().add(sideDir.multiplyScalar(dist));
                
                if (!this.isPositionValid(waypoint)) continue;
                if (!this.hasDirectPath(start, waypoint)) continue;
                
                // Check if this waypoint helps reach target
                const distFromWaypoint = waypoint.distanceTo(end);
                
                // Can we go directly from waypoint to end?
                if (this.hasDirectPath(waypoint, end)) {
                    const score = dist * 0.5 + distFromWaypoint;
                    if (score < bestScore) {
                        bestScore = score;
                        bestPath = [waypoint, end];
                    }
                } else {
                    // Try to find second waypoint
                    for (const angle2 of [0, 30, -30, 60, -60]) {
                        for (const dist2 of [4, 8]) {
                            const dir2 = end.clone().sub(waypoint).normalize();
                            const radians2 = angle2 * Math.PI / 180;
                            const sideDir2 = dir2.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), radians2);
                            const waypoint2 = waypoint.clone().add(sideDir2.multiplyScalar(dist2));
                            
                            if (!this.isPositionValid(waypoint2)) continue;
                            if (!this.hasDirectPath(waypoint, waypoint2)) continue;
                            
                            if (this.hasDirectPath(waypoint2, end)) {
                                const score = dist * 0.3 + dist2 * 0.3 + waypoint2.distanceTo(end);
                                if (score < bestScore) {
                                    bestScore = score;
                                    bestPath = [waypoint, waypoint2, end];
                                }
                            }
                        }
                    }
                }
            }
        }
        
        return bestPath || [end];
    }
    
    // Check if there's a direct path between two points
    hasDirectPath(from, to) {
        const dir = to.clone().sub(from);
        dir.y = 0;
        const dist = dir.length();
        if (dist < 0.1) return true;
        dir.normalize();
        
        // Check at multiple heights for better accuracy
        const heights = [0.5, 1.0, 1.5];
        for (const h of heights) {
            const ray = new THREE.Raycaster(
                new THREE.Vector3(from.x, h, from.z),
                dir,
                0,
                dist
            );
            const hits = ray.intersectObjects(colliders.map(c => c.mesh));
            if (hits.length > 0) return false;
        }
        return true;
    }
    
    // Check path with width (for wider enemies)
    hasWidePath(from, to, width = 0.8) {
        if (!this.hasDirectPath(from, to)) return false;
        
        const dir = to.clone().sub(from);
        dir.y = 0;
        dir.normalize();
        
        // Check sides
        const perp = new THREE.Vector3(-dir.z, 0, dir.x);
        const left = from.clone().add(perp.clone().multiplyScalar(width / 2));
        const right = from.clone().add(perp.clone().multiplyScalar(-width / 2));
        const leftEnd = to.clone().add(perp.clone().multiplyScalar(width / 2));
        const rightEnd = to.clone().add(perp.clone().multiplyScalar(-width / 2));
        
        return this.hasDirectPath(left, leftEnd) && this.hasDirectPath(right, rightEnd);
    }
    
    // Check if position is valid (not inside obstacle, on ground)
    isPositionValid(pos) {
        // Check bounds
        const bound = CONFIG.map.size - 2;
        if (Math.abs(pos.x) > bound || Math.abs(pos.z) > bound) return false;
        
        // Check collision with obstacles at ground level
        const box = new THREE.Box3().setFromCenterAndSize(
            new THREE.Vector3(pos.x, 1, pos.z),
            new THREE.Vector3(1.2, 2, 1.2)
        );
        for (const collider of colliders) {
            if (box.intersectsBox(collider.box)) return false;
        }
        
        // Check that position is on ground (not on top of platform)
        // Cast ray down to check ground height
        const rayOrigin = new THREE.Vector3(pos.x, 10, pos.z);
        const rayDir = new THREE.Vector3(0, -1, 0);
        const ray = new THREE.Raycaster(rayOrigin, rayDir, 0, 15);
        const hits = ray.intersectObjects(colliders.map(c => c.mesh));
        
        // If there's something below, check if it's too high (platform)
        if (hits.length > 0) {
            const groundY = 10 - hits[0].distance;
            // If ground is above 0.5, it's a platform - not valid
            if (groundY > 0.5) return false;
        }
        
        return true;
    }
    
    // Check if jumping would help overcome obstacle
    canJumpOverObstacle(direction) {
        const pos = this.group.position;
        const checkDistance = 1.5;
        
        // Check if there's an obstacle at ground level in front
        const groundRay = new THREE.Raycaster(
            new THREE.Vector3(pos.x, 0.5, pos.z),
            direction.clone().normalize(),
            0, checkDistance
        );
        const groundHits = groundRay.intersectObjects(colliders.map(c => c.mesh));
        
        if (groundHits.length === 0) return false; // No obstacle
        
        const obstacle = groundHits[0];
        
        // Check obstacle height - can we jump over it?
        // Check if path is clear at jump height (1.5 units up)
        const jumpRay = new THREE.Raycaster(
            new THREE.Vector3(pos.x, 1.8, pos.z),
            direction.clone().normalize(),
            0, checkDistance + 0.5
        );
        const jumpHits = jumpRay.intersectObjects(colliders.map(c => c.mesh));
        
        // If clear at jump height, we can jump over
        if (jumpHits.length === 0) return true;
        
        // If obstacle at jump height is further away, we might clear the low one
        if (jumpHits[0].distance > obstacle.distance + 0.5) return true;
        
        return false;
    }
    
    // Perform jump
    jump() {
        if (this.isGrounded && this.jumpCooldown <= 0) {
            this.velocityY = 7; // Jump force
            this.isGrounded = false;
            this.jumpCooldown = 1.5; // Cooldown between jumps
        }
    }
    
    // Single shot
    fireShot(playerPos) {
        // In party mode, shoot fireworks instead!
        if (state.partyMode) {
            this.shootFirework(playerPos);
            return;
        }
        
        // Muzzle flash
        this.muzzleFlash.intensity = 2;
        setTimeout(() => { this.muzzleFlash.intensity = 0; }, 50);
        
        // Play gunshot sound (volume based on distance)
        this.playGunSound();
        
        // Accuracy check - accuracy decreases during burst
        const burstPenalty = Math.max(0, (5 - this.burstShotsLeft) * 0.05);
        const accuracy = CONFIG.enemy.accuracy - burstPenalty;
        
        if (Math.random() < accuracy) {
            applyPlayerDamage(CONFIG.enemy.damage);
        }
        
        // Tracer from enemy
        const start = this.group.position.clone();
        start.y = 1.5;
        const spread = (1 - accuracy) * 0.4;
        const end = playerPos.clone();
        end.x += (Math.random() - 0.5) * spread * 5;
        end.y += (Math.random() - 0.5) * spread * 5;
        end.z += (Math.random() - 0.5) * spread * 5;
        createTracer(start, end);
    }
    
    // Start burst fire (3-8 shots)
    startBurst() {
        if (this.burstCooldown > 0 || this.isFiring) return;
        this.isFiring = true;
        this.burstShotsLeft = 3 + Math.floor(Math.random() * 6); // 3-8 shots
        this.burstTimer = 0;
    }
    
    // Update burst fire
    updateBurst(delta, playerPos) {
        if (this.burstCooldown > 0) {
            this.burstCooldown -= delta;
        }
        if (this.fireworkCooldown > 0) {
            this.fireworkCooldown -= delta;
        }
        
        if (!this.isFiring) return;
        
        this.burstTimer -= delta;
        
        if (this.burstTimer <= 0 && this.burstShotsLeft > 0) {
            this.fireShot(playerPos);
            this.burstShotsLeft--;
            this.burstTimer = 0.08 + Math.random() * 0.04; // 80-120ms between shots
            
            if (this.burstShotsLeft <= 0) {
                this.isFiring = false;
                this.burstCooldown = 0.8 + Math.random() * 0.6; // 0.8-1.4s cooldown
            }
        }
    }
    
    // Legacy shoot - starts a burst
    shoot(playerPos) {
        this.startBurst();
    }
    
    // Shoot firework in party mode
    shootFirework(playerPos) {
        // Check cooldown - 7 seconds between shots
        if (this.fireworkCooldown > 0) return;
        this.fireworkCooldown = 7; // 7 second cooldown
        
        // Play firework sound
        try {
            const snd = state.sounds.firework.cloneNode();
            const dist = this.group.position.distanceTo(camera.position);
            snd.volume = Math.max(0.1, 0.5 - dist / 60);
            snd.playbackRate = 1.3;
            snd.play();
        } catch (e) {}
        
        // Direction towards player with some randomness for fun
        const direction = new THREE.Vector3()
            .subVectors(playerPos, this.group.position)
            .normalize();
        
        // Add slight random spread for variety
        direction.x += (Math.random() - 0.5) * 0.3;
        direction.y += (Math.random() - 0.5) * 0.3;
        direction.z += (Math.random() - 0.5) * 0.3;
        direction.normalize();
        
        // Start position at gun barrel
        const startPos = this.group.position.clone();
        startPos.y += 1.4; // Gun height
        startPos.add(direction.clone().multiplyScalar(0.8));
        
        const firework = new Firework(startPos, direction);
        state.partyFireworks.push(firework);
    }
    
    update(delta, playerPos) {
        if (!this.isAlive) return;
        
        // Update burst fire
        this.updateBurst(delta, playerPos);
        
        // Update pathfind timer
        this.pathfindTimer -= delta;
        
        // Face health bar to camera
        this.healthBarBg.lookAt(camera.position);
        this.healthBarFill.lookAt(camera.position);
        
        // Update health bar
        const healthPercent = this.health / this.maxHealth;
        this.healthBarFill.scale.x = Math.max(0.001, healthPercent);
        this.healthBarFill.position.x = (healthPercent - 1) * 0.39;
        
        const distToPlayer = this.group.position.distanceTo(playerPos);
        const canSee = this.canSeePlayer(playerPos);
        
        this.stateTimer -= delta;
        
        // AI State Machine - prioritize bomb if planted
        if (state.bombPlanted && state.bombPosition) {
            const distToBomb = this.group.position.distanceTo(state.bombPosition);
            if (distToBomb < 3) {
                this.state = 'defuse';
            } else if (distToBomb > 5) {
                this.state = 'go_bomb';
            }
        } else if (canSee && distToPlayer < CONFIG.enemy.detectionRange) {
            if (distToPlayer < CONFIG.enemy.attackRange) {
                this.state = 'attack';
            } else {
                this.state = 'chase';
            }
        } else if (this.state === 'attack' || this.state === 'chase') {
            this.state = 'cover';
            this.coverPos = this.findCover(playerPos);
            this.stateTimer = 3;
        } else if (this.stateTimer <= 0) {
            this.state = 'patrol';
            this.patrolTarget.set(
                (Math.random() - 0.5) * CONFIG.map.size * 1.2,
                0,
                (Math.random() - 0.5) * CONFIG.map.size * 1.2
            );
            this.stateTimer = 3 + Math.random() * 2;
        }
        
        // Execute state behavior
        let targetPos = null;
        let moveSpeed = this.speed;
        
        switch (this.state) {
            case 'defuse':
                targetPos = null;
                break;
                
            case 'go_bomb':
                targetPos = state.bombPosition.clone();
                moveSpeed = this.speed * 1.5;
                break;
            
            case 'attack':
                // Move towards player with strafing
                targetPos = playerPos.clone();
                if (distToPlayer > 10) {
                    // Get closer first
                    moveSpeed = this.speed * 0.9;
                } else if (distToPlayer > 5) {
                    // Strafe while approaching
                    moveSpeed = this.speed * 0.6;
                    // Add strafe offset
                    const strafeDir = new THREE.Vector3()
                        .subVectors(playerPos, this.group.position)
                        .normalize();
                    const perpendicular = new THREE.Vector3(-strafeDir.z, 0, strafeDir.x);
                    const strafeAmount = Math.sin(Date.now() * 0.003 + this.group.position.x) * 3;
                    targetPos.add(perpendicular.multiplyScalar(strafeAmount));
                } else {
                    // Circle strafe when very close
                    moveSpeed = this.speed * 0.5;
                    const angle = Date.now() * 0.002;
                    targetPos.x += Math.cos(angle) * 4;
                    targetPos.z += Math.sin(angle) * 4;
                }
                this.shoot(playerPos);
                break;
                
            case 'chase':
                targetPos = playerPos.clone();
                moveSpeed = this.speed * 1.2; // Faster when chasing
                // Predict player movement slightly
                if (state.isMoving) {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    targetPos.add(forward.multiplyScalar(2));
                }
                break;
                
            case 'cover':
                if (this.coverPos) {
                    targetPos = this.coverPos;
                    if (this.group.position.distanceTo(this.coverPos) < 2) {
                        this.stateTimer = 0;
                    }
                }
                break;
                
            case 'patrol':
            default:
                targetPos = this.patrolTarget;
                if (this.group.position.distanceTo(this.patrolTarget) < 3) {
                    this.stateTimer = 0; // Pick new target
                }
                moveSpeed = this.speed * 0.4;
                break;
        }
        
        // Fix floating enemies
        this.fixFloating();
        
        // Smooth movement with pathfinding
        if (targetPos) {
            // Check if we need to recalculate path (stuck or timer expired)
            const isStuck = this.checkStuck(delta);
            
            // Force teleport if severely stuck
            if (this.isSeverelyStuck()) {
                this.forceUnstuck();
                return; // Skip rest of update this frame
            }
            
            if (isStuck || this.pathfindTimer <= 0 || this.waypoints.length === 0) {
                // Recalculate path
                if (!this.hasDirectPath(this.group.position, targetPos)) {
                    this.waypoints = this.findPathTo(targetPos);
                    this.currentWaypoint = 0;
                } else {
                    this.waypoints = [targetPos];
                    this.currentWaypoint = 0;
                }
                this.pathfindTimer = 0.6 + Math.random() * 0.4; // Recalc more often (0.6-1 sec)
                
                if (isStuck) {
                    // Smart unstuck: find valid escape position
                    const escapePos = this.getUnstuckPosition();
                    if (escapePos) {
                        // Teleport to escape position if stuck for a while
                        if (this.stuckTimer > 1.0) {
                            this.group.position.x = escapePos.x;
                            this.group.position.z = escapePos.z;
                            this.group.position.y = 0;
                        } else {
                            this.waypoints = [escapePos, targetPos];
                            this.currentWaypoint = 0;
                            const escapeDir = escapePos.clone().sub(this.group.position).normalize();
                            this.currentDirection.copy(escapeDir);
                        }
                    } else {
                        // Fallback: random direction
                        const randomAngle = Math.random() * Math.PI * 2;
                        this.currentDirection.set(Math.cos(randomAngle), 0, Math.sin(randomAngle));
                    }
                    this.stuckTimer = 0;
                    this.pathfindTimer = 0.2; // Quick recalc after unstuck
                }
            }
            
            // Get current waypoint target
            let moveTarget = targetPos;
            if (this.waypoints.length > 0 && this.currentWaypoint < this.waypoints.length) {
                moveTarget = this.waypoints[this.currentWaypoint];
                
                // Check if reached waypoint
                const distToWaypoint = this.group.position.distanceTo(moveTarget);
                if (distToWaypoint < 2) {
                    this.currentWaypoint++;
                    if (this.currentWaypoint >= this.waypoints.length) {
                        moveTarget = targetPos;
                    } else {
                        moveTarget = this.waypoints[this.currentWaypoint];
                    }
                }
            }
            
            let desiredDir = new THREE.Vector3()
                .subVectors(moveTarget, this.group.position);
            desiredDir.y = 0;
            
            if (desiredDir.length() > 0.5) {
                desiredDir.normalize();
                
                // Get steering direction (avoids immediate obstacles)
                const steerDir = this.getSteeringDirection(desiredDir);
                
                // Smoothly interpolate current direction towards steering direction
                const turnSpeed = 6 * delta;
                this.currentDirection.lerp(steerDir, turnSpeed);
                this.currentDirection.normalize();
                
                // Calculate velocity
                this.velocity.x = this.currentDirection.x * moveSpeed;
                this.velocity.z = this.currentDirection.z * moveSpeed;
                
                // Try to move
                const newX = this.group.position.x + this.velocity.x * delta;
                const newZ = this.group.position.z + this.velocity.z * delta;
                
                // Check full movement first
                const enemyBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(newX, this.group.position.y + 1, newZ),
                    new THREE.Vector3(0.8, 2, 0.8)
                );
                
                let blocked = false;
                for (const collider of colliders) {
                    if (enemyBox.intersectsBox(collider.box)) {
                        blocked = true;
                        break;
                    }
                }
                
                if (!blocked) {
                    // Full movement OK
                    this.group.position.x = newX;
                    this.group.position.z = newZ;
                } else {
                    // Check if we can jump over the obstacle
                    if (this.isGrounded && this.jumpCooldown <= 0) {
                        if (this.canJumpOverObstacle(this.currentDirection)) {
                            this.jump();
                        }
                    }
                    
                    // Try wall sliding - move along the wall smoothly
                    // Check X movement
                    const xBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(newX, this.group.position.y + 1, this.group.position.z),
                        new THREE.Vector3(0.8, 2, 0.8)
                    );
                    let canX = true;
                    for (const collider of colliders) {
                        if (xBox.intersectsBox(collider.box)) { canX = false; break; }
                    }
                    
                    // Check Z movement
                    const zBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(this.group.position.x, this.group.position.y + 1, newZ),
                        new THREE.Vector3(0.8, 2, 0.8)
                    );
                    let canZ = true;
                    for (const collider of colliders) {
                        if (zBox.intersectsBox(collider.box)) { canZ = false; break; }
                    }
                    
                    // Apply whichever movement is allowed
                    if (canX) this.group.position.x = newX;
                    if (canZ) this.group.position.z = newZ;
                }
            }
        }
        
        // Jump cooldown
        if (this.jumpCooldown > 0) {
            this.jumpCooldown -= delta;
        }
        
        // Gravity and vertical movement
        if (!this.isGrounded) {
            this.velocityY -= 20 * delta; // Gravity
            this.group.position.y += this.velocityY * delta;
            
            // Ground check
            if (this.group.position.y <= 0) {
                this.group.position.y = 0;
                this.velocityY = 0;
                this.isGrounded = true;
            }
        }
        
        // Keep in bounds
        const bound = CONFIG.map.size - 2;
        this.group.position.x = Math.max(-bound, Math.min(bound, this.group.position.x));
        this.group.position.z = Math.max(-bound, Math.min(bound, this.group.position.z));
        
        // Face direction - smooth rotation
        let targetRotY = this.group.rotation.y;
        if (this.state === 'attack' || this.state === 'chase') {
            const lookDir = new THREE.Vector3().subVectors(playerPos, this.group.position);
            targetRotY = Math.atan2(lookDir.x, lookDir.z);
        } else if (this.currentDirection.length() > 0.1) {
            targetRotY = Math.atan2(this.currentDirection.x, this.currentDirection.z);
        }
        
        // Smoothly rotate towards target
        let rotDiff = targetRotY - this.group.rotation.y;
        // Normalize angle difference to -PI to PI
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        this.group.rotation.y += rotDiff * Math.min(1, 8 * delta);
    }
    
    takeDamage(amount, isHeadshot = false) {
        this.health -= amount;
        showHitmarker(isHeadshot);
        
        // React to damage - become aggressive
        this.state = 'chase';
        
        if (this.health <= 0) {
            this.die();
        }
    }
    
    die() {
        this.isAlive = false;
        state.kills++;
        updateHUD();
        
        // Death particles
        for (let i = 0; i < 12; i++) {
            createParticle(
                this.group.position.x,
                this.group.position.y + 1,
                this.group.position.z,
                0xe94560
            );
        }
        
        scene.remove(this.group);
        
        // Respawn after delay
        setTimeout(() => {
            this.respawn();
        }, 5000);
    }
    
    respawn() {
        this.health = this.maxHealth;
        this.isAlive = true;
        this.state = 'patrol';
        this.stateTimer = 2;
        this.velocityY = 0;
        this.isGrounded = true;
        this.jumpCooldown = 0;
        this.waypoints = [];
        this.currentWaypoint = 0;
        this.pathfindTimer = 0;
        this.isFiring = false;
        this.burstShotsLeft = 0;
        this.burstCooldown = 0;
        this.fireworkCooldown = 0;
        const bound = CONFIG.map.size - 10;
        this.group.position.set(
            (Math.random() - 0.5) * bound * 2,
            0,
            (Math.random() - 0.5) * bound * 2
        );
        scene.add(this.group);
    }
}

// Spawn enemies
function spawnEnemies() {
    const spawnPoints = [[32, 32], [-32, -32], [32, -32], [-32, 32]];
    
    spawnPoints.forEach(pos => {
        enemies.push(new Enemy(pos[0], pos[1]));
    });
}

spawnEnemies();

// ==================== PARTICLES ====================
const particles = [];

function createParticle(x, y, z, color) {
    const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const mat = new THREE.MeshBasicMaterial({ color });
    const particle = new THREE.Mesh(geo, mat);
    particle.position.set(x, y, z);
    particle.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8,
        (Math.random() - 0.5) * 10
    );
    particle.life = 1;
    scene.add(particle);
    particles.push(particle);
}

function updateParticles(delta) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.velocity.y -= 20 * delta;
        p.position.add(p.velocity.clone().multiplyScalar(delta));
        p.life -= delta * 2;
        p.material.opacity = p.life;
        p.scale.multiplyScalar(0.98);
        
        if (p.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
}

// ==================== TRACERS ====================
const tracers = [];

function createTracer(start, end) {
    const points = [start.clone(), end.clone()];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1 });
    const line = new THREE.Line(geo, mat);
    line.life = (state.cheats.enabled && state.cheats.rapidFire) ? 0.02 : 0.1;
    scene.add(line);
    tracers.push(line);
}

function updateTracers(delta) {
    for (let i = tracers.length - 1; i >= 0; i--) {
        const t = tracers[i];
        t.life -= delta;
        t.material.opacity = t.life * 10;
        
        if (t.life <= 0) {
            scene.remove(t);
            tracers.splice(i, 1);
        }
    }
}

function updateESPForActor(actor) {
    const active = state.cheats.enabled && state.cheats.esp;
    if (!actor) return;
    const mesh = actor.mesh || actor.body;
    const head = actor.head;
    const color = active ? 0x00ffea : 0x000000;
    if (mesh && mesh.material && 'emissive' in mesh.material) {
        mesh.material.emissive.setHex(color);
        mesh.material.depthTest = !active;
        mesh.material.depthWrite = !active;
        mesh.renderOrder = active ? 999 : 0;
    }
    if (head && head.material && 'emissive' in head.material) {
        head.material.emissive.setHex(color);
        head.material.depthTest = !active;
        head.material.depthWrite = !active;
        head.renderOrder = active ? 999 : 0;
    }
    const hbBg = actor.healthBarBg;
    const hbFill = actor.healthBarFill;
    [hbBg, hbFill].forEach((m, idx) => {
        if (!m || !m.material) return;
        m.material.depthTest = !active;
        m.material.depthWrite = !active;
        m.renderOrder = active ? 998 + idx : 0;
    });
}

function updateESPHighlight() {
    enemies.forEach(e => updateESPForActor(e));
    remotePlayers.forEach(p => updateESPForActor(p));
}

function getAimbotDirection(isSniper) {
    // Choose closest target by angle; prefer heads
    const candidates = [];
    if (!state.isMultiplayer) {
        enemies.filter(e => e.isAlive).forEach(e => {
            candidates.push({ pos: e.head ? e.head.getWorldPosition(new THREE.Vector3()) : e.group.position.clone().setY(1.6) });
        });
    }
    remotePlayers.forEach((p, id) => {
        if (p.isAlive && id !== (mpSocket && mpSocket.id)) {
            const pos = p.head ? p.head.getWorldPosition(new THREE.Vector3()) : p.group.position.clone().setY(1.6);
            candidates.push({ pos });
        }
    });
    if (candidates.length === 0) return null;
    const camPos = camera.position.clone();
    const viewDir = new THREE.Vector3();
    camera.getWorldDirection(viewDir);
    let best = null;
    candidates.forEach(c => {
        const dir = c.pos.clone().sub(camPos);
        const dist = dir.length();
        if (dist < 1) return;
        dir.normalize();
        const angle = viewDir.angleTo(dir);
        if (angle > Math.PI / 3) return; // FOV limit ~60 deg
        // If wallbang off, ensure line of sight
        if (!(state.cheats.enabled && state.cheats.wallbang)) {
            const rc = new THREE.Raycaster(camPos, dir);
            const hitWall = rc.intersectObjects(colliders.map(c => c.mesh));
            if (hitWall.length && hitWall[0].distance < dist - 0.2) return;
        }
        if (!best || angle < best.angle) {
            best = { dir, angle };
        }
    });
    return best ? best.dir : null;
}

function updateMpScore() {
    const board = document.getElementById('mp-score');
    if (!board) return;
    if (state.isMultiplayer) {
        board.style.display = 'flex';
        const me = document.getElementById('score-me');
        const en = document.getElementById('score-enemy');
        if (me) me.textContent = `You: ${state.mpKills}`;
        if (en) en.textContent = `Enemy: ${state.mpDeaths}`;
    } else {
        board.style.display = 'none';
    }
}

// ==================== GRENADES ====================
const grenades = [];
const grenadeMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });
const grenadeMaterialRemote = new THREE.MeshLambertMaterial({ color: 0x55ff55 });

function spawnGrenade(px, py, pz, vx, vy, vz, ownerId = null) {
    const grenadeGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const mat = ownerId && mpSocket && ownerId !== mpSocket.id ? grenadeMaterialRemote : grenadeMaterial;
    const grenade = new THREE.Mesh(grenadeGeo, mat);
    grenade.position.set(px, py, pz);
    grenade.velocity = new THREE.Vector3(vx, vy, vz);
    grenade.life = 1.5; // Faster explosion
    grenade.bounces = 0;
    scene.add(grenade);
    grenades.push(grenade);
}

function throwGrenade() {
    if (!state.isPlaying) return;
    
    // In party mode, throw party grenade instead
    if (state.partyMode) {
        throwPartyGrenade();
        return;
    }
    
    if (!state.canThrowGrenade || state.grenades <= 0) return;
    
    const infiniteAmmo = state.cheats.enabled && state.cheats.infiniteAmmo;
    if (!infiniteAmmo) state.grenades--;
    state.canThrowGrenade = false;
    updateHUD();
    
    const throwDir = new THREE.Vector3();
    camera.getWorldDirection(throwDir);
    throwDir.y += 0.3;
    throwDir.normalize();
    const vel = throwDir.multiplyScalar(25);
    const pos = camera.position.clone();
    
    spawnGrenade(pos.x, pos.y, pos.z, vel.x, vel.y, vel.z, mpSocket ? mpSocket.id : null);
    
    if (mpSocket && mpSocket.connected && state.isMultiplayer) {
        mpSocket.emit('grenade', { x: pos.x, y: pos.y, z: pos.z, vx: vel.x, vy: vel.y, vz: vel.z });
    }
    
    setTimeout(() => {
        state.canThrowGrenade = true;
    }, 500);
}

// Party grenade - firework explosion without damage
let partyGrenadeCooldown = false;

function throwPartyGrenade() {
    if (!state.isPlaying) return;
    if (partyGrenadeCooldown) return;
    
    partyGrenadeCooldown = true;
    setTimeout(() => partyGrenadeCooldown = false, 2000); // 2 sec cooldown
    
    // Play throw sound
    try {
        const snd = state.sounds.firework.cloneNode();
        snd.volume = 0.3;
        snd.play();
    } catch (e) {}
    
    const throwDir = new THREE.Vector3();
    camera.getWorldDirection(throwDir);
    throwDir.y += 0.4;
    throwDir.normalize();
    
    const pos = camera.position.clone();
    const velocity = throwDir.multiplyScalar(0.5);
    
    const partyGrenade = new PartyGrenade(pos, velocity);
    state.partyFireworks.push(partyGrenade);
}

// Party grenade class
class PartyGrenade {
    constructor(position, velocity) {
        // Create colorful grenade mesh
        const color = FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)];
        const geo = new THREE.SphereGeometry(0.15, 8, 8);
        const mat = new THREE.MeshPhongMaterial({ 
            color: color,
            emissive: color,
            emissiveIntensity: 0.5
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(position);
        this.color = color;
        
        this.velocity = velocity.clone();
        this.age = 0;
        this.maxAge = 1.5; // Explodes after 1.5 seconds
        this.exploded = false;
        
        scene.add(this.mesh);
    }
    
    update(delta) {
        if (this.exploded) return true;
        
        this.age += delta;
        
        // Physics - gravity and movement
        this.velocity.y -= 0.02;
        this.mesh.position.add(this.velocity);
        
        // Bounce on ground
        if (this.mesh.position.y < 0.15) {
            this.mesh.position.y = 0.15;
            this.velocity.y *= -0.5;
            this.velocity.x *= 0.8;
            this.velocity.z *= 0.8;
        }
        
        // Rotate for effect
        this.mesh.rotation.x += delta * 5;
        this.mesh.rotation.z += delta * 3;
        
        if (this.age >= this.maxAge) {
            this.explode();
            return true;
        }
        
        return false;
    }
    
    explode() {
        this.exploded = true;
        
        // Create explosion particles
        const particleCount = 30 + Math.floor(Math.random() * 15);
        const colors = [
            this.color,
            FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)],
            FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)]
        ];
        
        for (let i = 0; i < particleCount; i++) {
            const particle = new FireworkParticle(
                this.mesh.position.clone(),
                colors[i % colors.length]
            );
            state.partyFireworks.push(particle);
        }
        
        // Flash light
        const flashLight = new THREE.PointLight(this.color, 8, 20);
        flashLight.position.copy(this.mesh.position);
        scene.add(flashLight);
        setTimeout(() => scene.remove(flashLight), 200);
        
        // Remove grenade mesh
        scene.remove(this.mesh);
    }
}

function explodeGrenade(grenade) {
    const explosionPos = grenade.position.clone();
    const explosionRadius = 8;
    const maxDamage = 80;
    
    // Damage enemies
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        const dist = enemy.group.position.distanceTo(explosionPos);
        if (dist < explosionRadius) {
            const damage = maxDamage * (1 - dist / explosionRadius);
            enemy.takeDamage(damage);
        }
    });
    
    // Damage player
    const playerDist = camera.position.distanceTo(explosionPos);
    if (playerDist < explosionRadius) {
        const damage = maxDamage * 0.5 * (1 - playerDist / explosionRadius);
        applyPlayerDamage(damage);
    }
    
    // Explosion particles
    for (let i = 0; i < 30; i++) {
        createParticle(explosionPos.x, explosionPos.y, explosionPos.z, 0xff6600);
    }
    for (let i = 0; i < 20; i++) {
        createParticle(explosionPos.x, explosionPos.y, explosionPos.z, 0xffff00);
    }
    
    // Explosion flash
    const flash = new THREE.PointLight(0xff6600, 5, 15);
    flash.position.copy(explosionPos);
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 100);
    
    // Remove grenade
    scene.remove(grenade);
}

function updateGrenades(delta) {
    for (let i = grenades.length - 1; i >= 0; i--) {
        const g = grenades[i];
        
        // Gravity
        g.velocity.y -= 20 * delta;
        
        // Move
        const newPos = g.position.clone().add(g.velocity.clone().multiplyScalar(delta));
        
        // Ground bounce
        if (newPos.y < 0.15) {
            newPos.y = 0.15;
            g.velocity.y *= -0.4;
            g.velocity.x *= 0.7;
            g.velocity.z *= 0.7;
            g.bounces++;
        }
        
        // Wall collision (simple bounds check)
        const bound = CONFIG.map.size - 1;
        if (Math.abs(newPos.x) > bound) {
            g.velocity.x *= -0.5;
            newPos.x = Math.sign(newPos.x) * bound;
        }
        if (Math.abs(newPos.z) > bound) {
            g.velocity.z *= -0.5;
            newPos.z = Math.sign(newPos.z) * bound;
        }
        
        g.position.copy(newPos);
        
        // Timer
        g.life -= delta;
        if (g.life <= 0) {
            explodeGrenade(g);
            grenades.splice(i, 1);
        }
    }
}

// ==================== BOMB SYSTEM ====================
let bombMesh = null;
let bombLight = null;

function plantBomb() {
    if (state.isMultiplayer) return;
    if (state.bombPlanted) return;
    
    state.bombPlanted = true;
    state.bombTimer = 15;
    state.bombPosition = camera.position.clone();
    state.bombPosition.y = 0;
    
    // Create bomb mesh
    const bombGeo = new THREE.BoxGeometry(0.6, 0.3, 0.4);
    const bombMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    bombMesh = new THREE.Mesh(bombGeo, bombMat);
    bombMesh.position.copy(state.bombPosition);
    bombMesh.position.y = 0.15;
    bombMesh.castShadow = true;
    scene.add(bombMesh);
    
    // Blinking light
    bombLight = new THREE.PointLight(0xff0000, 1, 5);
    bombLight.position.copy(bombMesh.position);
    bombLight.position.y = 0.4;
    scene.add(bombLight);
    
    // Screen indicator
    const bombStatus = document.getElementById('bomb-status');
    bombStatus.style.display = 'block';
    bombStatus.classList.add('success');
    bombStatus.classList.remove('danger');
}

function updateBomb(delta) {
    if (!state.bombPlanted) return;
    
    const bombStatus = document.getElementById('bomb-status');
    
    // Blink light
    if (bombLight) {
        bombLight.intensity = Math.sin(Date.now() * 0.01) > 0 ? 2 : 0;
    }
    
    // Check if enemy is near bomb
    let enemyDefusing = false;
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        const dist = enemy.group.position.distanceTo(state.bombPosition);
        if (dist < 3) {
            enemyDefusing = true;
            enemy.state = 'defuse';
        }
    });
    
    if (enemyDefusing) {
        state.enemyDefusing = true;
        state.bombDefuseTimer += delta;
        bombStatus.textContent = `?? ВРАГ ОБЕЗВРЕЖИВАЕТ! ${(4 - state.bombDefuseTimer).toFixed(1)}s`;
        bombStatus.classList.add('danger');
        bombStatus.classList.remove('success');
        
        if (state.bombDefuseTimer >= 4) {
            // Enemy defused - player loses
            bombStatus.textContent = '💀 БОМБА ОБЕЗВРЕЖЕНА - ПОРАЖЕНИЕ';
            // Stop further updates to avoid UI flicker
            state.bombPlanted = false;
            state.bombTimer = 0;
            state.bombDefuseTimer = 0;
            if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
            if (bombLight) { scene.remove(bombLight); bombLight = null; }
            setTimeout(() => gameOver(), 300);
            return;
        }
    } else {
        state.enemyDefusing = false;
        state.bombDefuseTimer = 0;
        bombStatus.classList.remove('danger');
        bombStatus.classList.add('success');
    }
    
    // Countdown
    state.bombTimer -= delta;
    
    if (!enemyDefusing) {
        bombStatus.textContent = `💣 БОМБА: ${state.bombTimer.toFixed(1)}s`;
    }
    
    if (state.bombTimer <= 0) {
        // Bomb explodes - player wins!
        
        // Big explosion
        for (let i = 0; i < 50; i++) {
            createParticle(state.bombPosition.x, 2, state.bombPosition.z, 0xff6600);
            createParticle(state.bombPosition.x, 2, state.bombPosition.z, 0xffff00);
        }
        
        // Flash
        const flash = new THREE.PointLight(0xff6600, 10, 50);
        flash.position.copy(state.bombPosition);
        flash.position.y = 2;
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 200);
        
        // Kill all enemies
        enemies.forEach(e => {
            if (e.isAlive) e.die();
        });
        
        // Remove bomb
        if (bombMesh) scene.remove(bombMesh);
        if (bombLight) scene.remove(bombLight);
        
        state.bombPlanted = false;
        
        // Show win screen
        setTimeout(() => gameWin('bomb'), 500);
    }
}

// ==================== SHOOTING ====================
const raycaster = new THREE.Raycaster();

function hasLineOfSight(targetPoint) {
    if (state.cheats.enabled && state.cheats.wallbang) return true;
    const dir = targetPoint.clone().sub(camera.position);
    const dist = dir.length();
    if (dist < 0.01) return true;
    dir.normalize();
    const rc = new THREE.Raycaster(camera.position, dir);
    const wallHits = rc.intersectObjects(colliders.map(c => c.mesh), true);
    if (wallHits.length && wallHits[0].distance < dist - 0.05) return false;
    return true;
}

// ==================== FIREWORK SYSTEM ====================
const FIREWORK_COLORS = [
    0xff6b6b, 0xfeca57, 0x48dbfb, 0xff9ff3, 0x1dd1a1,
    0xff4757, 0x2ed573, 0x1e90ff, 0xffa502, 0xf368e0,
    0x00d2d3, 0xff6348, 0x7bed9f, 0x70a1ff, 0xeccc68
];

class Firework {
    constructor(position, direction) {
        this.mesh = new THREE.Group();
        this.color = FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)];
        
        // Main rocket body - more rocket-like
        const bodyGeo = new THREE.CylinderGeometry(0.04, 0.06, 0.4, 8);
        const bodyMat = new THREE.MeshPhongMaterial({ 
            color: this.color,
            emissive: this.color,
            emissiveIntensity: 0.4
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.rotation.x = Math.PI / 2;
        this.mesh.add(body);
        
        // Rocket nose cone
        const noseGeo = new THREE.ConeGeometry(0.04, 0.12, 8);
        const noseMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
        const nose = new THREE.Mesh(noseGeo, noseMat);
        nose.rotation.x = -Math.PI / 2;
        nose.position.z = -0.26;
        this.mesh.add(nose);
        
        // Fins
        const finGeo = new THREE.BoxGeometry(0.02, 0.1, 0.08);
        const finMat = new THREE.MeshPhongMaterial({ color: this.color });
        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(finGeo, finMat);
            fin.position.z = 0.15;
            fin.position.x = Math.cos(i * Math.PI / 2) * 0.06;
            fin.position.y = Math.sin(i * Math.PI / 2) * 0.06;
            this.mesh.add(fin);
        }
        
        // Trail light (bright engine glow)
        const light = new THREE.PointLight(0xff4400, 3, 8);
        light.position.z = 0.25;
        this.mesh.add(light);
        this.light = light;
        
        // Position and direction
        this.mesh.position.copy(position);
        this.direction = direction.clone().normalize();
        this.mesh.lookAt(position.clone().add(this.direction));
        
        this.speed = 0.4; // Slower speed
        this.age = 0;
        this.maxAge = 0.5; // 500ms before explosion
        this.exploded = false;
        this.trailTimer = 0;
        this.trailParticles = [];
        
        scene.add(this.mesh);
    }
    
    update(delta) {
        if (this.exploded) return true;
        
        this.age += delta;
        
        // Move straight in direction (no gravity, no slowdown)
        const movement = this.direction.clone().multiplyScalar(this.speed);
        this.mesh.position.add(movement);
        
        // Spawn trail particles
        this.trailTimer += delta;
        if (this.trailTimer > 0.02) { // Every 20ms
            this.trailTimer = 0;
            this.spawnTrailParticle();
        }
        
        // Flicker light
        this.light.intensity = 2.5 + Math.sin(this.age * 30) * 1;
        
        // Check collision with scene objects
        if (this.checkCollision()) {
            this.explode();
            return true;
        }
        
        // Explode after max age
        if (this.age >= this.maxAge) {
            this.explode();
            return true;
        }
        
        return false;
    }
    
    spawnTrailParticle() {
        const trailPos = this.mesh.position.clone().add(this.direction.clone().multiplyScalar(-0.2));
        const particle = new TrailParticle(trailPos, this.color);
        state.partyFireworks.push(particle);
    }
    
    checkCollision() {
        // Raycast forward to detect obstacles
        const raycaster = new THREE.Raycaster(
            this.mesh.position.clone(),
            this.direction.clone(),
            0,
            this.speed * 1.5
        );
        
        // Get all collidable objects (walls, floor, platforms)
        const collidables = [];
        scene.traverse((obj) => {
            if (obj.isMesh && obj !== this.mesh && 
                !obj.userData.isTrail && !obj.userData.isParticle &&
                !obj.userData.isPlayer && !obj.userData.isEnemy) {
                collidables.push(obj);
            }
        });
        
        const intersects = raycaster.intersectObjects(collidables, false);
        return intersects.length > 0;
    }
    
    explode() {
        this.exploded = true;
        
        // Create explosion particles
        const particleCount = 30 + Math.floor(Math.random() * 15);
        const colors = [
            this.color,
            FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)],
            FIREWORK_COLORS[Math.floor(Math.random() * FIREWORK_COLORS.length)]
        ];
        
        for (let i = 0; i < particleCount; i++) {
            const particle = new FireworkParticle(
                this.mesh.position.clone(),
                colors[i % colors.length]
            );
            state.partyFireworks.push(particle);
        }
        
        // Flash light
        const flashLight = new THREE.PointLight(this.color, 10, 30);
        flashLight.position.copy(this.mesh.position);
        scene.add(flashLight);
        setTimeout(() => scene.remove(flashLight), 200);
        
        // Remove rocket mesh
        scene.remove(this.mesh);
    }
}

// Trail particle for rocket smoke trail
class TrailParticle {
    constructor(position, color) {
        const geo = new THREE.SphereGeometry(0.08, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ 
            color: color,
            transparent: true,
            opacity: 0.8
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(position);
        this.mesh.userData.isTrail = true;
        
        this.age = 0;
        this.maxAge = 0.5; // Short lived trail
        this.material = mat;
        this.initialScale = 0.8 + Math.random() * 0.4;
        this.mesh.scale.setScalar(this.initialScale);
        
        scene.add(this.mesh);
    }
    
    update(delta) {
        this.age += delta;
        
        // Expand and fade
        const lifeRatio = this.age / this.maxAge;
        this.material.opacity = 0.8 * (1 - lifeRatio);
        this.mesh.scale.setScalar(this.initialScale * (1 + lifeRatio * 2));
        
        if (this.age >= this.maxAge) {
            scene.remove(this.mesh);
            return true;
        }
        
        return false;
    }
}

class FireworkParticle {
    constructor(position, color) {
        const geo = new THREE.SphereGeometry(0.25 + Math.random() * 0.15, 4, 4);
        const mat = new THREE.MeshBasicMaterial({ 
            color: color,
            transparent: true,
            opacity: 1
        });
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.copy(position);
        this.mesh.userData.isParticle = true;
        
        // Random direction for explosion
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 0.6,
            (Math.random() - 0.5) * 0.6,
            (Math.random() - 0.5) * 0.6
        );
        
        this.age = 0;
        this.maxAge = 1 + Math.random() * 0.5;
        this.material = mat;
        
        scene.add(this.mesh);
    }
    
    update(delta) {
        this.age += delta;
        
        // Gravity and drag
        this.velocity.y -= 0.015;
        this.velocity.multiplyScalar(0.96);
        
        this.mesh.position.add(this.velocity);
        
        // Fade out
        const lifeRatio = this.age / this.maxAge;
        this.material.opacity = 1 - lifeRatio;
        this.mesh.scale.setScalar(1 - lifeRatio * 0.5);
        
        if (this.age >= this.maxAge) {
            scene.remove(this.mesh);
            return true;
        }
        
        return false;
    }
}

let fireworkCooldown = false;

function shootFirework() {
    if (!state.isPlaying) return;
    if (!state.partyMode) return;
    if (fireworkCooldown) return;
    
    fireworkCooldown = true;
    setTimeout(() => fireworkCooldown = false, 7000); // 7 sec cooldown
    
    // Play launch sound (quieter)
    try {
        const snd = state.sounds.firework.cloneNode();
        snd.volume = 0.3;
        snd.playbackRate = 1.5;
        snd.play();
    } catch (e) {}
    
    // Get shooting direction from camera
    const direction = new THREE.Vector3();
    camera.getWorldDirection(direction);
    
    // Start position slightly in front of camera
    const startPos = camera.position.clone().add(direction.clone().multiplyScalar(1));
    
    const firework = new Firework(startPos, direction);
    state.partyFireworks.push(firework);
}

function updateFireworks(delta) {
    for (let i = state.partyFireworks.length - 1; i >= 0; i--) {
        const fw = state.partyFireworks[i];
        if (fw.update(delta)) {
            state.partyFireworks.splice(i, 1);
        }
    }
}

function togglePartyMode(activatorName = 'Админ') {
    state.partyMode = !state.partyMode;
    
    const notification = document.getElementById('party-notification');
    const partyBtnGlobal = document.getElementById('admin-party-global');
    const partyBtnLocal = document.getElementById('admin-party-local');
    
    if (state.partyMode) {
        // Save current weapon
        state.savedWeaponBeforeParty = state.currentWeapon;
        
        // Switch to rocket launcher
        switchWeapon('rocketLauncher');
        
        // Show notification
        notification.textContent = 'Федя активировал праздник';
        notification.classList.add('show');
        setTimeout(() => notification.classList.remove('show'), 3000);
        
        // Update buttons
        if (partyBtnGlobal) partyBtnGlobal.classList.add('active');
        if (partyBtnLocal) partyBtnLocal.classList.add('active');
        if (partyBtnGlobal) partyBtnGlobal.textContent = '🎆 Праздник (ВКЛ)';
        if (partyBtnLocal) partyBtnLocal.textContent = '🎆 Праздник (ВКЛ)';
        
        // Enable party effects
        enablePartyEffects();
        
    } else {
        // Restore previous weapon
        if (state.savedWeaponBeforeParty) {
            switchWeapon(state.savedWeaponBeforeParty);
        } else {
            switchWeapon('rifle');
        }
        
        // Update buttons (no notification when turning off)
        if (partyBtnGlobal) partyBtnGlobal.classList.remove('active');
        if (partyBtnLocal) partyBtnLocal.classList.remove('active');
        if (partyBtnGlobal) partyBtnGlobal.textContent = '🎆 Праздник';
        if (partyBtnLocal) partyBtnLocal.textContent = '🎆 Праздник';
        
        // Disable party effects
        disablePartyEffects();
        
        // Clear remaining fireworks
        for (const fw of state.partyFireworks) {
            if (fw.mesh) scene.remove(fw.mesh);
        }
        state.partyFireworks = [];
    }
}

// Party disco effects
function enablePartyEffects() {
    const pe = state.partyEffects;
    
    // Save original scene settings
    pe.originalBackground = scene.background.clone();
    pe.originalFog = scene.fog ? { color: scene.fog.color.clone(), near: scene.fog.near, far: scene.fog.far } : null;
    
    // Dark night sky
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.Fog(0x050510, 5, 60);
    
    // Dim ambient light
    scene.traverse((obj) => {
        if (obj.isAmbientLight) {
            pe.originalAmbient = obj.intensity;
            obj.intensity = 0.1;
        }
    });
    
    // Create disco balls
    const discoBallPositions = [
        { x: 0, y: 15, z: 0 },
        { x: -20, y: 12, z: -20 },
        { x: 20, y: 12, z: 20 },
        { x: -20, y: 12, z: 20 },
        { x: 20, y: 12, z: -20 }
    ];
    
    discoBallPositions.forEach((pos, i) => {
        const discoBall = createDiscoBall(pos.x, pos.y, pos.z, i === 0 ? 2 : 1.2);
        pe.discoBalls.push(discoBall);
        scene.add(discoBall.group);
    });
    
    // Create spotlights with different colors
    const spotlightColors = [0xff0066, 0x00ff66, 0x0066ff, 0xffff00, 0xff00ff, 0x00ffff];
    const spotlightPositions = [
        { x: -15, z: -15 },
        { x: 15, z: -15 },
        { x: -15, z: 15 },
        { x: 15, z: 15 },
        { x: 0, z: -25 },
        { x: 0, z: 25 }
    ];
    
    spotlightPositions.forEach((pos, i) => {
        const color = spotlightColors[i % spotlightColors.length];
        const spotlight = new THREE.SpotLight(color, 3, 50, Math.PI / 6, 0.5, 1);
        spotlight.position.set(pos.x, 20, pos.z);
        spotlight.target.position.set(0, 0, 0);
        scene.add(spotlight);
        scene.add(spotlight.target);
        pe.spotlights.push({ light: spotlight, baseAngle: i * Math.PI / 3, speed: 0.5 + Math.random() * 0.5 });
    });
}

function createDiscoBall(x, y, z, size) {
    const group = new THREE.Group();
    
    // Main sphere with mirror-like material
    const geo = new THREE.SphereGeometry(size, 32, 32);
    const mat = new THREE.MeshPhongMaterial({
        color: 0xaaaaaa,
        specular: 0xffffff,
        shininess: 100,
        emissive: 0x222222
    });
    const sphere = new THREE.Mesh(geo, mat);
    group.add(sphere);
    
    // Add small mirror tiles
    const tileGeo = new THREE.BoxGeometry(size * 0.15, size * 0.15, size * 0.02);
    const tileMat = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        specular: 0xffffff,
        shininess: 150,
        emissive: 0x333333
    });
    
    for (let i = 0; i < 80; i++) {
        const tile = new THREE.Mesh(tileGeo, tileMat);
        const phi = Math.acos(-1 + (2 * i) / 80);
        const theta = Math.sqrt(80 * Math.PI) * phi;
        tile.position.setFromSphericalCoords(size * 1.02, phi, theta);
        tile.lookAt(0, 0, 0);
        group.add(tile);
    }
    
    // Point light inside disco ball
    const light = new THREE.PointLight(0xffffff, 2, 30);
    group.add(light);
    
    group.position.set(x, y, z);
    
    return { group, sphere, light };
}

function disablePartyEffects() {
    const pe = state.partyEffects;
    
    // Restore original scene settings
    if (pe.originalBackground) {
        scene.background = pe.originalBackground;
    }
    if (pe.originalFog) {
        scene.fog = new THREE.Fog(pe.originalFog.color, pe.originalFog.near, pe.originalFog.far);
    }
    
    // Restore ambient light
    scene.traverse((obj) => {
        if (obj.isAmbientLight && pe.originalAmbient !== null) {
            obj.intensity = pe.originalAmbient;
        }
    });
    
    // Remove disco balls
    pe.discoBalls.forEach(db => {
        scene.remove(db.group);
    });
    pe.discoBalls = [];
    
    // Remove spotlights
    pe.spotlights.forEach(sp => {
        scene.remove(sp.light.target);
        scene.remove(sp.light);
    });
    pe.spotlights = [];
    
    pe.originalBackground = null;
    pe.originalFog = null;
    pe.originalAmbient = null;
}

function updatePartyEffects(delta) {
    if (!state.partyMode) return;
    
    const pe = state.partyEffects;
    const time = performance.now() * 0.001;
    
    // Rotate disco balls
    pe.discoBalls.forEach((db, i) => {
        db.group.rotation.y += delta * (0.5 + i * 0.1);
        // Pulse the light
        db.light.intensity = 1.5 + Math.sin(time * 3 + i) * 0.5;
    });
    
    // Animate spotlights
    pe.spotlights.forEach((sp, i) => {
        const angle = sp.baseAngle + time * sp.speed;
        const radius = 15 + Math.sin(time * 0.5 + i) * 10;
        sp.light.target.position.x = Math.cos(angle) * radius;
        sp.light.target.position.z = Math.sin(angle) * radius;
        sp.light.target.position.y = Math.sin(time * 2 + i) * 3;
        
        // Color shift
        const hue = (time * 0.1 + i * 0.1) % 1;
        sp.light.color.setHSL(hue, 1, 0.5);
    });
}

function shoot() {
    if (!state.isPlaying) return;
    if (state.currentWeapon === 'hammer') return; // hammer does not shoot
    
    // Handle party mode - shoot fireworks
    if (state.partyMode && state.currentWeapon === 'rocketLauncher') {
        shootFirework();
        return;
    }
    
    if (state.currentWeapon === 'knife') {
        knifeAttack();
        return;
    }
    const isSniper = state.currentWeapon === 'sniper';
    const currentAmmo = isSniper ? state.sniperAmmo : state.ammo;
    
    if (!state.canShoot || state.isReloading || currentAmmo <= 0) return;
    
    state.canShoot = false;
    
    if (state.isMultiplayer && mpSocket && mpSocket.connected) {
        mpSocket.emit('shoot', {});
    }
    
    const infiniteAmmo = state.cheats.enabled && state.cheats.infiniteAmmo;
    if (!infiniteAmmo) {
        if (isSniper) {
            state.sniperAmmo--;
        } else {
            state.ammo--;
        }
    }
    updateHUD();
    if (isSniper) {
        startWeaponSound('sniperShot', 1.2);
    } else {
        startWeaponSound('rifleShot', 0.5);
    }
    
    // Muzzle flash
    const activeWeapon = isSniper ? sniperGroup : weaponGroup;
    const muzzleFlash = activeWeapon.getObjectByName('muzzleFlash');
    muzzleFlash.intensity = isSniper ? 5 : 3;
    setTimeout(() => { muzzleFlash.intensity = 0; }, 50);
    
    // Recoil
    const cfg = isSniper ? CONFIG.sniper : CONFIG.weapon;
    const noRecoil = state.cheats.enabled && state.cheats.noRecoil;
    targetWeaponRecoil = noRecoil ? 0 : (isSniper ? 0.1 : 0.05);
    const recoilX = noRecoil ? 0 : cfg.recoil * (0.8 + Math.random() * 0.4);
    controls.euler.x = Math.min(Math.PI / 2, controls.euler.x + recoilX);
    camera.quaternion.setFromEuler(controls.euler);
    
    // Crosshair spread (less for scoped sniper)
    if (!state.isScoped) {
        state.crosshairSpread = Math.min(state.crosshairSpread + (isSniper ? 15 : 8), 30);
    }
    
    // Raycast
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    
    // Aimbot direction override
    let aimDirection = null;
    if (state.cheats.enabled && state.cheats.aimbot) {
        aimDirection = getAimbotDirection(isSniper);
    }
    
    // Get shoot direction with spread (no spread when scoped)
    const spreadBase = state.isScoped ? 0 : state.crosshairSpread * 0.001;
    const spread = (noRecoil || aimDirection) ? 0 : spreadBase;
    let direction = raycaster.ray.direction.clone();
    if (aimDirection) {
        direction.copy(aimDirection);
    } else {
        direction.x += (Math.random() - 0.5) * spread;
        direction.y += (Math.random() - 0.5) * spread;
        direction.z += (Math.random() - 0.5) * spread;
    }
    raycaster.ray.direction.copy(direction.normalize());
    
    // Check enemy hits (body + head) and remote players
    const enemyParts = [];
    if (!state.isMultiplayer) {
        enemies.filter(e => e.isAlive).forEach(e => {
            enemyParts.push(e.mesh);
            enemyParts.push(e.head);
        });
    }
    const remoteParts = [];
    remotePlayers.forEach(p => {
        if (p.isAlive) {
            remoteParts.push(p.body);
            remoteParts.push(p.head);
        }
    });
    const hits = raycaster.intersectObjects([...enemyParts, ...remoteParts], true);
    
    // Tracer
    const start = camera.position.clone();
    start.add(direction.clone().multiplyScalar(1));
    let end;
    
    if (hits.length > 0) {
        const hit = hits[0];
        end = hit.point;
        
        // Find which enemy was hit
        const hitEnemy = (!state.isMultiplayer)
            ? enemies.find(e => e.isAlive && (e.mesh === hit.object || e.head === hit.object))
            : null;
        if (hitEnemy) {
            if (hasLineOfSight(hit.point)) {
                const isHeadshot = hit.object.name === 'head';
                let damage;
                if (isSniper) {
                    damage = cfg.damage; // 200 = instant kill
                } else {
                    damage = isHeadshot ? cfg.damage * 2.5 : cfg.damage;
                }
                hitEnemy.takeDamage(damage, isHeadshot || isSniper);
                
                for (let i = 0; i < 5; i++) {
                    createParticle(hit.point.x, hit.point.y, hit.point.z, (isHeadshot || isSniper) ? 0xffff00 : 0xe94560);
                }
            } else {
                // blocked by wall, treat as wall hit
                const wallHits = raycaster.intersectObjects(colliders.map(c => c.mesh));
                if (wallHits.length > 0) end = wallHits[0].point;
            }
        } else {
            const remoteEntry = Array.from(remotePlayers.entries()).find(([, p]) => p.body === hit.object || p.head === hit.object);
            if (remoteEntry) {
                const [remoteId] = remoteEntry;
                if (hasLineOfSight(hit.point)) {
                    const isHeadshot = hit.object.name === 'head';
                    let damage;
                    if (isSniper) {
                        damage = cfg.damage;
                    } else {
                        damage = isHeadshot ? cfg.damage * 2.5 : cfg.damage;
                    }
                    applyRemoteDamage(remoteId, damage, isHeadshot || isSniper);
                    if (mpSocket && mpSocket.connected) {
                        mpSocket.emit('hit', { targetId: remoteId, damage, isHeadshot: isHeadshot || isSniper });
                    }
                    showHitmarker(isHeadshot || isSniper);
                    for (let i = 0; i < 5; i++) {
                        createParticle(hit.point.x, hit.point.y, hit.point.z, (isHeadshot || isSniper) ? 0xffff00 : 0xe94560);
                    }
                } else {
                    const wallHits = raycaster.intersectObjects(colliders.map(c => c.mesh));
                    if (wallHits.length > 0) end = wallHits[0].point;
                }
            }
        }
    } else {
        // Check wall hits
        const wallHits = raycaster.intersectObjects(colliders.map(c => c.mesh));
        if (wallHits.length > 0 && !(state.cheats.enabled && state.cheats.wallbang)) {
            end = wallHits[0].point;
            for (let i = 0; i < 3; i++) {
                createParticle(end.x, end.y, end.z, 0xd4a574);
            }
        } else {
            end = camera.position.clone().add(direction.multiplyScalar(100));
        }
    }
    
    createTracer(start, end);
    
    // Fire rate cooldown (rapid fire cheat makes any gun fire extremely fast)
    const fireDelay = (state.cheats.enabled && state.cheats.rapidFire) ? 20 : (cfg.fireRate || 100);
    setTimeout(() => { state.canShoot = true; }, fireDelay);
    // Safety fallback in case state stuck
    setTimeout(() => { if (!state.canShoot) state.canShoot = true; }, fireDelay * 2);
    
    // Restore ammo if infinite
    if (infiniteAmmo) {
        if (isSniper) {
            state.sniperAmmo = cfg.magazineSize;
            state.sniperReserve = cfg.reserveAmmo || CONFIG.sniper.reserveAmmo;
        } else {
            state.ammo = cfg.magazineSize;
            state.reserveAmmo = cfg.reserveAmmo || CONFIG.weapon.reserveAmmo;
        }
        updateHUD();
    }
    
    // Auto reload
    const reserve = isSniper ? state.sniperReserve : state.reserveAmmo;
    const ammoNow = isSniper ? state.sniperAmmo : state.ammo;
    if (ammoNow <= 0 && reserve > 0) {
        reload();
    }
}


// Knife attack function
function knifeAttack() {
    if (!state.isPlaying) return;
    if (state.knifeCooldown) return;
    state.knifeCooldown = true;
    state.canShoot = true; // не блокируем стрельбу других видов оружия
    
    // Play knife sound
    try {
        if (state.sounds.knifeSwing) {
            state.sounds.knifeSwing.currentTime = 0;
            state.sounds.knifeSwing.play();
        }
    } catch (e) {}
    
    // Knife swing animation
    const originalRot = knifeGroup.rotation.x;
    knifeGroup.rotation.x = -1;
    setTimeout(() => { knifeGroup.rotation.x = originalRot; }, 200);
    
    // Check for enemies in range
    const knifeRange = CONFIG.knife.range;
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);
    
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        
        const enemyPos = enemy.group.position.clone();
        enemyPos.y = 1;
        const playerPos = camera.position.clone();
        
        const dist = playerPos.distanceTo(enemyPos);
        if (dist > knifeRange) return;
        
        // Check if enemy is in front of player
        const toEnemy = enemyPos.clone().sub(playerPos).normalize();
        const dot = cameraDir.dot(toEnemy);
        
        if (dot > 0.5) {
            enemy.takeDamage(CONFIG.knife.damage, true);
            
            // Blood particles
            for (let i = 0; i < 8; i++) {
                createParticle(enemyPos.x, enemyPos.y, enemyPos.z, 0xe94560);
            }
        }
    });
    
    // Remote players in MP
    remotePlayers.forEach((p, id) => {
        if (!p.isAlive) return;
        
        const targetPos = p.group.position.clone();
        targetPos.y = 1;
        const playerPos = camera.position.clone();
        
        const dist = playerPos.distanceTo(targetPos);
        if (dist > knifeRange) return;
        
        const toEnemy = targetPos.clone().sub(playerPos).normalize();
        const dot = cameraDir.dot(toEnemy);
        if (dot > 0.5) {
            applyRemoteDamage(id, CONFIG.knife.damage, true);
            if (mpSocket && mpSocket.connected) {
                mpSocket.emit('hit', { targetId: id, damage: CONFIG.knife.damage, isHeadshot: true });
            }
            for (let i = 0; i < 8; i++) {
                createParticle(targetPos.x, targetPos.y, targetPos.z, 0xe94560);
            }
        }
    });
    
    // Cooldown
    const knifeDelay = CONFIG.knife.fireRate || 500;
    setTimeout(() => { state.knifeCooldown = false; }, Math.min(knifeDelay, 250));
    setTimeout(() => { state.knifeCooldown = false; }, knifeDelay);
    setTimeout(() => { state.knifeCooldown = false; }, knifeDelay * 2); // страховка
}
function reload() {
    const isSniper = state.currentWeapon === 'sniper';
    const cfg = isSniper ? CONFIG.sniper : CONFIG.weapon;
    const currentAmmo = isSniper ? state.sniperAmmo : state.ammo;
    const reserve = isSniper ? state.sniperReserve : state.reserveAmmo;
    
    if (state.isReloading || currentAmmo === cfg.magazineSize || reserve <= 0) return;
    
    state.isReloading = true;
    
    setTimeout(() => {
        const needed = cfg.magazineSize - currentAmmo;
        const available = Math.min(needed, reserve);
        
        if (isSniper) {
            state.sniperAmmo += available;
            state.sniperReserve -= available;
        } else {
            state.ammo += available;
            state.reserveAmmo -= available;
        }
        state.isReloading = false;
        updateHUD();
    }, cfg.reloadTime);
}

// ==================== COLLISION DETECTION ====================
function checkCollision(position, radius = 0.5) {
    if (state.cheats.enabled && state.cheats.noclip) return false;
    const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - radius, position.y - CONFIG.player.height, position.z - radius),
        new THREE.Vector3(position.x + radius, position.y + 0.2, position.z + radius)
    );
    const playerMinY = position.y - CONFIG.player.height;
    
    for (const collider of colliders) {
        if (playerBox.intersectsBox(collider.box)) {
            // Если стоим на верхней поверхности, не считаем это коллизией
            const colliderTop = collider.box.max.y;
            if (playerMinY >= colliderTop - 0.3) {
                continue;
            }
            return true;
        }
    }
    return false;
}

function getGroundHeight(x, z) {
    const ray = new THREE.Raycaster(
        new THREE.Vector3(x, 50, z),
        new THREE.Vector3(0, -1, 0)
    );
    
    const hits = ray.intersectObjects(colliders.map(c => c.mesh));
    if (hits.length > 0) {
        return hits[0].point.y;
    }
    return 0;
}

// ==================== PLAYER MOVEMENT ====================
function updatePlayer(delta) {
    if (!state.isPlaying) return;
    
    let speed = CONFIG.player.speed * (state.isSprinting ? CONFIG.player.sprintMultiplier : 1);
    if (state.isCrouching) speed *= 0.4; // Crouch = 40% speed
    if (state.cheats.enabled && state.cheats.speedBoost) speed *= (state.cheats.speedMultiplier || 2);
    
    // Get movement direction
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
    
    // Calculate movement
    const moveDir = new THREE.Vector3();
    if (state.moveForward) moveDir.add(forward);
    if (state.moveBackward) moveDir.sub(forward);
    if (state.moveRight) moveDir.add(right);
    if (state.moveLeft) moveDir.sub(right);
    moveDir.normalize();
    
    state.isMoving = moveDir.length() > 0;
    
    // Footsteps sound
    try {
        if (state.sounds.footsteps) {
            if (state.isMoving && state.isGrounded) {
                if (state.sounds.footsteps.paused) {
                    state.sounds.footsteps.play();
                }
            } else {
                if (!state.sounds.footsteps.paused) {
                    state.sounds.footsteps.pause();
                    state.sounds.footsteps.currentTime = 0;
                }
            }
        }
    } catch (e) {}
    
    // Apply horizontal movement
    const newPos = camera.position.clone();
    newPos.x += moveDir.x * speed * delta;
    newPos.z += moveDir.z * speed * delta;
    
    // Check collision for X
    if (!checkCollision(new THREE.Vector3(newPos.x, camera.position.y, camera.position.z))) {
        camera.position.x = newPos.x;
    }
    
    // Check collision for Z
    if (!checkCollision(new THREE.Vector3(camera.position.x, camera.position.y, newPos.z))) {
        camera.position.z = newPos.z;
    }
    
    if (state.cheats.enabled && state.cheats.fly) {
        // Fly mode: свободный Y без гравитации
        const flySpeed = speed;
        let dy = 0;
        if (state.flyUp) dy += flySpeed;
        if (state.flyDown) dy -= flySpeed;
        camera.position.y += dy * delta;
        state.velocity.y = 0;
        state.isGrounded = false;
    } else {
        // Gravity and jumping
        state.velocity.y -= CONFIG.player.gravity * delta;
        camera.position.y += state.velocity.y * delta;
        
        // Ground check (crouch = lower camera)
        const playerHeight = state.isCrouching ? CONFIG.player.height * 0.5 : CONFIG.player.height;
        const groundY = getGroundHeight(camera.position.x, camera.position.z) + playerHeight;
        if (camera.position.y <= groundY) {
            camera.position.y = groundY;
            state.velocity.y = 0;
            state.isGrounded = true;
            
            // Авто-прыжок при удержании пробела и движении по земле
            if (state.jumpHeld) {
                state.velocity.y = CONFIG.player.jumpForce;
                state.isGrounded = false;
                // Play jump sound
                try {
                    if (state.sounds.jump) {
                        state.sounds.jump.currentTime = 0;
                        state.sounds.jump.play();
                    }
                } catch (e) {}
            }
        } else {
            state.isGrounded = false;
        }
    }
    
    // Keep in bounds
    const bound = CONFIG.map.size - 2;
    camera.position.x = Math.max(-bound, Math.min(bound, camera.position.x));
    camera.position.z = Math.max(-bound, Math.min(bound, camera.position.z));
}

// ==================== WEAPON ANIMATION ====================
function updateWeapon(delta) {
    // Weapon sway
    if (state.isMoving) {
        weaponSwayTime += delta * 10;
    }
    
    const swayX = Math.sin(weaponSwayTime) * 0.01 * (state.isMoving ? 1 : 0.2);
    const swayY = Math.abs(Math.cos(weaponSwayTime * 2)) * 0.008 * (state.isMoving ? 1 : 0.2);
    
    // Recoil recovery
    weaponRecoil = THREE.MathUtils.lerp(weaponRecoil, targetWeaponRecoil, delta * 20);
    targetWeaponRecoil = THREE.MathUtils.lerp(targetWeaponRecoil, 0, delta * 10);
    
    // Apply transforms
    weaponGroup.position.x = 0.25 + swayX;
    weaponGroup.position.y = -0.2 + swayY - weaponRecoil;
    weaponGroup.rotation.x = -weaponRecoil * 0.5;
    
    // Reload animation
    if (state.isReloading) {
        weaponGroup.rotation.x = Math.sin(Date.now() * 0.005) * 0.3 - 0.3;
    }
}

// ==================== CROSSHAIR ====================
function updateCrosshair(delta) {
    // Spread recovery
    if (!state.isMoving) {
        state.crosshairSpread = Math.max(0, state.crosshairSpread - delta * 50);
    } else {
        state.crosshairSpread = Math.max(5, state.crosshairSpread - delta * 30);
    }
    
    const baseGap = crosshairConfig.gap;
    const spread = baseGap + state.crosshairSpread;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    
    const top = document.querySelector('.cross-top');
    const bottom = document.querySelector('.cross-bottom');
    const left = document.querySelector('.cross-left');
    const right = document.querySelector('.cross-right');
    
    if (top) top.style.top = (-spread - len) + 'px';
    if (bottom) bottom.style.top = spread + 'px';
    if (left) left.style.left = (-spread - len) + 'px';
    if (right) right.style.left = spread + 'px';
}

// ==================== UI FUNCTIONS ====================
function updateHUD() {
    document.getElementById('health-fill').style.width = `${Math.max(0, state.health)}%`;
    
    if (state.currentWeapon === 'sniper') {
        document.getElementById('current-ammo').textContent = state.sniperAmmo;
        document.getElementById('reserve-ammo').textContent = state.sniperReserve;
    } else {
        document.getElementById('current-ammo').textContent = state.ammo;
        document.getElementById('reserve-ammo').textContent = state.reserveAmmo;
    }
    
    document.getElementById('kill-count').textContent = state.kills + '/30';
    document.getElementById('grenade-num').textContent = state.grenades;
    
    // Check win by kills
    if (state.isPlaying && state.kills >= 30) {
        gameWin('kills');
    }
}

function showHitmarker(isHeadshot = false) {
    const hitmarker = document.getElementById('hitmarker');
    hitmarker.style.opacity = '1';
    if (isHeadshot) {
        hitmarker.querySelectorAll('.hit-line').forEach(l => l.style.background = '#ffff00');
    } else {
        hitmarker.querySelectorAll('.hit-line').forEach(l => l.style.background = '#e94560');
    }
    setTimeout(() => { hitmarker.style.opacity = '0'; }, 100);
}

function showDamageOverlay() {
    state.regenTimer = 0; // Reset regen timer on damage
    const overlay = document.getElementById('damage-overlay');
    overlay.style.opacity = '1';
    setTimeout(() => { overlay.style.opacity = '0'; }, 200);
}

const defeatMessages = [
    '💀 УБИТ В БОЮ',
    '💀 МИССИЯ ПРОВАЛЕНА',
    '💔 ТЫ ПОГИБ',
    '💀 КОНЕЦ ПУТИ',
    '👿 ВРАГИ ПОБЕДИЛИ'
];

const victoryMessages = [
    '🏆 ПОБЕДА!',
    '🎖 МИССИЯ ВЫПОЛНЕНА!',
    '⭐ ОТЛИЧНАЯ РАБОТА!',
    '🥇 ТЫ ЛУЧШИЙ!',
    '💪 ВРАГИ УНИЧТОЖЕНЫ!'
];

function gameOver() {
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    
    // Stop footsteps sound
    try {
        if (state.sounds.footsteps && !state.sounds.footsteps.paused) {
            state.sounds.footsteps.pause();
            state.sounds.footsteps.currentTime = 0;
        }
    } catch (e) {}
    
    // Clean up bomb state to avoid flicker after defuse
    state.bombPlanted = false;
    state.bombTimer = 0;
    state.bombDefuseTimer = 0;
    if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
    if (bombLight) { scene.remove(bombLight); bombLight = null; }
    
    const msg = defeatMessages[Math.floor(Math.random() * defeatMessages.length)];
    
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('menu').querySelector('h1').textContent = msg;
    document.getElementById('menu').querySelector('p').textContent = `Убито врагов: ${state.kills}`;
    document.getElementById('play-btn').textContent = 'ИГРАТЬ СНОВА';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    document.getElementById('bomb-status').style.display = 'none';
}

function gameWin(reason) {
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    
    // Stop footsteps sound
    try {
        if (state.sounds.footsteps && !state.sounds.footsteps.paused) {
            state.sounds.footsteps.pause();
            state.sounds.footsteps.currentTime = 0;
        }
    } catch (e) {}
    
    const msg = victoryMessages[Math.floor(Math.random() * victoryMessages.length)];
    let subtext = '';
    
    if (reason === 'bomb') {
        subtext = '\u{1F4A3} Бомба взорвалась!';
    } else if (reason === 'kills') {
        subtext = `?? ${state.kills} врагов уничтожено!`;
    }
    
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('menu').querySelector('h1').textContent = msg;
    document.getElementById('menu').querySelector('p').textContent = subtext;
    document.getElementById('play-btn').textContent = 'ИГРАТЬ СНОВА';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    document.getElementById('bomb-status').style.display = 'none';
}

function checkWinCondition() {
    if (state.kills >= 30) {
        gameWin('kills');
        return true;
    }
    return false;
}

let mpRespawnTimeout = null;

function resetPlayerStats() {
    state.health = CONFIG.player.health;
    state.ammo = CONFIG.weapon.magazineSize;
    state.reserveAmmo = CONFIG.weapon.reserveAmmo;
    state.sniperAmmo = CONFIG.sniper.magazineSize;
    state.sniperReserve = CONFIG.sniper.reserveAmmo;
    state.grenades = 3;
    state.isReloading = false;
    state.currentWeapon = 'rifle';
    state.isScoped = false;
    state.regenTimer = 0;
    state.canShoot = true;
    state.canThrowGrenade = true;
    weaponGroup.visible = true;
    sniperGroup.visible = false;
    document.getElementById('weapon-name').textContent = 'AK-47';
    document.getElementById('scope-overlay').classList.remove('active');
    camera.fov = 75;
    camera.updateProjectionMatrix();
    updateHUD();
}

function placePlayer(position) {
    camera.position.copy(position);
    state.velocity.set(0, 0, 0);
    state.isGrounded = true;
}

function getAimSpawn(index = 0) {
    const spawn = AIM_SPAWNS[index % AIM_SPAWNS.length];
    return new THREE.Vector3(spawn.x, spawn.y || CONFIG.player.height, spawn.z);
}

function respawnLocalPlayer() {
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    resetPlayerStats();
    let spawn = getAimSpawn(state.mpSpawnIndex || 0);
    if (state.mpMode === 'team') {
        spawn = getTeamSpawn(state.mpSpawnIndex || 0);
    } else if (state.mpMode === 'ffa') {
        spawn = getFfaSpawn(state.mpSpawnIndex || 0);
    } else if (state.mpMode === 'sandbox') {
        spawn = getSandboxSpawn();
    }
    placePlayer(spawn);
    if (mpSocket && mpSocket.connected) {
        mpSocket.emit('respawn', { x: spawn.x, y: spawn.y, z: spawn.z });
    }
}

function applyPlayerDamage(amount) {
    if (state.cheats.enabled && state.cheats.godMode) return;
    state.health -= amount;
    updateHUD();
    showDamageOverlay();
    if (state.health <= 0) {
        if (state.isMultiplayer) {
            state.health = 0;
            updateHUD();
            state.mpDeaths++;
            updateMpScore();
            if (mpRespawnTimeout) clearTimeout(mpRespawnTimeout);
            mpRespawnTimeout = setTimeout(respawnLocalPlayer, 1200);
        } else {
            gameOver();
        }
    }
}

function resetGame(options = {}) {
    const { skipEnemies = false, position = null } = options;
    
    resetPlayerStats();
    state.kills = 0;
    state.mpKills = 0;
    state.mpDeaths = 0;
    state.bombPlanted = false;
    state.bombTimer = 0;
    state.bombDefuseTimer = 0;
    state.bombPosition = null;
    state.regenTimer = 0;
    state.enemyDefusing = false;
    
    // Reset party mode
    if (state.partyMode) {
        state.partyMode = false;
        disablePartyEffects();
        for (const fw of state.partyFireworks) {
            if (fw.mesh) scene.remove(fw.mesh);
        }
        state.partyFireworks = [];
        state.savedWeaponBeforeParty = null;
        const partyBtnGlobal = document.getElementById('admin-party-global');
        const partyBtnLocal = document.getElementById('admin-party-local');
        if (partyBtnGlobal) { partyBtnGlobal.classList.remove('active'); partyBtnGlobal.textContent = '🎆 Праздник'; }
        if (partyBtnLocal) { partyBtnLocal.classList.remove('active'); partyBtnLocal.textContent = '🎆 Праздник'; }
    }
    
    // Remove bomb if exists
    if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
    if (bombLight) { scene.remove(bombLight); bombLight = null; }
    
    const spawnPos = position || new THREE.Vector3(0, CONFIG.player.height, 20);
    placePlayer(spawnPos);
    
    // Reset enemies
    if (!skipEnemies) {
        enemies.forEach(e => {
            if (!scene.children.includes(e.group)) scene.add(e.group);
            if (!e.isAlive) {
                e.respawn();
            }
            e.health = e.maxHealth;
            e.state = 'patrol';
            e.group.visible = true;
        });
    } else {
        enemies.forEach(e => e.group.visible = false);
    }
    
    document.getElementById('bomb-status').style.display = 'none';
}

// ==================== INPUT HANDLING ====================
document.addEventListener('keydown', (e) => {
    if (!state.isPlaying) return;
    
    switch (e.code) {
        case 'KeyW': state.moveForward = true; break;
        case 'KeyS': state.moveBackward = true; break;
        case 'KeyA': state.moveLeft = true; break;
        case 'KeyD': state.moveRight = true; break;
        case 'Space':
            if (state.cheats.enabled && state.cheats.fly) {
                state.flyUp = true;
            } else {
                state.jumpHeld = true;
                if (state.isGrounded) {
                    state.velocity.y = CONFIG.player.jumpForce;
                    state.isGrounded = false;
                    // Play jump sound
                    try {
                        if (state.sounds.jump) {
                            state.sounds.jump.currentTime = 0;
                            state.sounds.jump.play();
                        }
                    } catch (e) {}
                }
            }
            break;
        case 'ShiftLeft':
            state.isSprinting = true;
            break;
        case 'ControlLeft':
        case 'ControlRight':
            if (state.cheats.enabled && state.cheats.fly) {
                state.flyDown = true;
            } else {
                state.isCrouching = true;
            }
            break;
        case 'KeyR': reload(); break;
        case 'KeyG': throwGrenade(); break;
        case 'KeyB': plantBomb(); break;
        case 'Digit1': switchWeapon('rifle'); break;
        case 'Digit2': switchWeapon('sniper'); break;
        case 'Digit3': switchWeapon('knife'); break;
        case 'Digit4':
            if (state.sandbox.active) toggleHammer();
            break;
        case 'KeyU':
            if (state.sandbox.active) {
                const willOpen = !isSandboxPanelOpen();
            if (willOpen) {
                document.exitPointerLock?.();
                setSandboxPanelVisible(true);
            } else {
                setSandboxPanelVisible(false);
                if (!isMobile) {
                    const target = renderer?.domElement || document.getElementById('game-container');
                    target?.requestPointerLock?.();
                }
            }
            }
            break;
        case 'Escape':
            // Let ESC be handled globally; no early return
            break;
    }
});

document.addEventListener('keyup', (e) => {
    switch (e.code) {
        case 'KeyW': state.moveForward = false; break;
        case 'KeyS': state.moveBackward = false; break;
        case 'KeyA': state.moveLeft = false; break;
        case 'KeyD': state.moveRight = false; break;
        case 'ShiftLeft':
            state.isSprinting = false;
            break;
        case 'ControlLeft':
        case 'ControlRight':
            state.flyDown = false;
            state.isCrouching = false;
            break;
        case 'Space':
            state.jumpHeld = false;
            state.flyUp = false;
            break;
    }
});

let isMouseDown = false;
document.addEventListener('mousedown', (e) => {
    if (!state.isPlaying) return;
    
    if (state.currentWeapon === 'hammer' && state.sandbox.active) {
        // Hammer controls: LMB remove, RMB place
        if (e.button === 0) {
            removeSandboxAtRay();
        } else if (e.button === 2) {
            sandboxPlaceBlock();
        }
        return;
    }
    
    // Re-lock pointer if lost (after alt-tab etc)
    if (!controls.isLocked && !isMobile) {
        const adminPanelEl = document.getElementById('admin-panel');
        if (!adminPanelEl || !adminPanelEl.classList.contains('active')) {
            document.getElementById('game-container').requestPointerLock();
        }
    }
    
    if (e.button === 0) {
        isMouseDown = true;
        shoot();
    } else if (e.button === 2) {
        toggleScope();
    }
});

document.addEventListener('mouseup', (e) => {
    if (e.button === 0) {
        isMouseDown = false;
    }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', (e) => e.preventDefault());

// Auto-fire while holding (rifle; sniper when rapid fire cheat; knife)
setInterval(() => {
    if (!isMouseDown || !state.isPlaying) return;
    if (state.currentWeapon === 'rifle') {
        shoot();
    } else if (state.currentWeapon === 'sniper' && state.cheats.enabled && state.cheats.rapidFire) {
        shoot();
    } else if (state.currentWeapon === 'knife') {
        knifeAttack();
    }
}, CONFIG.weapon.fireRate);

function enterGameUI() {
    if (isMobile) {
        controls.isLocked = true;
        state.isPlaying = true;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('crosshair').style.display = 'block';
        document.getElementById('mobile-controls').classList.add('active');
    } else {
        controls.lock();
        state.isPlaying = true;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('crosshair').style.display = 'block';
    }
}

// Play button
document.getElementById('play-btn').addEventListener('click', () => {
    state.isMultiplayer = false;
    state.isSearchingMatch = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    resetRemotePlayers();
    createDefaultMap();
    resetGame();
    
    // Reset menu text
    document.getElementById('menu').querySelector('h1').textContent = 'Standoff Online';
    document.getElementById('menu').querySelector('p').textContent = 'Browser FPS Prototype';
    document.getElementById('play-btn').textContent = 'ИГРАТЬ';
    
    enterGameUI();
    // Fallback: если pointer lock не взялся, всё равно запускаем управление
    controls.isLocked = true;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('crosshair').style.display = 'block';
    if (isMobile) document.getElementById('exit-btn').style.display = 'block';
    requestGamePointerLock();
});

function joinCurrentMpMode() {
    if (!mpSocket || !mpSocket.connected || !state.isMultiplayer) return;
    switch (state.mpMode) {
        case 'team':
            updateMpStatus('Команды: подключаемся...');
            mpSocket.emit('joinTeam');
            break;
        case 'ffa':
            updateMpStatus('FFA: подключаемся...');
            mpSocket.emit('joinFFA');
            break;
        case 'sandbox':
            updateMpStatus('Песочница: подключаемся...');
            mpSocket.emit('joinSandbox');
            break;
        default:
            joinMatchmaking();
    }
}

function ensureMatchmaking() {
    if (mpSocket) {
        if (mpSocket.connected) joinCurrentMpMode();
        return; // если идёт connect, дождёмся штатного on('connect')
    }
    connectMultiplayer();
}

// Авто-подключение сокета даже в одиночке, чтобы получать глобальные сообщения
window.addEventListener('load', () => {
    connectMultiplayer();
});

function startMultiplayer() {
    state.isMultiplayer = true;
    state.isSearchingMatch = true;
    state.mpMode = 'duel';
    state.mpTeam = null;
    state.sandbox.active = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    clearSandboxObjectsLocal();
    createAimMap();
    resetRemotePlayers();
    resetGame({ skipEnemies: true, position: getAimSpawn(state.mpSpawnIndex || 0) });
    document.getElementById('menu').querySelector('h1').textContent = 'Standoff 1v1';
    document.getElementById('menu').querySelector('p').textContent = 'Aim карта для дуэлей';
    updateMpStatus('Поиск соперника...');
    enterGameUI();
    ensureMatchmaking();
    updateMpScore();
    if (isMobile) document.getElementById('exit-btn').style.display = 'block';
    setSandboxPanelVisible(false);
    requestGamePointerLock();
}

function startTeamMode() {
    state.isMultiplayer = true;
    state.isSearchingMatch = true;
    state.mpMode = 'team';
    state.mpTeam = null;
    state.sandbox.active = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    clearSandboxObjectsLocal();
    createDefaultMap();
    resetRemotePlayers();
    resetGame({ skipEnemies: true, position: getTeamSpawn(0) });
    document.getElementById('menu').querySelector('h1').textContent = 'Команды 5v5';
    document.getElementById('menu').querySelector('p').textContent = 'Командный бой';
    updateMpStatus('Команды: поиск игроков...');
    enterGameUI();
    ensureMatchmaking();
    updateMpScore();
    if (isMobile) document.getElementById('exit-btn').style.display = 'block';
    setSandboxPanelVisible(false);
    requestGamePointerLock();
}

function startFfaMode() {
    state.isMultiplayer = true;
    state.isSearchingMatch = true;
    state.mpMode = 'ffa';
    state.mpTeam = null;
    state.sandbox.active = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    clearSandboxObjectsLocal();
    createDefaultMap();
    resetRemotePlayers();
    resetGame({ skipEnemies: true, position: getFfaSpawn(0) });
    document.getElementById('menu').querySelector('h1').textContent = 'Все против всех';
    document.getElementById('menu').querySelector('p').textContent = 'Каждый сам за себя';
    updateMpStatus('FFA: подключаемся...');
    enterGameUI();
    ensureMatchmaking();
    updateMpScore();
    if (isMobile) document.getElementById('exit-btn').style.display = 'block';
    setSandboxPanelVisible(false);
    requestGamePointerLock();
}

function startSandboxMode() {
    state.isMultiplayer = true;
    state.isSearchingMatch = false;
    state.mpMode = 'sandbox';
    state.mpTeam = null;
    state.sandbox.active = true;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    createSandboxMap();
    resetRemotePlayers();
    clearSandboxObjectsLocal();
    resetGame({ skipEnemies: true, position: getSandboxSpawn() });
    document.getElementById('menu').querySelector('h1').textContent = 'Песочница';
    document.getElementById('menu').querySelector('p').textContent = 'Один общий сервер, стройте!';
    updateMpStatus('Песочница: подключаемся...');
    enterGameUI();
    ensureMatchmaking();
    document.getElementById('mp-score').style.display = 'none';
    setSandboxPanelVisible(true);
    if (isMobile) document.getElementById('exit-btn').style.display = 'block';
    requestGamePointerLock();
}

function leaveMultiplayer() {
    state.isMultiplayer = false;
    state.isSearchingMatch = false;
    state.mpMode = null;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    state.sandbox.active = false;
    if (mpSocket && mpSocket.connected) {
        mpSocket.emit('leaveMatch');
    }
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    resetRemotePlayers();
    createDefaultMap();
    resetGame();
    enemies.forEach(e => e.group.visible = true);
    const menu = document.getElementById('menu');
    menu.querySelector('h1').textContent = 'Standoff Online';
    menu.querySelector('p').textContent = 'Браузерный шутер';
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    updateMpStatus('');
    document.getElementById('mp-score').style.display = 'none';
    document.getElementById('exit-btn').style.display = 'none';
    clearSandboxObjectsLocal();
    setSandboxPanelVisible(false);
    if (state.currentWeapon === 'hammer') {
        switchWeapon('rifle');
    }
}

// Multiplayer menu button
document.getElementById('mp-menu-btn').addEventListener('click', () => {
    document.getElementById('menu').style.display = 'none';
    document.getElementById('mp-menu').style.display = 'flex';
});

// Back button in MP menu
document.getElementById('mp-back-btn').addEventListener('click', () => {
    document.getElementById('mp-menu').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
});

// Duel mode button
document.getElementById('mp-duel-btn').addEventListener('click', () => {
    document.getElementById('mp-menu').style.display = 'none';
        startMultiplayer();
});

document.getElementById('mp-team-btn').addEventListener('click', () => {
    document.getElementById('mp-menu').style.display = 'none';
    startTeamMode();
});

document.getElementById('mp-ffa-btn').addEventListener('click', () => {
    document.getElementById('mp-menu').style.display = 'none';
    startFfaMode();
});

document.getElementById('mp-sandbox-btn').addEventListener('click', () => {
    document.getElementById('mp-menu').style.display = 'none';
    startSandboxMode();
});

// Sandbox UI
const sandboxShapeBtns = document.querySelectorAll('.sandbox-shape-btn');
const sandboxSizeInput = document.getElementById('sandbox-size');
const sandboxSizeVal = document.getElementById('sandbox-size-val');
const sandboxColorInput = document.getElementById('sandbox-color');
const sandboxPlaceBtn = document.getElementById('sandbox-place');
const sandboxClearLocalBtn = document.getElementById('sandbox-clear-local');
const mobileHammerBtn = document.getElementById('btn-hammer');

function updateSandboxSizeLabel() {
    if (sandboxSizeVal && sandboxSizeInput) {
        sandboxSizeVal.textContent = (parseFloat(sandboxSizeInput.value) || 2).toFixed(1);
    }
}

sandboxShapeBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        sandboxShapeBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        state.sandbox.tool.shape = btn.dataset.shape || 'box';
    });
});

if (sandboxSizeInput) {
    sandboxSizeInput.addEventListener('input', () => {
        state.sandbox.tool.size = parseFloat(sandboxSizeInput.value) || 2;
        updateSandboxSizeLabel();
    });
    updateSandboxSizeLabel();
}

if (sandboxColorInput) {
    sandboxColorInput.addEventListener('input', () => {
        state.sandbox.tool.color = sandboxColorInput.value || '#e94560';
    });
}

if (sandboxPlaceBtn) {
    sandboxPlaceBtn.addEventListener('click', sandboxPlaceBlock);
}

if (sandboxClearLocalBtn) {
    sandboxClearLocalBtn.addEventListener('click', clearSandboxObjectsLocal);
}

if (mobileHammerBtn) {
    mobileHammerBtn.addEventListener('click', () => {
        if (state.sandbox.active) {
            toggleHammer();
        }
    });
}

// ==================== MAP EDITOR ====================
const mapEditor = {
    active: false,
    testMode: false,
    savedColliders: null,
    mapWasVisible: true,
    selectedShape: 'box',
    selectedColor: '#e94560',
    objectSize: { w: 2, h: 2, d: 2 },
    rotation: 0,
    placedObjects: [],
    spawnPoints: [],
    mapMode: '1v1',
    ghostMesh: null,
    previewRenderer: null,
    previewScene: null,
    previewCamera: null,
    previewMesh: null,
    editorFloor: null,
    undoStack: [],
    redoStack: [],
    gridHelper: null,
    hiddenObjects: [],
    originalBackground: null,
    originalFog: null
};

function initEditorPreview() {
    const canvas = document.getElementById('editor-preview-canvas');
    mapEditor.previewRenderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    mapEditor.previewRenderer.setSize(120, 120);
    mapEditor.previewRenderer.setClearColor(0x000000);
    
    mapEditor.previewScene = new THREE.Scene();
    mapEditor.previewCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    mapEditor.previewCamera.position.set(3, 2, 3);
    mapEditor.previewCamera.lookAt(0, 0, 0);
    
    const ambLight = new THREE.AmbientLight(0xffffff, 0.5);
    mapEditor.previewScene.add(ambLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 5, 5);
    mapEditor.previewScene.add(dirLight);
    
    updateEditorPreview();
}

function createEditorGeometry(shape, size) {
    switch (shape) {
        case 'box':
            return new THREE.BoxGeometry(size.w, size.h, size.d);
        case 'sphere':
            return new THREE.SphereGeometry(size.w / 2, 16, 16);
        case 'cylinder':
            return new THREE.CylinderGeometry(size.w / 2, size.w / 2, size.h, 16);
        case 'cone':
            return new THREE.ConeGeometry(size.w / 2, size.h, 16);
        case 'plane':
            return new THREE.PlaneGeometry(size.w, size.d);
        case 'ramp':
            const rampShape = new THREE.Shape();
            rampShape.moveTo(0, 0);
            rampShape.lineTo(size.d, 0);
            rampShape.lineTo(size.d, size.h);
            rampShape.lineTo(0, 0);
            const extrudeSettings = { depth: size.w, bevelEnabled: false };
            return new THREE.ExtrudeGeometry(rampShape, extrudeSettings);
        default:
            return new THREE.BoxGeometry(size.w, size.h, size.d);
    }
}

function updateEditorPreview() {
    if (!mapEditor.previewScene) return;
    
    if (mapEditor.previewMesh) {
        mapEditor.previewScene.remove(mapEditor.previewMesh);
        mapEditor.previewMesh.geometry.dispose();
        mapEditor.previewMesh.material.dispose();
    }
    
    const geo = createEditorGeometry(mapEditor.selectedShape, mapEditor.objectSize);
    const mat = new THREE.MeshStandardMaterial({ color: mapEditor.selectedColor });
    mapEditor.previewMesh = new THREE.Mesh(geo, mat);
    
    if (mapEditor.selectedShape === 'plane') {
        mapEditor.previewMesh.rotation.x = -Math.PI / 2;
    }
    if (mapEditor.selectedShape === 'ramp') {
        mapEditor.previewMesh.position.set(-mapEditor.objectSize.w / 2, 0, -mapEditor.objectSize.d / 2);
    }
    
    mapEditor.previewScene.add(mapEditor.previewMesh);
    
    // Auto-rotate preview
    if (mapEditor.previewMesh) {
        mapEditor.previewMesh.rotation.y = Date.now() * 0.001;
    }
    
    mapEditor.previewRenderer.render(mapEditor.previewScene, mapEditor.previewCamera);
}

function animateEditorPreview() {
    if (!mapEditor.active) return;
    requestAnimationFrame(animateEditorPreview);
    if (mapEditor.previewMesh) {
        mapEditor.previewMesh.rotation.y = Date.now() * 0.001;
    }
    mapEditor.previewRenderer.render(mapEditor.previewScene, mapEditor.previewCamera);
}

function createGhostMesh() {
    if (mapEditor.ghostMesh) {
        scene.remove(mapEditor.ghostMesh);
        mapEditor.ghostMesh.geometry.dispose();
        mapEditor.ghostMesh.material.dispose();
    }
    
    let geo, mat;
    if (mapEditor.selectedShape === 'spawn') {
        // Spawn marker - cylinder with flag look
        geo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
        mat = new THREE.MeshStandardMaterial({ 
            color: 0x4ade80,
            transparent: true,
            opacity: 0.7,
            emissive: 0x4ade80,
            emissiveIntensity: 0.3
        });
    } else {
        geo = createEditorGeometry(mapEditor.selectedShape, mapEditor.objectSize);
        mat = new THREE.MeshStandardMaterial({ 
            color: mapEditor.selectedColor,
            transparent: true,
            opacity: 0.6
        });
    }
    mapEditor.ghostMesh = new THREE.Mesh(geo, mat);
    mapEditor.ghostMesh.rotation.y = mapEditor.rotation;
    
    if (mapEditor.selectedShape === 'plane') {
        mapEditor.ghostMesh.rotation.x = -Math.PI / 2;
    }
    if (mapEditor.selectedShape === 'spawn') {
        mapEditor.ghostMesh.position.y = 1; // Lift spawn marker
    }
    
    scene.add(mapEditor.ghostMesh);
}

function updateGhostPosition(event) {
    if (!mapEditor.ghostMesh || !mapEditor.active) return;
    
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
    );
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    
    // Raycast against editor floor and placed objects
    const floorTarget = mapEditor.editorFloor || floor;
    const targets = [floorTarget, ...mapEditor.placedObjects.map(o => o.mesh)];
    const intersects = raycaster.intersectObjects(targets);
    
    if (intersects.length > 0) {
        const hit = intersects[0];
        const pos = hit.point.clone();
        
        // Snap to grid (0.5 units)
        pos.x = Math.round(pos.x * 2) / 2;
        pos.z = Math.round(pos.z * 2) / 2;
        
        // Place on top of hit surface
        if (mapEditor.selectedShape === 'plane') {
            pos.y = hit.point.y + 0.01;
        } else {
            pos.y = hit.point.y + mapEditor.objectSize.h / 2;
        }
        
        mapEditor.ghostMesh.position.copy(pos);
    }
}

function placeObject() {
    if (!mapEditor.ghostMesh) return;
    
    // Handle spawn placement
    if (mapEditor.selectedShape === 'spawn') {
        const maxSpawns = getMaxSpawns();
        if (maxSpawns !== Infinity && mapEditor.spawnPoints.length >= maxSpawns) {
            return; // Can't place more spawns
        }
        
        const geo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x4ade80,
            emissive: 0x4ade80,
            emissiveIntensity: 0.2
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(mapEditor.ghostMesh.position);
        mesh.position.y = 1;
        scene.add(mesh);
        
        mapEditor.spawnPoints.push({
            mesh,
            position: mesh.position.clone()
        });
        
        // Save action for undo
        saveEditorAction({
            type: 'placeSpawn',
            mesh,
            data: { position: mesh.position.clone() }
        });
        
        updateSpawnsUI();
        return;
    }
    
    const geo = createEditorGeometry(mapEditor.selectedShape, { ...mapEditor.objectSize });
    const mat = new THREE.MeshStandardMaterial({ color: mapEditor.selectedColor });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(mapEditor.ghostMesh.position);
    mesh.rotation.copy(mapEditor.ghostMesh.rotation);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    
    scene.add(mesh);
    obstacles.push(mesh);
    
    const objData = {
        mesh,
        shape: mapEditor.selectedShape,
        color: mapEditor.selectedColor,
        size: { ...mapEditor.objectSize },
        position: mesh.position.clone(),
        rotation: mesh.rotation.clone()
    };
    mapEditor.placedObjects.push(objData);
    
    // Save action for undo
    saveEditorAction({
        type: 'place',
        mesh,
        data: { ...objData }
    });
}

function getMaxSpawns() {
    switch(mapEditor.mapMode) {
        case '1v1': return 2;
        case '5v5': return 10;
        case 'ffa': return Infinity;
        case 'sandbox': return Infinity;
        default: return 2;
    }
}

function updateSpawnsUI() {
    const placed = document.getElementById('spawns-placed');
    const needed = document.getElementById('spawns-needed');
    if (placed) placed.textContent = mapEditor.spawnPoints.length;
    if (needed) {
        const max = getMaxSpawns();
        needed.textContent = max === Infinity ? '∞' : max;
    }
}

// Undo/Redo system
function saveEditorAction(action) {
    mapEditor.undoStack.push(action);
    mapEditor.redoStack = []; // Clear redo stack on new action
    if (mapEditor.undoStack.length > 50) mapEditor.undoStack.shift(); // Limit history
}

function editorUndo() {
    if (mapEditor.undoStack.length === 0) return;
    const action = mapEditor.undoStack.pop();
    
    if (action.type === 'place') {
        // Remove the placed object
        const obj = mapEditor.placedObjects.find(o => o.mesh === action.mesh);
        if (obj) {
            scene.remove(action.mesh);
            const idx = obstacles.indexOf(action.mesh);
            if (idx !== -1) obstacles.splice(idx, 1);
            action.mesh.geometry.dispose();
            action.mesh.material.dispose();
            mapEditor.placedObjects = mapEditor.placedObjects.filter(o => o.mesh !== action.mesh);
        }
    } else if (action.type === 'placeSpawn') {
        // Remove spawn
        const spawn = mapEditor.spawnPoints.find(s => s.mesh === action.mesh);
        if (spawn) {
            scene.remove(action.mesh);
            action.mesh.geometry.dispose();
            action.mesh.material.dispose();
            mapEditor.spawnPoints = mapEditor.spawnPoints.filter(s => s.mesh !== action.mesh);
            updateSpawnsUI();
        }
    } else if (action.type === 'remove') {
        // Restore removed object
        const geo = createEditorGeometry(action.data.shape, action.data.size);
        const mat = new THREE.MeshStandardMaterial({ color: action.data.color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(action.data.position);
        mesh.rotation.copy(action.data.rotation);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        obstacles.push(mesh);
        mapEditor.placedObjects.push({
            mesh,
            shape: action.data.shape,
            color: action.data.color,
            size: action.data.size,
            position: mesh.position.clone(),
            rotation: mesh.rotation.clone()
        });
        action.mesh = mesh; // Update reference for redo
    } else if (action.type === 'removeSpawn') {
        // Restore spawn
        const geo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x4ade80,
            emissive: 0x4ade80,
            emissiveIntensity: 0.2
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(action.data.position);
        scene.add(mesh);
        mapEditor.spawnPoints.push({ mesh, position: mesh.position.clone() });
        action.mesh = mesh;
        updateSpawnsUI();
    }
    
    mapEditor.redoStack.push(action);
}

function editorRedo() {
    if (mapEditor.redoStack.length === 0) return;
    const action = mapEditor.redoStack.pop();
    
    if (action.type === 'place') {
        // Re-place object
        const geo = createEditorGeometry(action.data.shape, action.data.size);
        const mat = new THREE.MeshStandardMaterial({ color: action.data.color });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(action.data.position);
        mesh.rotation.copy(action.data.rotation);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);
        obstacles.push(mesh);
        mapEditor.placedObjects.push({
            mesh,
            shape: action.data.shape,
            color: action.data.color,
            size: action.data.size,
            position: mesh.position.clone(),
            rotation: mesh.rotation.clone()
        });
        action.mesh = mesh;
    } else if (action.type === 'placeSpawn') {
        // Re-place spawn
        const geo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
        const mat = new THREE.MeshStandardMaterial({ 
            color: 0x4ade80,
            emissive: 0x4ade80,
            emissiveIntensity: 0.2
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(action.data.position);
        scene.add(mesh);
        mapEditor.spawnPoints.push({ mesh, position: mesh.position.clone() });
        action.mesh = mesh;
        updateSpawnsUI();
    } else if (action.type === 'remove' || action.type === 'removeSpawn') {
        // Re-remove object
        if (action.mesh) {
            scene.remove(action.mesh);
            if (action.type === 'remove') {
                const idx = obstacles.indexOf(action.mesh);
                if (idx !== -1) obstacles.splice(idx, 1);
                mapEditor.placedObjects = mapEditor.placedObjects.filter(o => o.mesh !== action.mesh);
            } else {
                mapEditor.spawnPoints = mapEditor.spawnPoints.filter(s => s.mesh !== action.mesh);
                updateSpawnsUI();
            }
            action.mesh.geometry.dispose();
            action.mesh.material.dispose();
        }
    }
    
    mapEditor.undoStack.push(action);
}

function removeObjectAt(event) {
    const rect = renderer.domElement.getBoundingClientRect();
    const mouse = new THREE.Vector2(
        ((event.clientX - rect.left) / rect.width) * 2 - 1,
        -((event.clientY - rect.top) / rect.height) * 2 + 1
    );
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);
    
    // Check spawns first
    const spawnMeshes = mapEditor.spawnPoints.map(s => s.mesh);
    const spawnIntersects = raycaster.intersectObjects(spawnMeshes);
    if (spawnIntersects.length > 0) {
        const hitMesh = spawnIntersects[0].object;
        const index = mapEditor.spawnPoints.findIndex(s => s.mesh === hitMesh);
        if (index !== -1) {
            const spawn = mapEditor.spawnPoints[index];
            // Save for undo before removing
            saveEditorAction({
                type: 'removeSpawn',
                mesh: hitMesh,
                data: { position: spawn.position.clone() }
            });
            scene.remove(hitMesh);
            mapEditor.spawnPoints.splice(index, 1);
            updateSpawnsUI();
        }
        return;
    }
    
    const meshes = mapEditor.placedObjects.map(o => o.mesh);
    const intersects = raycaster.intersectObjects(meshes);
    
    if (intersects.length > 0) {
        const hitMesh = intersects[0].object;
        const index = mapEditor.placedObjects.findIndex(o => o.mesh === hitMesh);
        if (index !== -1) {
            const obj = mapEditor.placedObjects[index];
            // Save for undo before removing
            saveEditorAction({
                type: 'remove',
                mesh: hitMesh,
                data: {
                    shape: obj.shape,
                    color: obj.color,
                    size: { ...obj.size },
                    position: obj.position.clone(),
                    rotation: obj.rotation.clone()
                }
            });
            scene.remove(hitMesh);
            const obsIdx = obstacles.indexOf(hitMesh);
            if (obsIdx !== -1) obstacles.splice(obsIdx, 1);
            mapEditor.placedObjects.splice(index, 1);
        }
    }
}

function setupEditorScene() {
    // Store original game objects visibility
    mapEditor.hiddenObjects = [];
    
    // Backup current map state once and hide it while editing
    if (!mapEditor.savedColliders) {
        mapEditor.savedColliders = colliders.slice();
    }
    mapEditor.mapWasVisible = mapGroup.visible;
    mapGroup.visible = false;

    // Editor uses its own collision list
    colliders.length = 0;
    
    // Hide all game obstacles (but not lights!)
    if (obstacles.length) {
        obstacles.forEach(o => {
            if (o.visible) {
                mapEditor.hiddenObjects.push(o);
                o.visible = false;
            }
        });
    }
    if (floor) {
        floor.visible = false;
    }
    enemies.forEach(e => { if (e.mesh) e.mesh.visible = false; });
    
    // Create editor floor if not exists
    if (!mapEditor.editorFloor) {
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.MeshStandardMaterial({ 
            color: 0x2a2a4e,
            roughness: 0.8
        });
        mapEditor.editorFloor = new THREE.Mesh(floorGeo, floorMat);
        mapEditor.editorFloor.rotation.x = -Math.PI / 2;
        mapEditor.editorFloor.receiveShadow = true;
        
        // Add grid helper
        mapEditor.gridHelper = new THREE.GridHelper(100, 50, 0x555555, 0x444444);
        mapEditor.gridHelper.position.y = 0.02;
    }
    
    scene.add(mapEditor.editorFloor);
    scene.add(mapEditor.gridHelper);
    if (mapEditor.gridHelper) {
        mapEditor.gridHelper.visible = true;
    }
    if (mapEditor.editorFloor) {
        mapEditor.editorFloor.visible = true;
    }
    
    // Add starting platform only if no objects yet
    if (mapEditor.placedObjects.length === 0) {
        const platformGeo = new THREE.BoxGeometry(10, 1, 10);
        const platformMat = new THREE.MeshStandardMaterial({ color: 0x5a5a8a });
        const platform = new THREE.Mesh(platformGeo, platformMat);
        platform.position.set(0, 0.5, 0);
        platform.castShadow = true;
        platform.receiveShadow = true;
        scene.add(platform);
        
        mapEditor.placedObjects.push({
            mesh: platform,
            shape: 'box',
            color: '#5a5a8a',
            size: { w: 10, h: 1, d: 10 },
            position: platform.position.clone(),
            rotation: platform.rotation.clone()
        });
    } else {
        // Re-add existing placed objects to scene
        mapEditor.placedObjects.forEach(obj => {
            if (!scene.children.includes(obj.mesh)) {
                scene.add(obj.mesh);
            }
        });
    }
}

function cleanupEditorScene() {
    // Remove editor-specific objects
    if (mapEditor.editorFloor) {
        scene.remove(mapEditor.editorFloor);
    }
    if (mapEditor.gridHelper) {
        scene.remove(mapEditor.gridHelper);
    }
    
    // Remove placed editor objects from scene and obstacles
    mapEditor.placedObjects.forEach(obj => {
        scene.remove(obj.mesh);
        const idx = obstacles.indexOf(obj.mesh);
        if (idx !== -1) obstacles.splice(idx, 1);
        obj.mesh.geometry.dispose();
        obj.mesh.material.dispose();
    });
    mapEditor.placedObjects = [];
    
    // Show game objects again
    mapEditor.hiddenObjects.forEach(o => o.visible = true);
    mapEditor.hiddenObjects = [];
    if (floor) {
        floor.visible = true;
    }
    enemies.forEach(e => { if (e.mesh) e.mesh.visible = true; });
    
    // Restore original map visibility and colliders
    if (mapEditor.savedColliders) {
        colliders.length = 0;
        colliders.push(...mapEditor.savedColliders);
        mapEditor.savedColliders = null;
    }
    mapGroup.visible = mapEditor.mapWasVisible !== undefined ? mapEditor.mapWasVisible : true;
}

function startMapEditor() {
    mapEditor.active = true;
    document.getElementById('menu').style.display = 'none';
    document.getElementById('map-editor').style.display = 'block';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    
    // Hide weapons in editor
    weaponGroup.visible = false;
    sniperGroup.visible = false;
    knifeGroup.visible = false;
    rocketLauncherGroup.visible = false;
    
    // Save original scene settings
    if (!mapEditor.originalBackground) {
        mapEditor.originalBackground = scene.background;
        mapEditor.originalFog = scene.fog;
    }
    
    // Set editor background
    scene.background = new THREE.Color(0x1a1a2e);
    scene.fog = null;
    
    // Setup empty editor scene
    setupEditorScene();
    
    // Update spawns UI
    updateSpawnsUI();
    
    // Reset camera for editor
    camera.position.set(0, 30, 30);
    camera.lookAt(0, 0, 0);
    editorCameraState.orbitAngle = 0;
    editorCameraState.orbitHeight = 30;
    editorCameraState.orbitDistance = 40;
    editorCameraState.target.set(0, 0, 0);
    updateEditorCamera();
    
    // Init preview if not done
    if (!mapEditor.previewRenderer) {
        initEditorPreview();
    }
    
    createGhostMesh();
    animateEditorPreview();
    
    // Start editor render loop
    editorAnimate();
}

function exitMapEditor() {
    mapEditor.active = false;
    document.getElementById('map-editor').style.display = 'none';
    document.getElementById('menu').style.display = 'flex';
    
    if (mapEditor.ghostMesh) {
        scene.remove(mapEditor.ghostMesh);
        mapEditor.ghostMesh.geometry.dispose();
        mapEditor.ghostMesh.material.dispose();
        mapEditor.ghostMesh = null;
    }
    
    // Restore original scene settings
    if (mapEditor.originalBackground) {
        scene.background = mapEditor.originalBackground;
    }
    if (mapEditor.originalFog) {
        scene.fog = mapEditor.originalFog;
    }
    
    // Cleanup editor scene (also clears placed objects)
    cleanupEditorScene();
}

function clearEditorObjects() {
    mapEditor.placedObjects.forEach(obj => {
        scene.remove(obj.mesh);
        const idx = obstacles.indexOf(obj.mesh);
        if (idx !== -1) obstacles.splice(idx, 1);
        obj.mesh.geometry.dispose();
        obj.mesh.material.dispose();
    });
    mapEditor.placedObjects = [];
    
    // Clear spawns too
    mapEditor.spawnPoints.forEach(spawn => {
        scene.remove(spawn.mesh);
        spawn.mesh.geometry.dispose();
        spawn.mesh.material.dispose();
    });
    mapEditor.spawnPoints = [];
    updateSpawnsUI();
}

function saveEditorMap() {
    const mapData = {
        mode: mapEditor.mapMode,
        objects: mapEditor.placedObjects.map(obj => ({
            shape: obj.shape,
            color: obj.color,
            size: obj.size,
            position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
            rotation: { x: obj.rotation.x, y: obj.rotation.y, z: obj.rotation.z }
        })),
        spawns: mapEditor.spawnPoints.map(s => ({
            x: s.position.x,
            y: s.position.y,
            z: s.position.z
        }))
    };
    const json = JSON.stringify(mapData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'standoff-map.json';
    a.click();
    URL.revokeObjectURL(url);
}

function loadEditorMap() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            try {
                const parsed = JSON.parse(ev.target.result);
                clearEditorObjects();
                
                // Support old format (array) and new format (object)
                const objects = Array.isArray(parsed) ? parsed : (parsed.objects || []);
                const spawns = parsed.spawns || [];
                const mode = parsed.mode || '1v1';
                
                // Set map mode
                mapEditor.mapMode = mode;
                document.getElementById('editor-map-mode').value = mode;
                
                // Load objects
                objects.forEach(obj => {
                    const geo = createEditorGeometry(obj.shape, obj.size);
                    const mat = new THREE.MeshStandardMaterial({ color: obj.color });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(obj.position.x, obj.position.y, obj.position.z);
                    mesh.rotation.set(obj.rotation.x, obj.rotation.y, obj.rotation.z);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    scene.add(mesh);
                    obstacles.push(mesh);
                    mapEditor.placedObjects.push({
                        mesh,
                        shape: obj.shape,
                        color: obj.color,
                        size: obj.size,
                        position: mesh.position.clone(),
                        rotation: mesh.rotation.clone()
                    });
                });
                
                // Load spawns
                spawns.forEach(s => {
                    const geo = new THREE.CylinderGeometry(0.3, 0.3, 2, 8);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: 0x4ade80,
                        emissive: 0x4ade80,
                        emissiveIntensity: 0.2
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(s.x, s.y, s.z);
                    scene.add(mesh);
                    mapEditor.spawnPoints.push({
                        mesh,
                        position: mesh.position.clone()
                    });
                });
                
                updateSpawnsUI();
            } catch (err) {
                console.error('Failed to load map:', err);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function testEditorMap() {
    mapEditor.active = false;
    mapEditor.testMode = true;
    document.getElementById('map-editor').style.display = 'none';
    mapGroup.visible = false;
    
    if (mapEditor.ghostMesh) {
        scene.remove(mapEditor.ghostMesh);
        mapEditor.ghostMesh.geometry.dispose();
        mapEditor.ghostMesh.material.dispose();
        mapEditor.ghostMesh = null;
    }
    
    // Hide grid for cleaner look
    if (mapEditor.gridHelper) {
        mapEditor.gridHelper.visible = false;
    }
    
    // Fresh collision list only with editor content
    colliders.length = 0;
    
    // Hide enemies in test mode
    enemies.forEach(e => { if (e.mesh) e.mesh.visible = false; if (e.group) e.group.visible = false; });
    
    // Add editor floor to colliders for ground detection
    if (mapEditor.editorFloor) {
        mapEditor.editorFloor.visible = true;
        colliders.push({ 
            mesh: mapEditor.editorFloor,
            box: new THREE.Box3().setFromObject(mapEditor.editorFloor)
        });
    }
    
    // Add placed objects to colliders and obstacles for collision
    mapEditor.placedObjects.forEach(obj => {
        if (!obstacles.includes(obj.mesh)) {
            obstacles.push(obj.mesh);
        }
        colliders.push({ 
            mesh: obj.mesh,
            box: new THREE.Box3().setFromObject(obj.mesh)
        });
    });
    
    // Reset player state
    state.isPlaying = true;
    state.health = CONFIG.player.maxHealth;
    state.ammo = CONFIG.rifle.magSize;
    state.reserveAmmo = CONFIG.rifle.reserveAmmo;
    state.isReloading = false;
    state.currentWeapon = 'rifle';
    state.velocity = new THREE.Vector3();
    state.isGrounded = true;
    
    // Position player on the platform
    camera.position.set(0, CONFIG.player.height + 1.5, 5);
    camera.rotation.set(0, Math.PI, 0);
    
    // Show HUD
    document.getElementById('hud').style.display = 'block';
    document.getElementById('crosshair').style.display = 'block';
    document.getElementById('menu').style.display = 'none';
    
    // Show weapon
    switchWeapon('rifle');
    updateAmmoDisplay();
    updateHealthBar();
    
    if (!isMobile) {
        document.getElementById('game-container').requestPointerLock();
    }
    if (isMobile) {
        document.getElementById('mobile-controls').classList.add('active');
    }
}

function exitTestMode() {
    if (!mapEditor.testMode) return;
    
    mapEditor.testMode = false;
    state.isPlaying = false;
    
    // Remove editor floor from colliders
    if (mapEditor.editorFloor) {
        const floorIdx = colliders.findIndex(c => c.mesh === mapEditor.editorFloor);
        if (floorIdx !== -1) colliders.splice(floorIdx, 1);
    }
    
    // Remove placed objects from obstacles and colliders
    mapEditor.placedObjects.forEach(obj => {
        const idx = obstacles.indexOf(obj.mesh);
        if (idx !== -1) obstacles.splice(idx, 1);
        const colIdx = colliders.findIndex(c => c.mesh === obj.mesh);
        if (colIdx !== -1) colliders.splice(colIdx, 1);
    });
    colliders.length = 0;
    
    // Hide HUD
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    
    if (!isMobile) document.exitPointerLock();
    
    // Return to editor
    startMapEditor();
}

// Editor camera controls
const editorCameraState = {
    isDragging: false,
    lastX: 0,
    lastY: 0,
    orbitAngle: 0,
    orbitHeight: 30,
    orbitDistance: 40,
    target: new THREE.Vector3(0, 0, 0)
};

function updateEditorCamera() {
    const x = editorCameraState.target.x + Math.sin(editorCameraState.orbitAngle) * editorCameraState.orbitDistance;
    const z = editorCameraState.target.z + Math.cos(editorCameraState.orbitAngle) * editorCameraState.orbitDistance;
    camera.position.set(x, editorCameraState.orbitHeight, z);
    camera.lookAt(editorCameraState.target);
}

function editorAnimate() {
    if (!mapEditor.active) return;
    requestAnimationFrame(editorAnimate);
    renderer.render(scene, camera);
}

// Editor event listeners
document.getElementById('map-editor-btn').addEventListener('click', startMapEditor);
document.getElementById('editor-exit').addEventListener('click', exitMapEditor);
document.getElementById('editor-clear').addEventListener('click', clearEditorObjects);
document.getElementById('editor-save').addEventListener('click', saveEditorMap);
document.getElementById('editor-load').addEventListener('click', loadEditorMap);
document.getElementById('editor-test').addEventListener('click', testEditorMap);
document.getElementById('editor-undo').addEventListener('click', editorUndo);
document.getElementById('editor-redo').addEventListener('click', editorRedo);

// Map mode selector
document.getElementById('editor-map-mode').addEventListener('change', (e) => {
    mapEditor.mapMode = e.target.value;
    updateSpawnsUI();
});

// Shape buttons
document.querySelectorAll('.editor-shape-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.editor-shape-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mapEditor.selectedShape = btn.dataset.shape;
        createGhostMesh();
        updateEditorPreview();
    });
});

// Color buttons
document.querySelectorAll('.editor-color-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.editor-color-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        mapEditor.selectedColor = btn.dataset.color;
        document.getElementById('editor-color-picker').value = btn.dataset.color;
        createGhostMesh();
        updateEditorPreview();
    });
});

// Color picker
document.getElementById('editor-color-picker').addEventListener('input', (e) => {
    document.querySelectorAll('.editor-color-btn').forEach(b => b.classList.remove('active'));
    mapEditor.selectedColor = e.target.value;
    createGhostMesh();
    updateEditorPreview();
});

// Size inputs
['w', 'h', 'd'].forEach(dim => {
    document.getElementById(`editor-size-${dim}`).addEventListener('input', (e) => {
        mapEditor.objectSize[dim] = parseFloat(e.target.value) || 1;
        createGhostMesh();
        updateEditorPreview();
    });
});

// Mouse events for editor
document.addEventListener('mousemove', (e) => {
    if (!mapEditor.active) return;
    
    if (editorCameraState.isDragging) {
        const dx = e.clientX - editorCameraState.lastX;
        const dy = e.clientY - editorCameraState.lastY;
        editorCameraState.orbitAngle += dx * 0.01;
        editorCameraState.orbitHeight = Math.max(5, Math.min(100, editorCameraState.orbitHeight - dy * 0.5));
        editorCameraState.lastX = e.clientX;
        editorCameraState.lastY = e.clientY;
        updateEditorCamera();
    } else {
        updateGhostPosition(e);
    }
});

document.addEventListener('mousedown', (e) => {
    if (!mapEditor.active) return;
    
    // Check if clicking on UI
    if (e.target.closest('#editor-toolbar') || 
        e.target.closest('#editor-controls') || 
        e.target.closest('#editor-preview') ||
        e.target.closest('#editor-info')) {
        return;
    }
    
    if (e.button === 0) { // Left click - place
        placeObject();
    } else if (e.button === 2) { // Right click - orbit camera
        editorCameraState.isDragging = true;
        editorCameraState.lastX = e.clientX;
        editorCameraState.lastY = e.clientY;
    } else if (e.button === 1) { // Middle click - remove
        removeObjectAt(e);
    }
});

document.addEventListener('mouseup', (e) => {
    if (e.button === 2) {
        editorCameraState.isDragging = false;
    }
});

document.addEventListener('wheel', (e) => {
    if (!mapEditor.active) return;
    
    if (e.shiftKey) {
        // Change size with scroll + shift
        const delta = e.deltaY > 0 ? -0.5 : 0.5;
        mapEditor.objectSize.w = Math.max(0.5, Math.min(50, mapEditor.objectSize.w + delta));
        mapEditor.objectSize.h = Math.max(0.5, Math.min(50, mapEditor.objectSize.h + delta));
        mapEditor.objectSize.d = Math.max(0.5, Math.min(50, mapEditor.objectSize.d + delta));
        document.getElementById('editor-size-w').value = mapEditor.objectSize.w;
        document.getElementById('editor-size-h').value = mapEditor.objectSize.h;
        document.getElementById('editor-size-d').value = mapEditor.objectSize.d;
        createGhostMesh();
        updateEditorPreview();
    } else {
        // Zoom camera
        editorCameraState.orbitDistance = Math.max(10, Math.min(100, editorCameraState.orbitDistance + e.deltaY * 0.05));
        updateEditorCamera();
    }
});

document.addEventListener('keydown', (e) => {
    if (!mapEditor.active) return;
    
    // Ctrl+Z for undo, Ctrl+Y for redo
    if (e.ctrlKey || e.metaKey) {
        if (e.code === 'KeyZ') {
            e.preventDefault();
            editorUndo();
            return;
        } else if (e.code === 'KeyY') {
            e.preventDefault();
            editorRedo();
            return;
        }
    }
    
    const moveSpeed = 2;
    switch (e.code) {
        case 'KeyW':
            editorCameraState.target.z -= moveSpeed;
            updateEditorCamera();
            break;
        case 'KeyS':
            editorCameraState.target.z += moveSpeed;
            updateEditorCamera();
            break;
        case 'KeyA':
            editorCameraState.target.x -= moveSpeed;
            updateEditorCamera();
            break;
        case 'KeyD':
            editorCameraState.target.x += moveSpeed;
            updateEditorCamera();
            break;
        case 'KeyR':
            mapEditor.rotation += Math.PI / 4;
            if (mapEditor.ghostMesh) {
                mapEditor.ghostMesh.rotation.y = mapEditor.rotation;
            }
            break;
        case 'Escape':
            exitMapEditor();
            break;
    }
});

// Prevent context menu in editor
document.getElementById('map-editor').addEventListener('contextmenu', (e) => e.preventDefault());

// Exit button (leave match or back to menu) - only for mobile/multiplayer
document.getElementById('exit-btn').addEventListener('click', () => {
    if (state.isMultiplayer) {
        leaveMultiplayer();
    } else {
        exitToMenu();
    }
    document.getElementById('exit-btn').style.display = 'none';
});

// Secret code / cheats
const CHEATS_STORAGE_KEY = 'standoffCheatsV2';
const SETTINGS_STORAGE_KEY = 'standoffSettingsV1';
const secretInput = document.getElementById('secret-code');
const cheatPanel = document.getElementById('cheat-panel');
const adminPanel = document.getElementById('admin-panel');
const adminBanner = document.getElementById('admin-banner');
// Admin panel inputs (for checking if typing)
const adminTextareas = () => document.querySelectorAll('#admin-panel textarea');
const sensDesktop = document.getElementById('sens-desktop');
const sensDesktopVal = document.getElementById('sens-desktop-val');
const sensMobile = document.getElementById('sens-mobile');
const sensMobileVal = document.getElementById('sens-mobile-val');
const adminToggle = document.getElementById('cheat-admin-toggle');
const cheatControls = [
    { id: 'cheat-god', key: 'godMode' },
    { id: 'cheat-ammo', key: 'infiniteAmmo' },
    { id: 'cheat-recoil', key: 'noRecoil' },
    { id: 'cheat-speed', key: 'speedBoost' },
    { id: 'cheat-speed-mul', key: 'speedMultiplier', isSlider: true },
    { id: 'cheat-fly', key: 'fly' },
    { id: 'cheat-noclip', key: 'noclip' },
    { id: 'cheat-wallbang', key: 'wallbang' },
    { id: 'cheat-rapid', key: 'rapidFire' },
    { id: 'cheat-esp', key: 'esp' },
    { id: 'cheat-aimbot', key: 'aimbot' }
];

function loadCheatsState() {
    try {
        const saved = localStorage.getItem(CHEATS_STORAGE_KEY);
        if (saved) {
            return JSON.parse(saved);
        }
    } catch (e) {}
    return { unlocked: false, adminUnlocked: false, cheats: {} };
}

function saveCheatsState() {
    try {
        localStorage.setItem(CHEATS_STORAGE_KEY, JSON.stringify({
            unlocked: state.cheatsUnlocked,
            adminUnlocked: state.adminUnlocked,
            cheats: state.cheats
        }));
    } catch (e) {}
}

function loadSettingsState() {
    try {
        const s = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (s) return JSON.parse(s);
    } catch (e) {}
    return {};
}

function saveSettingsState() {
    try {
        localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(state.settings));
    } catch (e) {}
}

function applyCheatUIFromState() {
    cheatControls.forEach(({ id, key }) => {
        const el = document.getElementById(id);
        if (!el) return;
        if (el.type === 'range') {
            el.value = state.cheats[key] || 2;
            const valEl = document.getElementById('cheat-speed-mul-val');
            if (valEl) valEl.textContent = `${parseFloat(el.value).toFixed(1)}x`;
        } else {
            el.checked = !!state.cheats[key];
        }
    });
    if (state.cheatsUnlocked) {
        cheatPanel.classList.add('active');
        document.getElementById('secret-wrapper').classList.add('unlocked');
    }
}

// Load cheats at startup
function normalizeCheatsEnabled() {
    const active = Object.entries(state.cheats).some(([k, v]) => {
        if (k === 'enabled' || k === 'speedMultiplier') return false;
        return !!v;
    });
    state.cheats.enabled = state.cheatsUnlocked && active;
    if (!state.cheats.enabled) {
        Object.keys(state.cheats).forEach(k => {
            if (k === 'enabled' || k === 'speedMultiplier') return;
            state.cheats[k] = false;
        });
    }
}

const savedCheats = loadCheatsState();
state.cheatsUnlocked = !!savedCheats.unlocked;
if (savedCheats.cheats) {
    Object.assign(state.cheats, savedCheats.cheats);
}
state.adminUnlocked = !!savedCheats.adminUnlocked;
if (typeof state.cheats.speedMultiplier !== 'number' || isNaN(state.cheats.speedMultiplier)) {
    state.cheats.speedMultiplier = 2;
}
normalizeCheatsEnabled();
applyCheatUIFromState();
if (state.adminUnlocked && adminToggle) {
    adminToggle.checked = true;
}

// Settings load
const savedSettings = loadSettingsState();
if (typeof savedSettings.desktopSensitivity === 'number') state.settings.desktopSensitivity = savedSettings.desktopSensitivity;
if (typeof savedSettings.mobileLookSensitivity === 'number') state.settings.mobileLookSensitivity = savedSettings.mobileLookSensitivity;
controls.sensitivity = state.settings.desktopSensitivity;
const mobileLookSensitivity = () => state.settings.mobileLookSensitivity;
if (sensDesktop) {
    sensDesktop.value = state.settings.desktopSensitivity;
    sensDesktopVal.textContent = parseFloat(state.settings.desktopSensitivity).toFixed(3);
}
if (sensMobile) {
    sensMobile.value = state.settings.mobileLookSensitivity;
    sensMobileVal.textContent = parseFloat(state.settings.mobileLookSensitivity).toFixed(3);
}

function unlockCheats() {
    const code = secretInput.value.trim();
    if (code === 'тикитоки') {
        state.adminUnlocked = true;
        state.cheatsUnlocked = true;
        cheatPanel.classList.add('active');
        adminPanel.classList.add('active');
        document.getElementById('secret-wrapper').classList.add('unlocked');
        saveCheatsState();
        applyCheatUIFromState();
        normalizeCheatsEnabled();
        if (adminToggle) adminToggle.checked = true;
        if (adminPanel) adminPanel.classList.add('active');
    }
}

if (secretInput) {
    secretInput.addEventListener('change', unlockCheats);
    secretInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') unlockCheats();
    });
}

const adminOverlay = document.getElementById('admin-overlay');
const adminCloseBtn = document.getElementById('admin-close');
let adminPanelWasPlaying = false;

function openAdminPanel() {
    if (!state.adminUnlocked) return;
    if (adminPanel.classList.contains('active')) return;
    
    adminPanelWasPlaying = state.isPlaying;
    
    // Unlock cursor
    if (document.pointerLockElement) {
        document.exitPointerLock();
    }
    
    // Show panel and overlay
    adminPanel.classList.add('active');
    adminOverlay.classList.add('active');
}

function closeAdminPanel() {
    adminPanel.classList.remove('active');
    adminOverlay.classList.remove('active');
    
    // Re-lock cursor if was playing
    if (adminPanelWasPlaying && state.isPlaying && !isMobile) {
        document.getElementById('game-container').requestPointerLock();
    }
}

// Click to resume overlay
function showClickToResume() {
    let overlay = document.getElementById('click-resume-overlay');
    if (!overlay) {
        overlay = document.createElement('div');
        overlay.id = 'click-resume-overlay';
        overlay.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); z-index: 9000;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
        `;
        overlay.innerHTML = `<div style="color: white; font-size: 24px; text-align: center; 
            background: rgba(0,0,0,0.7); padding: 30px 50px; border-radius: 12px;">
            🎮 Кликните чтобы продолжить
        </div>`;
        overlay.addEventListener('click', () => {
            overlay.style.display = 'none';
            document.getElementById('game-container').requestPointerLock();
        });
        document.body.appendChild(overlay);
    }
    overlay.style.display = 'flex';
}

function toggleAdminPanel() {
    if (!state.adminUnlocked) return;
    
    if (adminPanel.classList.contains('active')) {
        closeAdminPanel();
    } else {
        openAdminPanel();
    }
}

// J key listener for admin panel (works when unlocked via secret code)
document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyJ') {
        if (!state.adminUnlocked) return;
        // Don't toggle if typing in textarea
        const textareas = adminTextareas();
        for (const ta of textareas) {
            if (document.activeElement === ta) return;
        }
        toggleAdminPanel();
    }
    
    // ESC - close admin panel or exit to menu
    if (e.code === 'Escape') {
        // First close admin panel if open
        if (adminPanel && adminPanel.classList.contains('active')) {
            closeAdminPanel();
            return;
        }

        // Close hammer panel in sandbox
        if (state.sandbox.active && isSandboxPanelOpen()) {
            toggleHammer(false);
            return;
        }
        
        // Exit test mode back to editor
        if (mapEditor.testMode) {
            e.preventDefault();
            exitTestMode();
            return;
        }

        // Otherwise exit to menu if playing
        if (state.isPlaying) {
            e.preventDefault();
            exitToMenu();
        }
    }
});

// Exit to menu function
function exitToMenu() {
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    
    // Stop sounds
    try {
        if (state.sounds.footsteps && !state.sounds.footsteps.paused) {
            state.sounds.footsteps.pause();
            state.sounds.footsteps.currentTime = 0;
        }
    } catch (e) {}
    
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    
    // Reset menu text
    const menu = document.getElementById('menu');
    menu.querySelector('h1').textContent = 'Standoff Online';
    menu.querySelector('p').textContent = 'Браузерный шутер';
    document.getElementById('play-btn').textContent = 'ИГРАТЬ';
}

// Close button
if (adminCloseBtn) {
    adminCloseBtn.addEventListener('click', closeAdminPanel);
}

// Click overlay to close
if (adminOverlay) {
    adminOverlay.addEventListener('click', closeAdminPanel);
}

// Admin Panel Tab Switching
const adminTabs = document.querySelectorAll('.admin-tab');
const adminTabPanes = document.querySelectorAll('.admin-tab-pane');

adminTabs.forEach(tab => {
    tab.addEventListener('click', () => {
        const targetTab = tab.dataset.tab;
        
        // Update active tab
        adminTabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        
        // Update active pane with animation
        adminTabPanes.forEach(pane => {
            pane.classList.remove('active');
            if (pane.id === `tab-${targetTab}`) {
                pane.classList.add('active');
            }
        });
    });
});

// Global send button
const adminSendGlobal = document.getElementById('admin-send-global');
const adminMsgGlobal = document.getElementById('admin-message-global');

if (adminSendGlobal) {
    adminSendGlobal.addEventListener('click', () => {
        const msg = (adminMsgGlobal?.value || '').trim();
        if (!msg) return;
        showAdminBanner('🌍 ' + msg); // Show with globe for myself
        if (!mpSocket || !mpSocket.connected) connectMultiplayer();
        if (mpSocket) {
            mpSocket.emit('adminMsg', { msg: msg, global: true }); // Send without globe to others
        }
        adminMsgGlobal.value = '';
        closeAdminPanel();
    });
}

// Local send button
const adminSendLocal = document.getElementById('admin-send-local');
const adminMsgLocal = document.getElementById('admin-message-local');

if (adminSendLocal) {
    adminSendLocal.addEventListener('click', () => {
        const msg = (adminMsgLocal?.value || '').trim();
        if (!msg) return;
        showAdminBanner('🖥️ ' + msg);
        if (!mpSocket || !mpSocket.connected) connectMultiplayer();
        if (mpSocket) {
            mpSocket.emit('adminMsg', { msg: '🖥️ ' + msg, global: false });
        }
        adminMsgLocal.value = '';
        closeAdminPanel();
    });
}

// Party mode buttons
const adminPartyGlobal = document.getElementById('admin-party-global');
const adminPartyLocal = document.getElementById('admin-party-local');

if (adminPartyGlobal) {
    adminPartyGlobal.addEventListener('click', () => {
        togglePartyMode('Федя');
        // Send to all servers via socket
        if (!mpSocket || !mpSocket.connected) connectMultiplayer();
        if (mpSocket) {
            mpSocket.emit('adminMsg', { 
                type: 'party', 
                active: state.partyMode, 
                global: true 
            });
        }
    });
}

if (adminPartyLocal) {
    adminPartyLocal.addEventListener('click', () => {
        // Local or solo - just toggle locally
        togglePartyMode('Федя');
        // If connected, send local only
        if (mpSocket && mpSocket.connected) {
            mpSocket.emit('adminMsg', { 
                type: 'party', 
                active: state.partyMode, 
                global: false 
            });
        }
    });
}

const adminSandboxClear = document.getElementById('admin-sandbox-clear');
if (adminSandboxClear) {
    adminSandboxClear.addEventListener('click', () => {
        clearSandboxObjectsLocal();
        if (!mpSocket || !mpSocket.connected) connectMultiplayer();
        if (mpSocket) {
            mpSocket.emit('sandboxClear');
        }
    });
}

const adminMobileBtn = document.getElementById('admin-mobile-btn');
function updateAdminMobileButton() {
    if (!adminMobileBtn) return;
    adminMobileBtn.style.display = (isMobile && state.adminUnlocked) ? 'block' : 'none';
}
updateAdminMobileButton();

if (adminToggle) {
    adminToggle.addEventListener('change', () => {
        if (adminToggle.checked) {
            state.adminUnlocked = true;
            adminPanel.classList.add('active');
        } else {
            adminPanel.classList.remove('active');
            state.adminUnlocked = false;
        }
        saveCheatsState();
        updateAdminMobileButton();
    });
}

function showAdminBanner(msg) {
    if (!adminBanner) return;
    adminBanner.textContent = msg;
    adminBanner.style.display = 'block';
    setTimeout(() => {
        adminBanner.style.display = 'none';
    }, 4000);
}

if (adminBanner) {
    adminBanner.addEventListener('click', () => {
        adminBanner.style.display = 'none';
    });
}

if (adminMobileBtn) {
    adminMobileBtn.addEventListener('click', () => {
        if (!state.adminUnlocked) return;
        toggleAdminPanel();
    });
}

cheatControls.forEach(({ id, key }) => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('change', () => {
        if (el.type === 'range') {
            state.cheats[key] = parseFloat(el.value) || 2;
            const valEl = document.getElementById('cheat-speed-mul-val');
            if (valEl) valEl.textContent = `${state.cheats[key].toFixed(1)}x`;
        } else {
            state.cheats[key] = !!el.checked;
        }
        // Если нужны немедленные эффекты — например, заполнить магазины при бесконечных патронах
        if (key === 'infiniteAmmo' && state.cheats.infiniteAmmo) {
            state.ammo = CONFIG.weapon.magazineSize;
            state.reserveAmmo = CONFIG.weapon.reserveAmmo;
            state.sniperAmmo = CONFIG.sniper.magazineSize;
            state.sniperReserve = CONFIG.sniper.reserveAmmo;
            updateHUD();
        }
        if (key === 'esp') {
            updateESPHighlight();
        }
        normalizeCheatsEnabled();
        saveCheatsState();
    });
});

// Sensitivity controls
function updateDesktopSens(val) {
    state.settings.desktopSensitivity = val;
    controls.sensitivity = val;
    if (sensDesktopVal) sensDesktopVal.textContent = val.toFixed(3);
    saveSettingsState();
}
function updateMobileSens(val) {
    state.settings.mobileLookSensitivity = val;
    if (sensMobileVal) sensMobileVal.textContent = val.toFixed(3);
    saveSettingsState();
}
if (sensDesktop) {
    sensDesktop.addEventListener('input', () => updateDesktopSens(parseFloat(sensDesktop.value) || 0.002));
}
if (sensMobile) {
    sensMobile.addEventListener('input', () => updateMobileSens(parseFloat(sensMobile.value) || 0.004));
}

// Window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Re-lock pointer after alt-tab / focus return
window.addEventListener('focus', () => {
    if (state.isPlaying && !controls.isLocked && !isMobile) {
        controls.lock();
    }
    updateMpScore();
});

// ==================== GAME LOOP ====================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    // Don't render if map editor is active (it has its own render loop)
    if (mapEditor.active) return;
    
    const delta = Math.min(clock.getDelta(), 0.1);
    
    if (state.isPlaying) {
        updatePlayer(delta);
        updateWeapon(delta);
        updateCrosshair(delta);
        
        // Health regeneration (2 HP per second, starts after 3 seconds without damage)
        // Crouching: faster regen (5 HP/s), starts after 1.5 seconds
        if (state.health < CONFIG.player.health && state.health > 0) {
            state.regenTimer = (state.regenTimer || 0) + delta;
            const regenDelay = state.isCrouching ? 1.5 : 3;
            const regenRate = state.isCrouching ? 5 : 2;
            if (state.regenTimer > regenDelay) {
                state.health = Math.min(CONFIG.player.health, state.health + regenRate * delta);
                updateHUD();
            }
        }
        
        // Update enemies (singleplayer only)
        if (!state.isMultiplayer) {
            enemies.forEach(enemy => {
                enemy.update(delta, camera.position);
                updateESPForActor(enemy);
            });
        }
    }
    
    updateParticles(delta);
    updateTracers(delta);
    updateGrenades(delta);
    updateFireworks(delta);
    updatePartyEffects(delta);
    if (!state.isMultiplayer) {
        updateBomb(delta);
    }
    updateRemotePlayers(delta);
    
    // Mobile joystick movement
    if (isMobile && state.isPlaying) {
        updateMobileMovement();
    }
    
    renderer.render(scene, camera);
}

// ==================== MOBILE CONTROLS ====================
// Default control positions
const defaultControls = {
    joystick: { x: 30, y: 30, size: 100 },
    shoot: { y: 40, size: 70, right: 30 },
    jump: { y: 120, size: 55, right: 30 },
    reload: { y: 40, size: 45, right: 120 },
    grenade: { y: 100, size: 45, right: 110 },
    weapon: { y: 160, size: 45, right: 110 },
    scope: { y: 190, size: 45, right: 30 },
    bomb: { y: 250, size: 45, right: 30 },
    crouch: { y: 220, size: 55, left: 30 }
};

function loadControlsConfig() {
    try {
        const saved = localStorage.getItem('standoffControls');
        if (saved) {
            return JSON.parse(saved);
        }
    } catch (e) {
        console.log('Failed to load controls config');
    }
    return JSON.parse(JSON.stringify(defaultControls));
}

let controlsConfig = loadControlsConfig();

function applyControlsConfig() {
    Object.keys(controlsConfig).forEach(key => {
        const el = document.querySelector(`[data-ctrl="${key}"]`);
        if (!el) return;
        
        const cfg = controlsConfig[key];
        el.style.width = cfg.size + 'px';
        el.style.height = cfg.size + 'px';
        el.style.fontSize = (cfg.size * 0.35) + 'px';
        
        if (cfg.right !== undefined && cfg.right !== null) {
            el.style.right = cfg.right + 'px';
            el.style.left = 'auto';
        } else if (cfg.left !== undefined && cfg.left !== null) {
            el.style.left = cfg.left + 'px';
            el.style.right = 'auto';
        } else if (cfg.x !== undefined && cfg.x !== null) {
            el.style.left = cfg.x + 'px';
            el.style.right = 'auto';
        }
        el.style.bottom = cfg.y + 'px';
    });
}

// Button emoji labels
var btnEmoji={shoot:String.fromCodePoint(0x1F52B),jump:String.fromCodePoint(0x2B06,0xFE0F),reload:String.fromCodePoint(0x1F504),grenade:String.fromCodePoint(0x1F4A5),weapon:String.fromCodePoint(0x1F500),scope:String.fromCodePoint(0x1F3AF),bomb:String.fromCodePoint(0x1F4A3),crouch:String.fromCodePoint(0x2B07,0xFE0F)};function setButtonLabels(){for(var k in btnEmoji){var b=document.getElementById('btn-'+k);if(b)b.textContent=btnEmoji[k];}}
// Apply on load
if(isMobile){window.addEventListener('load',function(){setButtonLabels();applyControlsConfig();});}

// ==================== CONTROLS EDITOR ====================
let editorActive = false;
let selectedBtn = null;
let dragOffset = { x: 0, y: 0 };
let isResizing = false;

if (isMobile) {
    document.getElementById('edit-controls-btn').addEventListener('click', openEditor);
    document.getElementById('save-controls').addEventListener('click', saveControls);
    document.getElementById('reset-controls').addEventListener('click', resetControls);
}

function openEditor() {
    editorActive = true;
    document.getElementById('controls-editor').classList.add('active');
    const area = document.getElementById('editor-area');
    area.innerHTML = '';
    
    // Wait for area to render
    setTimeout(() => {
        const areaRect = area.getBoundingClientRect();
        
        // Create editor buttons
        Object.keys(controlsConfig).forEach(key => {
            const cfg = controlsConfig[key];
            const btn = document.createElement('div');
            btn.className = 'editor-btn';
            btn.dataset.ctrl = key;
            btn.style.width = cfg.size + 'px';
            btn.style.height = cfg.size + 'px';
            btn.style.fontSize = (cfg.size * 0.35) + 'px';
            
            // Position from bottom
            let left;
            if (cfg.right !== undefined && cfg.right !== null) {
                left = areaRect.width - cfg.right - cfg.size;
            } else if (cfg.left !== undefined && cfg.left !== null) {
                left = cfg.left;
            } else {
                left = cfg.x || 30;
            }
            btn.style.left = left + 'px';
            // Position vertically
            if (cfg.top !== undefined && cfg.top !== null) {
                btn.style.top = cfg.top + 'px';
            } else if (cfg.y !== undefined && cfg.y !== null) {
                btn.style.top = (areaRect.height - cfg.y - cfg.size) + 'px';
            }
            
            // Label
            const labels = {
                joystick: 'MOVE',
                shoot: 'FIRE',
                jump: 'UP',
                reload: 'R',
                grenade: 'G',
                weapon: '1/2',
                scope: 'AIM',
                bomb: 'B'
            };
            btn.textContent = labels[key] || key;
            
            // Resize handle
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            btn.appendChild(handle);
            
            area.appendChild(btn);
            
            // Touch events for dragging
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = btn.getBoundingClientRect();
                const handleRect = handle.getBoundingClientRect();
                
                // Check if touching resize handle
                if (touch.clientX >= handleRect.left && touch.clientY >= handleRect.top) {
                    isResizing = true;
                } else {
                    isResizing = false;
                    dragOffset.x = touch.clientX - rect.left;
                    dragOffset.y = touch.clientY - rect.top;
                }
                
                // Select this button
                document.querySelectorAll('.editor-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedBtn = btn;
            });
            
            btn.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!selectedBtn || selectedBtn !== btn) return;
                
                const touch = e.touches[0];
                const areaRect = area.getBoundingClientRect();
                
                if (isResizing) {
                    // Resize
                    const rect = btn.getBoundingClientRect();
                    const newSize = Math.max(40, Math.min(300, touch.clientX - rect.left + 10));
                    btn.style.width = newSize + 'px';
                    btn.style.height = newSize + 'px';
                    btn.style.fontSize = (newSize * 0.35) + 'px';
                    
                    document.getElementById('size-indicator').style.display = 'block';
                    document.getElementById('size-value').textContent = Math.round(newSize);
                } else {
                    // Drag
                    let newX = touch.clientX - areaRect.left - dragOffset.x;
                    let newY = touch.clientY - areaRect.top - dragOffset.y;
                    
                    // Clamp to area
                    newX = Math.max(0, Math.min(areaRect.width - btn.offsetWidth, newX));
                    newY = Math.max(0, Math.min(areaRect.height - btn.offsetHeight, newY));
                    
                    btn.style.left = newX + 'px';
                    btn.style.top = newY + 'px';
                }
            });
            
            btn.addEventListener('touchend', () => {
                isResizing = false;
                document.getElementById('size-indicator').style.display = 'none';
            });
        });
    }, 100);
}

function saveControls() {
    const area = document.getElementById('editor-area');
    const areaRect = area.getBoundingClientRect();
    
    document.querySelectorAll('.editor-btn').forEach(btn => {
        const key = btn.dataset.ctrl;
        const rect = btn.getBoundingClientRect();
        const size = btn.offsetWidth;
        
        // Convert to bottom-right coordinates
        const bottomY = areaRect.height - (rect.top - areaRect.top) - size;
        const rightX = areaRect.width - (rect.left - areaRect.left) - size;
        const leftX = rect.left - areaRect.left;
        
        // Decide if right or left positioning
        if (leftX > areaRect.width / 2) {
            controlsConfig[key] = { right: Math.round(rightX), y: Math.round(bottomY), size: Math.round(size) };
        } else {
            controlsConfig[key] = { left: Math.round(leftX), y: Math.round(bottomY), size: Math.round(size) };
        }
    });
    
    try {
        localStorage.setItem('standoffControls', JSON.stringify(controlsConfig));
    } catch (e) {
        console.log('Failed to save controls');
    }
    applyControlsConfig();
    closeEditor();
}

function resetControls() {
    controlsConfig = JSON.parse(JSON.stringify(defaultControls));
    localStorage.removeItem('standoffControls');
    applyControlsConfig();
    openEditor(); // Refresh editor
}

function closeEditor() {
    editorActive = false;
    document.getElementById('controls-editor').classList.remove('active');
}

// ==================== MOBILE GAME CONTROLS ====================
let moveJoystick = { active: false, id: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
let lookTouch = { active: false, id: null, lastX: 0, lastY: 0 };
let mobileShootInterval = null;

function setupMobileControls() {
    if (!isMobile) return;
    
    const joystickMove = document.getElementById('joystick-move');
    const moveStick = document.getElementById('move-stick');
    const lookArea = document.getElementById('look-area');
    
    // Movement joystick
    // --- Improved multi-touch joystick handling ---
    joystickMove.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0]; // use changedTouches to get the initiating finger only
        const rect = joystickMove.getBoundingClientRect();
        moveJoystick.active = true;
        moveJoystick.id = touch.identifier; // remember which finger controls the stick
        moveJoystick.startX = rect.left + rect.width / 2;
        moveJoystick.startY = rect.top + rect.height / 2;
    }, { passive: false });
    
    // Listen on document so that movement continues even if the finger leaves the joystick element
    document.addEventListener('touchmove', (e) => {
        if (!moveJoystick.active) return;
        const touch = Array.from(e.touches).find(t => t.identifier === moveJoystick.id);
        if (!touch) return;
    const rect = joystickMove.getBoundingClientRect();
    const maxDist = rect.width * 0.35;
    let dx = touch.clientX - moveJoystick.startX;
    let dy = touch.clientY - moveJoystick.startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxDist) {
            dx = dx / dist * maxDist;
            dy = dy / dist * maxDist;
        }
        moveJoystick.currentX = dx / maxDist;
        moveJoystick.currentY = dy / maxDist;
        moveStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }, { passive: false });
    
    document.addEventListener('touchend', (e) => {
        if (!moveJoystick.active) return;
        // Check if the finger that ended is the joystick finger
        const ended = Array.from(e.changedTouches).some(t => t.identifier === moveJoystick.id);
        if (!ended) return;
        moveJoystick.active = false;
        moveJoystick.currentX = 0;
        moveJoystick.currentY = 0;
        moveStick.style.transform = 'translate(-50%, -50%)';
    });
    
    // Look area
    lookArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Не перехватываем второй палец, если уже крутим камерой
        if (lookTouch.active) return;
        const touch = e.changedTouches[0];
        lookTouch.active = true;
        lookTouch.id = touch.identifier;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
    }, { passive: false });
    
    // Use document-level listener so camera keeps rotating even if finger leaves the look area
    document.addEventListener('touchmove', (e) => {
        if (!lookTouch.active || !controls.isLocked) return;
        const touch = Array.from(e.touches).find(t => t.identifier === lookTouch.id);
        if (!touch) return;
        const dx = touch.clientX - lookTouch.lastX;
        const dy = touch.clientY - lookTouch.lastY;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
        
        const sens = mobileLookSensitivity();
        const maxStep = 0.06;
        const stepYaw = THREE.MathUtils.clamp(dx * sens, -maxStep, maxStep);
        const stepPitch = THREE.MathUtils.clamp(dy * sens, -maxStep, maxStep);
        controls.euler.y -= stepYaw;
        controls.euler.x -= stepPitch;
        controls.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.euler.x));
        camera.quaternion.setFromEuler(controls.euler);
    }, { passive: false });
    
    const clearLookTouch = (e) => {
        if (!lookTouch.active) return;
        const ended = Array.from(e.changedTouches || []).some(t => t.identifier === lookTouch.id);
        if (ended) {
            lookTouch.active = false;
            lookTouch.id = null;
        }
    };
    document.addEventListener('touchend', clearLookTouch);
    document.addEventListener('touchcancel', clearLookTouch);
    
    // Action buttons
    document.getElementById('btn-shoot').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!controls.isLocked) return;
        shoot();
        if (state.currentWeapon === 'rifle') {
            mobileShootInterval = setInterval(shoot, CONFIG.weapon.fireRate);
        } else if (state.currentWeapon === 'knife') {
            mobileShootInterval = setInterval(knifeAttack, CONFIG.knife.fireRate);
        }
    }, { passive: false });
    
    document.getElementById('btn-shoot').addEventListener('touchend', () => {
        if (mobileShootInterval) {
            clearInterval(mobileShootInterval);
            mobileShootInterval = null;
        }
    });
    
    document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!controls.isLocked) return;
        
        // Fly mode - go up
        if (state.cheats.enabled && state.cheats.fly) {
            state.flyUp = true;
            return;
        }
        
        if (state.isGrounded) {
            state.velocity.y = CONFIG.player.jumpForce;
            state.isGrounded = false;
            // Play jump sound
            try {
                if (state.sounds.jump) {
                    state.sounds.jump.currentTime = 0;
                    state.sounds.jump.play();
                }
            } catch (e) {}
        }
    }, { passive: false });
    
    document.getElementById('btn-jump').addEventListener('touchend', (e) => {
        e.preventDefault();
        state.flyUp = false;
    }, { passive: false });
    
    document.getElementById('btn-reload').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) reload();
    }, { passive: false });
    
    document.getElementById('btn-grenade').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) throwGrenade();
    }, { passive: false });
    
    document.getElementById('btn-crouch').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (state.cheats.enabled && state.cheats.fly) {
            state.flyDown = true;
        } else {
            state.isCrouching = true;
        }
    }, { passive: false });
    document.getElementById('btn-crouch').addEventListener('touchend', (e) => {
        e.preventDefault();
        state.flyDown = false;
        state.isCrouching = false;
    }, { passive: false });
    
    document.getElementById('btn-weapon').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) {
            if (state.currentWeapon === 'rifle') switchWeapon('sniper');
            else if (state.currentWeapon === 'sniper') switchWeapon('knife');
            else switchWeapon('rifle');
        }
    }, { passive: false });
    
    document.getElementById('btn-scope').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) toggleScope();
    }, { passive: false });
    
    document.getElementById('btn-bomb').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) plantBomb();
    }, { passive: false });
}

setupMobileControls();

function updateMobileMovement() {
    if (!moveJoystick.active) {
        state.moveForward = false;
        state.moveBackward = false;
        state.moveLeft = false;
        state.moveRight = false;
        return;
    }
    
    state.moveForward = moveJoystick.currentY < -0.3;
    state.moveBackward = moveJoystick.currentY > 0.3;
    state.moveLeft = moveJoystick.currentX < -0.3;
    state.moveRight = moveJoystick.currentX > 0.3;
}


// ==================== HUD EDITOR ====================
const defaultHudConfig = {
    kills: { top: 30, left: 30 },
    health: { bottom: 30, left: 30 },
    ammo: { bottom: 30, right: 30 },
    grenades: { bottom: 70, right: 30 },
    weaponName: { bottom: 110, right: 30 }
};
let hudConfig = JSON.parse(JSON.stringify(defaultHudConfig));
try { const s = localStorage.getItem('standoffHud'); if(s) hudConfig = JSON.parse(s); } catch(e){}

function applyHudConfig() {
    const els = {kills:document.getElementById('kills'),health:document.getElementById('health-bar'),ammo:document.getElementById('ammo'),grenades:document.getElementById('grenades-count'),weaponName:document.getElementById('weapon-name')};
    Object.keys(hudConfig).forEach(k => {
        const el = els[k]; if(!el) return;
        const c = hudConfig[k];
        el.style.position = 'fixed';
        el.style.top = c.top !== undefined ? c.top+'px' : 'auto';
        el.style.bottom = c.bottom !== undefined ? c.bottom+'px' : 'auto';
        el.style.left = c.left !== undefined ? c.left+'px' : 'auto';
        el.style.right = c.right !== undefined ? c.right+'px' : 'auto';
    });
    const ht = document.getElementById('health-text');
    if(ht && hudConfig.health) {
        ht.style.position = 'fixed';
        ht.style.bottom = ((hudConfig.health.bottom||0)+15)+'px';
        ht.style.left = hudConfig.health.left !== undefined ? hudConfig.health.left+'px' : 'auto';
    }
}

let draggedHud = null, hudOff = {x:0,y:0};
function openHudEditor() {
    const ed = document.getElementById('hud-editor'); ed.classList.add('active');
    ed.querySelectorAll('.hud-draggable').forEach(e => e.remove());
    [{k:'kills',l:'Убийства'},{k:'health',l:'Здоровье'},{k:'ammo',l:'Патроны'},{k:'grenades',l:'Гранаты'},{k:'weaponName',l:'Оружие'}].forEach(item => {
        const el = document.createElement('div'); el.className = 'hud-draggable'; el.dataset.hudKey = item.k; el.textContent = item.l;
        const c = hudConfig[item.k];
        if(c.top !== undefined) el.style.top = c.top+'px';
        if(c.bottom !== undefined) el.style.bottom = c.bottom+'px';
        if(c.left !== undefined) el.style.left = c.left+'px';
        if(c.right !== undefined) el.style.right = c.right+'px';
        el.onmousedown = (e) => { draggedHud = el; el.classList.add('dragging'); const r = el.getBoundingClientRect(); hudOff = {x:e.clientX-r.left,y:e.clientY-r.top}; };
        el.ontouchstart = (e) => { e.preventDefault(); draggedHud = el; el.classList.add('dragging'); const r = el.getBoundingClientRect(); const t = e.touches[0]; hudOff = {x:t.clientX-r.left,y:t.clientY-r.top}; };
        ed.appendChild(el);
    });
}
document.addEventListener('mousemove', (e) => {
    if(!draggedHud) return;
    e.preventDefault();
    const x = e.clientX - hudOff.x, y = e.clientY - hudOff.y, mx = window.innerWidth/2, my = window.innerHeight/2;
    draggedHud.style.left = x < mx ? x+'px' : 'auto';
    draggedHud.style.right = x >= mx ? (window.innerWidth-x-draggedHud.offsetWidth)+'px' : 'auto';
    draggedHud.style.top = y < my ? y+'px' : 'auto';
    draggedHud.style.bottom = y >= my ? (window.innerHeight-y-draggedHud.offsetHeight)+'px' : 'auto';
});
document.addEventListener('mouseup', () => { if(draggedHud) { draggedHud.classList.remove('dragging'); draggedHud = null; } });

// Touch support for mobile HUD editor
document.addEventListener('touchmove', (e) => {
    if(!draggedHud) return;
    e.preventDefault();
    const touch = e.touches[0];
    const x = touch.clientX - hudOff.x, y = touch.clientY - hudOff.y;
    const mx = window.innerWidth/2, my = window.innerHeight/2;
    draggedHud.style.left = x < mx ? x+'px' : 'auto';
    draggedHud.style.right = x >= mx ? (window.innerWidth-x-draggedHud.offsetWidth)+'px' : 'auto';
    draggedHud.style.top = y < my ? y+'px' : 'auto';
    draggedHud.style.bottom = y >= my ? (window.innerHeight-y-draggedHud.offsetHeight)+'px' : 'auto';
}, {passive: false});

document.addEventListener('touchend', () => { if(draggedHud) { draggedHud.classList.remove('dragging'); draggedHud = null; } });

function saveHudConfig() {
    document.querySelectorAll('.hud-draggable').forEach(el => {
        const k = el.dataset.hudKey, s = el.style;
        const currentCfg = hudConfig[k] || {};
        const newCfg = {};
        // Preserve existing config if style not set
        if(s.top && s.top !== 'auto') {
            newCfg.top = parseInt(s.top);
        } else if(s.bottom && s.bottom !== 'auto') {
            newCfg.bottom = parseInt(s.bottom);
        } else if(currentCfg.top !== undefined) {
            newCfg.top = currentCfg.top;
        } else if(currentCfg.bottom !== undefined) {
            newCfg.bottom = currentCfg.bottom;
        }
        if(s.left && s.left !== 'auto') {
            newCfg.left = parseInt(s.left);
        } else if(s.right && s.right !== 'auto') {
            newCfg.right = parseInt(s.right);
        } else if(currentCfg.left !== undefined) {
            newCfg.left = currentCfg.left;
        } else if(currentCfg.right !== undefined) {
            newCfg.right = currentCfg.right;
        }
        hudConfig[k] = newCfg;
    });
    localStorage.setItem('standoffHud', JSON.stringify(hudConfig));
    applyHudConfig();
    document.getElementById('hud-editor').classList.remove('active');
}
function resetHudConfig() { hudConfig = JSON.parse(JSON.stringify(defaultHudConfig)); localStorage.removeItem('standoffHud'); applyHudConfig(); openHudEditor(); }

document.getElementById('edit-hud-btn').addEventListener('click', openHudEditor);
document.getElementById('save-hud').addEventListener('click', saveHudConfig);
document.getElementById('reset-hud').addEventListener('click', resetHudConfig);
applyHudConfig();

// ==================== CROSSHAIR EDITOR ====================
const defaultCrosshair = { 
    style: 'cross', // cross, dot, circle, t
    length: 12, 
    thickness: 2, 
    gap: 20, 
    color: '#ffffff', 
    dot: true,
    dotSize: 4
};

function loadCrosshairConfig() {
    try {
        const s = localStorage.getItem('standoffCrosshair');
        if (s) return { ...defaultCrosshair, ...JSON.parse(s) };
    } catch (e) {}
    return { ...defaultCrosshair };
}
let crosshairConfig = loadCrosshairConfig();

// ==================== MULTIPLAYER (1v1 AIM) ====================
// Фиксированный адрес сокет-сервера (Railway)
const MP_URL = 'wss://standoff2-production.up.railway.app';
let mpSocket = null;
let mpSendInterval = null;
const remotePlayers = new Map();

function createRemotePlayer(color = 0x4ade80) {
    const group = new THREE.Group();
    
    const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.1, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color, emissive: 0x000000 });
    const body = new THREE.Mesh(torsoGeo, bodyMat);
    body.position.y = 1;
    body.castShadow = true;
    group.add(body);
    
    const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
    const headMat = new THREE.MeshLambertMaterial({ color: 0xffffff, emissive: 0x000000 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.8;
    head.castShadow = true;
    head.name = 'head';
    group.add(head);
    
    // Weapon
    const weaponGroup = new THREE.Group();
    const gunBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.06, 0.08, 0.4),
        materials.metal
    );
    gunBody.position.z = -0.2;
    weaponGroup.add(gunBody);
    
    const gunBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.02, 0.25, 6),
        materials.metal
    );
    gunBarrel.rotation.x = Math.PI / 2;
    gunBarrel.position.z = -0.5;
    weaponGroup.add(gunBarrel);
    
    const muzzleFlash = new THREE.PointLight(0xffaa00, 0, 3);
    muzzleFlash.position.z = -0.6;
    weaponGroup.add(muzzleFlash);
    weaponGroup.position.set(0.3, 1.1, 0);
    group.add(weaponGroup);
    
    // Health bar
    const hbBgGeo = new THREE.PlaneGeometry(0.8, 0.08);
    const hbBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide, depthTest: true, depthWrite: true });
    const healthBarBg = new THREE.Mesh(hbBgGeo, hbBgMat);
    healthBarBg.position.y = 2.3;
    healthBarBg.renderOrder = 5;
    group.add(healthBarBg);
    
    const hbFillGeo = new THREE.PlaneGeometry(0.78, 0.06);
    const hbFillMat = new THREE.MeshBasicMaterial({ color: 0x4ade80, side: THREE.DoubleSide, depthTest: true, depthWrite: true });
    const healthBarFill = new THREE.Mesh(hbFillGeo, hbFillMat);
    healthBarFill.position.y = 2.3;
    healthBarFill.position.z = 0.01;
    healthBarFill.renderOrder = 6;
    group.add(healthBarFill);
    
    group.position.y = 0;
    scene.add(group);
    
    // Create gun sound for this remote player
    const gunSound = new Audio('sounds/kalash.mp3');
    gunSound.volume = 0.5;
    
    return {
        group,
        body,
        head,
        healthBarBg,
        healthBarFill,
        muzzleFlash,
        target: { pos: new THREE.Vector3(), rotY: 0 },
        health: CONFIG.player.health,
        maxHealth: CONFIG.player.health,
        isAlive: true,
        gunSound: gunSound,
        gunSoundTimer: null
    };
}

function getRemotePlayer(id) {
    let p = remotePlayers.get(id);
    if (!p) {
        p = createRemotePlayer();
        remotePlayers.set(id, p);
    }
    return p;
}

function removeRemotePlayer(id) {
    const p = remotePlayers.get(id);
    if (p) {
        scene.remove(p.group);
        remotePlayers.delete(id);
    }
}

function resetRemotePlayers() {
    Array.from(remotePlayers.keys()).forEach(id => removeRemotePlayer(id));
}

function applyRemoteDamage(id, damage, isHeadshot = false) {
    const p = remotePlayers.get(id);
    if (!p || !p.isAlive) return;
    p.health = Math.max(0, p.health - damage);
    const healthPercent = p.health / p.maxHealth;
    p.healthBarFill.scale.x = Math.max(0.001, healthPercent);
    p.healthBarFill.position.x = (healthPercent - 1) * 0.39;
    if (p.health <= 0) {
        p.isAlive = false;
        p.group.visible = false;
        state.kills++;
        state.mpKills++;
        updateHUD();
        updateMpScore();
    }
}

function handleHitEvent({ shooterId, targetId, damage }) {
    if (!state.isMultiplayer) return;
    const dmg = Number(damage) || 0;
    if (mpSocket && targetId === mpSocket.id) {
        applyPlayerDamage(dmg);
    } else {
        applyRemoteDamage(targetId, dmg);
    }
}

function handleRemoteRespawn({ id, x, y, z }) {
    const p = getRemotePlayer(id);
    p.health = p.maxHealth;
    p.isAlive = true;
    p.group.visible = true;
    p.healthBarFill.scale.x = 1;
    p.healthBarFill.position.x = 0;
    const yPos = Math.max(0, (typeof y === 'number' ? y - CONFIG.player.height : 0));
    p.group.position.set(x, yPos, z);
    p.target.pos.set(x, yPos, z);
    p.target.rotY = 0;
}

function handleRemoteState(data) {
    if (!state.isMultiplayer) return;
    const { id, x, y, z, rotY, health } = data;
    if (mpSocket && id === mpSocket.id) return;
    const p = getRemotePlayer(id);
    const yPos = Math.max(0, (typeof y === 'number' ? y - CONFIG.player.height : 0));
    p.target.pos.set(x, yPos, z);
    p.target.rotY = rotY || 0;
    if (typeof health === 'number') {
        p.health = Math.max(0, Math.min(p.maxHealth, health));
        const hp = p.health / p.maxHealth;
        p.healthBarFill.scale.x = hp;
        p.healthBarFill.position.x = (1 - hp) * -0.39;
        p.isAlive = p.health > 0;
        p.group.visible = p.isAlive;
    }
}

function handleRemoteGrenade({ id, x, y, z, vx, vy, vz }) {
    if (mpSocket && id === mpSocket.id) return;
    spawnGrenade(x, y, z, vx, vy, vz, id);
}

function handleRemoteShoot({ id }) {
    if (!state.isMultiplayer) return;
    if (mpSocket && id === mpSocket.id) return;
    const p = remotePlayers.get(id);
    if (!p) return;
    p.muzzleFlash.intensity = 2;
    setTimeout(() => { p.muzzleFlash.intensity = 0; }, 60);
    
    // Play gunshot sound (volume based on distance)
    try {
        const maxDistance = 50;
        const distance = p.group.position.distanceTo(camera.position);
        if (distance <= maxDistance && p.gunSound) {
            const volume = Math.max(0.1, 1 - (distance / maxDistance)) * 0.6;
            p.gunSound.volume = volume;
            
            if (p.gunSound.paused) {
                p.gunSound.currentTime = 0;
                p.gunSound.play().catch(() => {});
            }
            
            if (p.gunSoundTimer) clearTimeout(p.gunSoundTimer);
            p.gunSoundTimer = setTimeout(() => {
                try {
                    p.gunSound.pause();
                    p.gunSound.currentTime = 0;
                } catch (e) {}
            }, 500);
        }
    } catch (e) {}
}

function updateMpStatus(text) {
    const status = document.getElementById('mp-status');
    if (status) status.textContent = text;
}

function connectMultiplayer() {
    if (mpSocket) return;
    if (!window.io) { console.warn('Socket.IO client not loaded'); return; }
    mpSocket = io(MP_URL, { transports: ['websocket'], path: '/socket.io' });

    mpSocket.on('connect', () => {
        if (mpSendInterval) clearInterval(mpSendInterval);
        mpSendInterval = setInterval(sendPlayerState, 50); // 20 tps
        if (state.isMultiplayer) {
            joinCurrentMpMode();
        }
    });

    mpSocket.on('connect_error', (err) => {
        console.warn('MP connect_error', err.message);
        updateMpStatus('Ошибка подключения');
    });
    mpSocket.on('error', (err) => {
        console.warn('MP error', err);
    });

    mpSocket.on('disconnect', () => {
        if (mpSendInterval) { clearInterval(mpSendInterval); mpSendInterval = null; }
        resetRemotePlayers();
        state.isSearchingMatch = false;
        updateMpStatus('Отключено');
        mpSocket = null;
    });

    mpSocket.on('waiting', () => {
        if (!state.isMultiplayer) return;
        state.isSearchingMatch = true;
        updateMpStatus('Поиск соперника...');
    });

    mpSocket.on('matchFound', ({ room, spawnIndex = 0, opponentId }) => {
        if (!state.isMultiplayer) return;
        state.mpRoom = room;
        state.mpSpawnIndex = spawnIndex;
        state.mpOpponentId = opponentId || null;
        state.isSearchingMatch = false;
        const spawn = getAimSpawn(spawnIndex);
        resetGame({ skipEnemies: true, position: spawn });
        updateMpStatus('Играем 1v1');
    });

    mpSocket.on('ffaJoined', ({ room, spawnIndex = 0 }) => {
        if (state.mpMode !== 'ffa') return;
        state.mpRoom = room;
        state.mpSpawnIndex = spawnIndex;
        state.isSearchingMatch = false;
        resetGame({ skipEnemies: true, position: getFfaSpawn(spawnIndex) });
        updateMpStatus('FFA: бой начался');
    });

    mpSocket.on('teamJoined', ({ room, spawnIndex = 0, team = null }) => {
        if (state.mpMode !== 'team') return;
        state.mpRoom = room;
        state.mpSpawnIndex = spawnIndex;
        state.mpTeam = team;
        state.isSearchingMatch = false;
        resetGame({ skipEnemies: true, position: getTeamSpawn(spawnIndex) });
        updateMpStatus(`Команды: ${team || 'бой'}`);
    });

    mpSocket.on('sandboxJoined', ({ room, objects = [] }) => {
        if (state.mpMode !== 'sandbox') return;
        state.mpRoom = room;
        state.isSearchingMatch = false;
        state.sandbox.active = true;
        updateMpStatus('Песочница: на сервере');
        clearSandboxObjectsLocal();
        objects.forEach(obj => addSandboxObject(obj, false));
        const panel = document.getElementById('sandbox-tools');
        if (panel) panel.style.display = 'block';
    });

    mpSocket.on('sandboxPlace', (data) => {
        if (state.mpMode !== 'sandbox') return;
        addSandboxObject(data, false);
    });

    mpSocket.on('sandboxClear', () => {
        if (state.mpMode !== 'sandbox') return;
        clearSandboxObjectsLocal();
    });

mpSocket.on('sandboxRemove', ({ id }) => {
    if (state.mpMode !== 'sandbox') return;
    removeSandboxObject(id, false);
});

    mpSocket.on('state', handleRemoteState);
    mpSocket.on('shoot', handleRemoteShoot);
    mpSocket.on('hit', handleHitEvent);
    mpSocket.on('respawn', handleRemoteRespawn);
    mpSocket.on('grenade', handleRemoteGrenade);
    mpSocket.on('adminMsg', (data) => {
        if (data.type === 'party') {
            // Sync party mode from remote
            if (data.active !== state.partyMode) {
                togglePartyMode('Федя');
            }
        } else if (data.msg) {
            showAdminBanner(data.msg);
        }
    });
    mpSocket.on('leave', ({ id }) => removeRemotePlayer(id));
}

function disconnectMultiplayer() {
    if (mpSendInterval) { clearInterval(mpSendInterval); mpSendInterval = null; }
    if (mpSocket) { mpSocket.disconnect(); mpSocket = null; }
    resetRemotePlayers();
    updateMpStatus('');
}

function joinMatchmaking() {
    if (!mpSocket || !mpSocket.connected) return;
    state.isSearchingMatch = true;
    updateMpStatus('Поиск соперника...');
    mpSocket.emit('join1v1');
}

function sendPlayerState() {
    if (!mpSocket || !mpSocket.connected || !state.isMultiplayer || !state.isPlaying) return;
    mpSocket.emit('state', {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        rotY: camera.rotation.y,
        health: state.health
    });
}

function updateRemotePlayers(delta) {
    if (!state.isMultiplayer) return;
    remotePlayers.forEach((p) => {
        p.group.position.lerp(p.target.pos, Math.min(1, delta * 10));
        p.group.rotation.y = THREE.MathUtils.lerp(p.group.rotation.y, p.target.rotY, Math.min(1, delta * 10));
        if (p.healthBarBg && p.healthBarFill) {
            p.healthBarBg.lookAt(camera.position);
            p.healthBarFill.lookAt(camera.position);
        }
        updateESPForActor(p);
    });
}

function applyCrosshairConfig() {
    const top = document.querySelector('.cross-top');
    const bottom = document.querySelector('.cross-bottom');
    const left = document.querySelector('.cross-left');
    const right = document.querySelector('.cross-right');
    const dot = document.getElementById('crosshair-dot');
    
    const style = crosshairConfig.style;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    const gap = crosshairConfig.gap;
    const color = crosshairConfig.color;
    const dotSize = crosshairConfig.dotSize;
    
    const showLines = style !== 'dot';
    const showTop = style === 'cross' || style === 'circle';
    
    // Top line (vertical)
    if (top) {
        top.style.width = thick + 'px';
        top.style.height = len + 'px';
        top.style.left = (-thick / 2) + 'px';
        top.style.top = (-gap - len) + 'px';
        top.style.bottom = 'auto';
        top.style.right = 'auto';
        top.style.background = color;
        top.style.display = (showLines && showTop) ? 'block' : 'none';
    }
    
    // Bottom line (vertical)
    if (bottom) {
        bottom.style.width = thick + 'px';
        bottom.style.height = len + 'px';
        bottom.style.left = (-thick / 2) + 'px';
        bottom.style.top = gap + 'px';
        bottom.style.bottom = 'auto';
        bottom.style.right = 'auto';
        bottom.style.background = color;
        bottom.style.display = showLines ? 'block' : 'none';
    }
    
    // Left line (horizontal)
    if (left) {
        left.style.width = len + 'px';
        left.style.height = thick + 'px';
        left.style.top = (-thick / 2) + 'px';
        left.style.left = (-gap - len) + 'px';
        left.style.bottom = 'auto';
        left.style.right = 'auto';
        left.style.background = color;
        left.style.display = showLines ? 'block' : 'none';
    }
    
    // Right line (horizontal)
    if (right) {
        right.style.width = len + 'px';
        right.style.height = thick + 'px';
        right.style.top = (-thick / 2) + 'px';
        right.style.left = gap + 'px';
        right.style.bottom = 'auto';
        right.style.right = 'auto';
        right.style.background = color;
        right.style.display = showLines ? 'block' : 'none';
    }
    
    // Dot
    if (dot) {
        dot.style.background = color;
        dot.style.display = crosshairConfig.dot ? 'block' : 'none';
        dot.style.width = dotSize + 'px';
        dot.style.height = dotSize + 'px';
        dot.style.top = (-dotSize / 2) + 'px';
        dot.style.left = (-dotSize / 2) + 'px';
    }
    
    // Update preview
    updateCrosshairPreview();
}

function updateCrosshairPreview() {
    const previewTop = document.querySelector('.preview-top');
    const previewBottom = document.querySelector('.preview-bottom');
    const previewLeft = document.querySelector('.preview-left');
    const previewRight = document.querySelector('.preview-right');
    const previewDot = document.querySelector('.preview-dot');
    
    if (!previewTop) return;
    
    const style = crosshairConfig.style;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    const gap = crosshairConfig.gap;
    const color = crosshairConfig.color;
    const dotSize = crosshairConfig.dotSize;
    
    const showLines = style !== 'dot';
    const showTop = style === 'cross' || style === 'circle';
    
    // Vertical lines (top/bottom)
    previewTop.style.width = thick + 'px';
    previewTop.style.height = len + 'px';
    previewTop.style.left = (-thick/2) + 'px';
    previewTop.style.top = (-gap - len) + 'px';
    previewTop.style.background = color;
    previewTop.style.display = (showLines && showTop) ? 'block' : 'none';
    
    previewBottom.style.width = thick + 'px';
    previewBottom.style.height = len + 'px';
    previewBottom.style.left = (-thick/2) + 'px';
    previewBottom.style.top = gap + 'px';
    previewBottom.style.background = color;
    previewBottom.style.display = showLines ? 'block' : 'none';
    
    // Horizontal lines (left/right)
    previewLeft.style.height = thick + 'px';
    previewLeft.style.width = len + 'px';
    previewLeft.style.top = (-thick/2) + 'px';
    previewLeft.style.left = (-gap - len) + 'px';
    previewLeft.style.background = color;
    previewLeft.style.display = showLines ? 'block' : 'none';
    
    previewRight.style.height = thick + 'px';
    previewRight.style.width = len + 'px';
    previewRight.style.top = (-thick/2) + 'px';
    previewRight.style.left = gap + 'px';
    previewRight.style.background = color;
    previewRight.style.display = showLines ? 'block' : 'none';
    
    // Dot
    previewDot.style.background = color;
    previewDot.style.display = crosshairConfig.dot ? 'block' : 'none';
    previewDot.style.width = dotSize + 'px';
    previewDot.style.height = dotSize + 'px';
    previewDot.style.top = (-dotSize/2) + 'px';
    previewDot.style.left = (-dotSize/2) + 'px';
    
    // Update value labels
    const lenVal = document.getElementById('cross-length-val');
    const thickVal = document.getElementById('cross-thickness-val');
    const gapVal = document.getElementById('cross-gap-val');
    const dotSizeVal = document.getElementById('cross-dot-size-val');
    if (lenVal) lenVal.textContent = len + 'px';
    if (thickVal) thickVal.textContent = thick + 'px';
    if (gapVal) gapVal.textContent = gap + 'px';
    if (dotSizeVal) dotSizeVal.textContent = dotSize + 'px';
    
    // Update toggle state
    const dotToggle = document.getElementById('cross-dot-toggle');
    if (dotToggle) {
        dotToggle.classList.toggle('active', crosshairConfig.dot);
    }
    
    // Update style presets
    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.style === crosshairConfig.style);
    });
    
    // Show/hide lines controls based on style
    const linesControls = document.getElementById('lines-controls');
    if (linesControls) {
        linesControls.style.opacity = style === 'dot' ? '0.4' : '1';
        linesControls.style.pointerEvents = style === 'dot' ? 'none' : 'auto';
    }
}

applyCrosshairConfig();

// Open editor
function openCrosshairEditor() {
    document.getElementById('crosshair-editor').classList.add('active');
    document.getElementById('cross-length').value = crosshairConfig.length;
    document.getElementById('cross-thickness').value = crosshairConfig.thickness;
    document.getElementById('cross-gap').value = crosshairConfig.gap;
    document.getElementById('cross-color').value = crosshairConfig.color;
    document.getElementById('cross-dot-size').value = crosshairConfig.dotSize;
    updateCrosshairPreview();
}

function closeCrosshairEditor() {
    document.getElementById('crosshair-editor').classList.remove('active');
}

function saveCrosshair() {
    localStorage.setItem('standoffCrosshair', JSON.stringify(crosshairConfig));
    applyCrosshairConfig();
    closeCrosshairEditor();
}

function resetCrosshair() {
    crosshairConfig = { ...defaultCrosshair };
    localStorage.removeItem('standoffCrosshair');
    applyCrosshairConfig();
    openCrosshairEditor();
}

// Style presets
document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        crosshairConfig.style = btn.dataset.style;
        // Auto-enable dot for dot style
        if (btn.dataset.style === 'dot') {
            crosshairConfig.dot = true;
        }
        applyCrosshairConfig();
    });
});

// Toggle switch for dot
document.getElementById('cross-dot-toggle').addEventListener('click', function() {
    crosshairConfig.dot = !crosshairConfig.dot;
    this.classList.toggle('active', crosshairConfig.dot);
    applyCrosshairConfig();
});

// Live preview for sliders
['cross-length', 'cross-thickness', 'cross-gap', 'cross-dot-size'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => {
        const key = id.replace('cross-', '').replace('-', '');
        if (id === 'cross-dot-size') {
            crosshairConfig.dotSize = parseInt(el.value);
        } else {
            crosshairConfig[id.split('-')[1]] = parseInt(el.value);
        }
        applyCrosshairConfig();
    });
});

// Color picker
document.getElementById('cross-color').addEventListener('input', (e) => {
    crosshairConfig.color = e.target.value;
    applyCrosshairConfig();
});

document.getElementById('edit-crosshair-btn').addEventListener('click', openCrosshairEditor);
document.getElementById('save-crosshair').addEventListener('click', saveCrosshair);
document.getElementById('reset-crosshair').addEventListener('click', resetCrosshair);

document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && document.getElementById('crosshair-editor').classList.contains('active')) {
        closeCrosshairEditor();
    }
});

animate();
    </script>
</body>
</html>
