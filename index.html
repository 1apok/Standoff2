<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Standoff FPS</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #1a1a2e; 
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        #game-container { width: 100vw; height: 100vh; }
        
        /* Menu */
        #menu {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 1000;
        }
        #menu h1 {
            font-size: 72px; color: #e94560; text-transform: uppercase;
            letter-spacing: 8px; margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.5);
        }
        #menu p { color: #888; margin-bottom: 40px; font-size: 18px; }
        .primary-btn {
            padding: 18px 56px; font-size: 22px; font-weight: bold;
            background: linear-gradient(135deg, #e94560, #c23a51);
            color: white; border: none; border-radius: 10px; cursor: pointer;
            text-transform: uppercase; letter-spacing: 3px;
            transition: all 0.3s ease; box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }
        .primary-btn:hover {
            transform: translateY(-3px); box-shadow: 0 15px 40px rgba(233, 69, 96, 0.6);
        }
        #mp-btn { margin-top: 18px; }
        #debug-btn { margin-top: 12px; font-size: 16px; padding: 12px 32px; }

        #debug-panel {
            display: none;
            margin-top: 16px;
            padding: 14px;
            background: rgba(0,0,0,0.4);
            border: 1px solid #444;
            border-radius: 8px;
            color: #ddd;
            width: 320px;
            max-width: 90vw;
            font-family: monospace;
            font-size: 12px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        #debug-panel.active { display: block; }
        #controls-info {
            margin-top: 40px; color: #666; text-align: center; line-height: 1.8;
        }
        
        /* HUD */
        #hud {
            position: fixed; bottom: 0; left: 0; width: 100%; padding: 20px;
            display: none; pointer-events: none;
        }
        #health-bar {
            position: absolute; bottom: 30px; left: 30px;
            width: 200px; height: 8px; background: rgba(0,0,0,0.6);
            border-radius: 4px; overflow: hidden;
        }
        #health-fill {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #e94560, #ff6b6b);
            transition: width 0.3s ease;
        }
        #health-text {
            position: absolute; bottom: 45px; left: 30px;
            color: white; font-size: 14px; font-weight: bold;
        }
        #ammo {
            position: absolute; bottom: 30px; right: 30px;
            color: white; font-size: 32px; font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #ammo span { font-size: 18px; color: #888; }
        #kills {
            position: absolute; bottom: calc(100vh - 50px); left: 30px;
            color: white; font-size: 18px;
        }
        #grenades-count {
            position: absolute; bottom: 70px; right: 30px;
            color: white; font-size: 20px; font-weight: bold;
        }
        
        /* Crosshair */
        #crosshair {
            position: fixed; top: 50%; left: 50%;
            pointer-events: none; display: none;
        }
        .cross-line {
            position: absolute; background: rgba(255,255,255,0.9);
        }
        .cross-h { }
        .cross-v { }
        .cross-top { }
        .cross-bottom { }
        .cross-left { }
        .cross-right { }
        #crosshair-dot {
            background: rgba(255,255,255,0.8);
            border-radius: 50%; position: absolute;
        }
        
        /* Hit marker */
        #hitmarker {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0;
            transition: opacity 0.1s ease;
        }
        .hit-line {
            position: absolute; width: 15px; height: 2px;
            background: #e94560;
        }
        .hit-1 { transform: rotate(45deg) translate(8px, 0); }
        .hit-2 { transform: rotate(-45deg) translate(8px, 0); }
        .hit-3 { transform: rotate(135deg) translate(8px, 0); }
        .hit-4 { transform: rotate(-135deg) translate(8px, 0); }
        
        /* Damage overlay */
        #damage-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(233,69,96,0.4) 100%);
            transition: opacity 0.2s ease;
        }
        
        /* Sniper scope */
        #scope-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none; z-index: 50;
        }
        #scope-overlay.active { display: block; }
        .scope-black {
            position: absolute; background: #000;
        }
        .scope-top { top: 0; left: 0; right: 0; height: calc(50% - 150px); }
        .scope-bottom { bottom: 0; left: 0; right: 0; height: calc(50% - 150px); }
        .scope-left { top: 0; bottom: 0; left: 0; width: calc(50% - 150px); }
        .scope-right { top: 0; bottom: 0; right: 0; width: calc(50% - 150px); }
        #scope-circle {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 300px; height: 300px;
            border: 3px solid #000; border-radius: 50%;
            box-shadow: 0 0 0 2000px rgba(0,0,0,0.95);
        }
        #scope-crosshair {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        .scope-line {
            position: absolute; background: #000;
        }
        .scope-h { width: 140px; height: 1px; top: 0; }
        .scope-v { width: 1px; height: 140px; left: 0; }
        .scope-h.left { right: 5px; }
        .scope-h.right { left: 5px; }
        .scope-v.top { bottom: 5px; }
        .scope-v.bottom { top: 5px; }
        
        /* Bomb UI */
        #bomb-status {
            position: fixed; top: 80px; left: 50%;
            transform: translateX(-50%);
            color: white; font-size: 20px; font-weight: bold;
            text-align: center; display: none;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #bomb-status.danger { color: #e94560; }
        #bomb-status.success { color: #4ade80; }
        #weapon-name {
            position: absolute; bottom: 110px; right: 30px;
            color: #888; font-size: 14px;
        }
        
        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
            z-index: 100;
        }
        .mobile #mobile-controls.active { display: block; }
        .mobile #hud { pointer-events: none; }
        .mobile #health-bar { bottom: 10px; left: 10px; width: 100px; }
        .mobile #health-text { bottom: 22px; left: 10px; font-size: 11px; }
        .mobile #ammo { bottom: 10px; right: 10px; font-size: 18px; }
        .mobile #weapon-name { bottom: 32px; right: 10px; font-size: 10px; }
        .mobile #grenades-count { bottom: 50px; right: 10px; font-size: 12px; }
        .mobile #kills { position: fixed; top: 50px; left: 10px; font-size: 14px; }
        
        .joystick-container {
            position: absolute;
            pointer-events: auto;
            touch-action: none;
        }
        .joystick-base {
            width: 100%; height: 100%;
            background: rgba(255,255,255,0.15);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .joystick-stick {
            position: absolute;
            width: 40%; height: 40%;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .mobile-btn {
            position: absolute;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex; align-items: center; justify-content: center;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .mobile-btn:active { background: rgba(255,255,255,0.5); }
        #btn-shoot { background: rgba(233, 69, 96, 0.4); border-color: rgba(233, 69, 96, 0.6); }
        
        #look-area {
            position: absolute;
            top: 0; left: 30%; right: 0; bottom: 40%;
            pointer-events: auto;
            touch-action: none;
        }
        
        .mobile #menu h1 { font-size: 32px; letter-spacing: 3px; }
        .mobile #menu p { font-size: 12px; margin-bottom: 20px; }
        .mobile #play-btn { padding: 12px 30px; font-size: 16px; }
        .mobile #controls-info { display: none; }
        
        /* Edit Controls Button */
        #edit-controls-btn {
            display: none;
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 15px;
        }
        .mobile #edit-controls-btn { display: block; }
        
        #edit-hud-btn {
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 10px;
        }
        #edit-hud-btn:hover { background: rgba(255,255,255,0.2); }
        .mobile #edit-hud-btn { display: block; }
        
        #hud-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 2000;
        }
        #hud-editor.active { display: block; }
        #hud-editor-header {
            position: absolute; top: 0; left: 0; right: 0;
            padding: 15px; background: #1a1a2e;
            display: flex; justify-content: space-between; align-items: center;
        }
        #hud-editor-header h2 { color: #e94560; font-size: 18px; margin: 0; }
        #hud-editor-buttons button {
            padding: 8px 16px; margin-left: 10px;
            border: none; border-radius: 4px; font-size: 12px; cursor: pointer;
        }
        #save-hud { background: #4ade80; color: #000; }
        #reset-hud { background: #666; color: #fff; }
        .hud-draggable {
            position: absolute;
            cursor: move;
            border: 2px dashed rgba(255,255,255,0.5);
            padding: 10px 15px;
            background: rgba(0,0,0,0.7);
            color: white;
            user-select: none;
            font-size: 14px;
        }
        .hud-draggable:hover { border-color: #e94560; }
        .hud-draggable.dragging { border-color: #4ade80; background: rgba(74,222,128,0.2); }
        
        /* Controls Editor */
        #controls-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 2000;
            flex-direction: column;
        }
        #controls-editor.active { display: flex; }
        #editor-header {
            padding: 15px; background: #1a1a2e;
            display: flex; justify-content: space-between; align-items: center;
        }
        #editor-header h2 { color: #e94560; font-size: 18px; }
        #editor-buttons button {
            padding: 8px 16px; margin-left: 10px;
            border: none; border-radius: 4px; font-size: 12px; cursor: pointer;
        }
        #save-controls { background: #4ade80; color: #000; }
        #reset-controls { background: #666; color: #fff; }
        #editor-area {
            flex: 1; position: relative;
            background: linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .editor-btn {
            position: absolute;
            background: rgba(255,255,255,0.2);
            border: 2px dashed rgba(255,255,255,0.5);
            border-radius: 50%;
            color: white;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
            touch-action: none;
        }
        .editor-btn.selected { border-color: #e94560; border-style: solid; }
        .resize-handle {
            position: absolute; bottom: -8px; right: -8px;
            width: 20px; height: 20px;
            background: #e94560; border-radius: 50%;
            display: none;
        }
        .editor-btn.selected .resize-handle { display: block; }
        #size-indicator {
            position: fixed; bottom: 80px; left: 50%;
            transform: translateX(-50%);
            color: white; font-size: 14px;
            background: rgba(0,0,0,0.7); padding: 8px 16px;
            border-radius: 4px; display: none;
        }
        /* Crosshair Editor */
        #crosshair-editor {
            display: none;
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, rgba(26,26,46,0.98) 0%, rgba(22,33,62,0.98) 100%);
            z-index: 2000;
            flex-direction: column;
            overflow-y: auto;
        }
        #crosshair-editor.active { display: flex; }
        #crosshair-editor-header {
            padding: 20px; background: linear-gradient(90deg, #1a1a2e, #16213e);
            display: flex; justify-content: space-between; align-items: center;
            border-bottom: 2px solid #e94560;
        }
        #crosshair-editor-header h2 { 
            color: #e94560; font-size: 20px; margin: 0; 
            text-transform: uppercase; letter-spacing: 2px;
        }
        #crosshair-editor-buttons button {
            padding: 10px 20px; margin-left: 10px;
            border: none; border-radius: 6px; font-size: 13px; cursor: pointer;
            font-weight: bold; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        #save-crosshair { background: linear-gradient(135deg, #4ade80, #22c55e); color: #000; }
        #save-crosshair:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(74,222,128,0.4); }
        #reset-crosshair { background: #444; color: #fff; }
        #reset-crosshair:hover { background: #555; }
        #crosshair-editor-content {
            display: flex; flex-direction: row; flex: 1; padding: 20px; gap: 20px;
        }
        @media (max-width: 768px) {
            #crosshair-editor-content { flex-direction: column; }
        }
        #crosshair-preview-section {
            flex: 1; display: flex; flex-direction: column; align-items: center;
        }
        #crosshair-preview {
            display: flex; align-items: center; justify-content: center;
            width: 100%; max-width: 300px; height: 200px;
            background: radial-gradient(circle, #2a2a4a 0%, #1a1a2e 100%);
            border-radius: 12px; border: 2px solid #333;
            position: relative; box-shadow: inset 0 0 30px rgba(0,0,0,0.5);
        }
        #preview-cross { position: relative; }
        .preview-line { position: absolute; background: white; transition: all 0.1s ease; }
        .preview-dot {
            width: 4px; height: 4px; background: white;
            border-radius: 50%; position: absolute;
            top: -2px; left: -2px; transition: all 0.1s ease;
        }
        #crosshair-editor-controls {
            flex: 1; color: white; display: flex; flex-direction: column; gap: 12px;
            max-width: 400px;
        }
        .control-group {
            background: rgba(255,255,255,0.05); border-radius: 10px; padding: 15px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .control-group-title {
            font-size: 12px; color: #e94560; text-transform: uppercase;
            letter-spacing: 1px; margin-bottom: 12px; font-weight: bold;
        }
        .control-row {
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 10px;
        }
        .control-row:last-child { margin-bottom: 0; }
        .control-row label { font-size: 13px; color: #aaa; }
        .control-row .value { 
            font-size: 12px; color: #e94560; min-width: 40px; text-align: right;
            font-weight: bold;
        }
        .control-row input[type=range] {
            flex: 1; margin: 0 12px; height: 6px; -webkit-appearance: none;
            background: #333; border-radius: 3px; cursor: pointer;
        }
        .control-row input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 16px; height: 16px;
            background: #e94560; border-radius: 50%; cursor: pointer;
            box-shadow: 0 0 8px rgba(233,69,96,0.5);
        }
        .control-row input[type=color] {
            width: 50px; height: 32px; border: 2px solid #444;
            border-radius: 6px; cursor: pointer; background: transparent;
        }
        .control-row input[type=color]::-webkit-color-swatch-wrapper { padding: 2px; }
        .control-row input[type=color]::-webkit-color-swatch { border-radius: 4px; border: none; }
        .style-presets {
            display: flex; gap: 10px; flex-wrap: wrap;
        }
        .preset-btn {
            padding: 8px 14px; background: rgba(255,255,255,0.1);
            border: 1px solid #444; border-radius: 6px; color: #aaa;
            font-size: 12px; cursor: pointer; transition: all 0.2s ease;
        }
        .preset-btn:hover { background: rgba(233,69,96,0.2); border-color: #e94560; color: #fff; }
        .preset-btn.active { background: #e94560; border-color: #e94560; color: #fff; }
        .toggle-switch {
            position: relative; width: 50px; height: 26px;
            background: #333; border-radius: 13px; cursor: pointer;
            transition: background 0.2s ease;
        }
        .toggle-switch.active { background: #e94560; }
        .toggle-switch::after {
            content: ''; position: absolute; width: 22px; height: 22px;
            background: #fff; border-radius: 50%; top: 2px; left: 2px;
            transition: transform 0.2s ease;
        }
        .toggle-switch.active::after { transform: translateX(24px); }
        #edit-crosshair-btn {
            padding: 10px 20px; font-size: 14px;
            background: rgba(255,255,255,0.1);
            color: #888; border: 1px solid #444;
            border-radius: 6px; cursor: pointer;
            margin-top: 10px;
        }
        #edit-crosshair-btn:hover { background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="game-container"></div>
    
    <!-- Menu -->
    <div id="menu">
        <h1>Standoff</h1>
        <p>Браузерный шутер</p>
        <button id="play-btn" class="primary-btn">Играть</button>
        <button id="mp-btn" class="primary-btn">Играть мультиплеер</button>
        <button id="debug-btn" class="primary-btn">Debug</button>
        <button id="edit-controls-btn">Настроить управление</button>
        <button id="edit-hud-btn">Настроить HUD</button>
        <button id="edit-crosshair-btn">Настроить прицел</button>
        <div id="debug-panel">Debug info...</div>
        <div id="controls-info">
            <p>WASD - Движение | ПРОБЕЛ - Прыжок | ЛКМ - Стрельба | ПКМ - Прицел | R - Перезарядка | G - Граната</p>
            <p>1/2 - Смена оружия | B - Установить бомбу</p>
        </div>
    </div>
    
    <!-- Controls Editor -->
    <div id="controls-editor">
        <div id="editor-header">
            <h2>Настройка управления</h2>
            <div id="editor-buttons">
                <button id="reset-controls">Сброс</button>
                <button id="save-controls">Сохранить</button>
            </div>
        </div>
        <div id="editor-area"></div>
        <div id="size-indicator">Размер: <span id="size-value">50</span>px</div>
    </div>
    
    <!-- HUD Editor -->
    <!-- Crosshair Editor -->
    <div id="crosshair-editor">
        <div id="crosshair-editor-header">
            <h2>Настройка прицела</h2>
            <div id="crosshair-editor-buttons">
                <button id="reset-crosshair">Сброс</button>
                <button id="save-crosshair">Сохранить</button>
            </div>
        </div>
        <div id="crosshair-editor-content">
            <div id="crosshair-preview-section">
                <div id="crosshair-preview">
                    <div id="preview-cross">
                        <div class="preview-line preview-top"></div>
                        <div class="preview-line preview-bottom"></div>
                        <div class="preview-line preview-left"></div>
                        <div class="preview-line preview-right"></div>
                        <div class="preview-dot"></div>
                    </div>
                </div>
            </div>
            <div id="crosshair-editor-controls">
                <div class="control-group">
                    <div class="control-group-title">Стиль</div>
                    <div class="style-presets">
                        <button class="preset-btn" data-style="cross">Крест</button>
                        <button class="preset-btn" data-style="dot">Точка</button>
                        <button class="preset-btn" data-style="circle">Круг</button>
                        <button class="preset-btn" data-style="t">T-образный</button>
                    </div>
                </div>
                <div class="control-group" id="lines-controls">
                    <div class="control-group-title">Линии</div>
                    <div class="control-row">
                        <label>Длина</label>
                        <input id="cross-length" type="range" min="4" max="40">
                        <span class="value" id="cross-length-val">12px</span>
                    </div>
                    <div class="control-row">
                        <label>Толщина</label>
                        <input id="cross-thickness" type="range" min="1" max="8">
                        <span class="value" id="cross-thickness-val">2px</span>
                    </div>
                    <div class="control-row">
                        <label>Отступ</label>
                        <input id="cross-gap" type="range" min="0" max="60">
                        <span class="value" id="cross-gap-val">20px</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-group-title">Точка</div>
                    <div class="control-row">
                        <label>Показать точку</label>
                        <div id="cross-dot-toggle" class="toggle-switch active"></div>
                    </div>
                    <div class="control-row">
                        <label>Размер точки</label>
                        <input id="cross-dot-size" type="range" min="2" max="20">
                        <span class="value" id="cross-dot-size-val">4px</span>
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-group-title">Цвет</div>
                    <div class="control-row">
                        <label>Цвет прицела</label>
                        <input id="cross-color" type="color" value="#ffffff">
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="hud-editor">
        <div id="hud-editor-header">
            <h2>Настройка HUD</h2>
            <div id="hud-editor-buttons">
                <button id="reset-hud">Сброс</button>
                <button id="save-hud">Сохранить</button>
            </div>
        </div>
    </div>
    
    <!-- HUD -->
    <div id="hud">
        <div id="health-text" data-ctrl="hudHealth">HP</div>
        <div id="health-bar"><div id="health-fill"></div></div>
        <div id="ammo" data-ctrl="hudAmmo"><span id="current-ammo">30</span> / <span id="reserve-ammo">90</span></div>
        <div id="weapon-name">AK-47</div>
        <div id="grenades-count" data-ctrl="hudGrenades">🧨 <span id="grenade-num">3</span></div>
        <div id="kills" data-ctrl="hudKills">Убийства: <span id="kill-count">0</span></div>
    </div>
    
    <!-- Crosshair -->
    <div id="crosshair">
        <div id="crosshair-dot"></div>
        <div class="cross-line cross-v cross-top"></div>
        <div class="cross-line cross-v cross-bottom"></div>
        <div class="cross-line cross-h cross-left"></div>
        <div class="cross-line cross-h cross-right"></div>
    </div>
    
    <!-- Hit marker -->
    <div id="hitmarker">
        <div class="hit-line hit-1"></div>
        <div class="hit-line hit-2"></div>
        <div class="hit-line hit-3"></div>
        <div class="hit-line hit-4"></div>
    </div>
    
    <!-- Damage overlay -->
    <div id="damage-overlay"></div>
    
    <!-- Sniper scope -->
    <div id="scope-overlay">
        <div id="scope-circle"></div>
        <div id="scope-crosshair">
            <div class="scope-line scope-h left"></div>
            <div class="scope-line scope-h right"></div>
            <div class="scope-line scope-v top"></div>
            <div class="scope-line scope-v bottom"></div>
        </div>
    </div>
    
    <!-- Bomb status -->
    <div id="bomb-status"></div>
    
    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="look-area"></div>
        <div id="joystick-move" class="joystick-container" data-ctrl="joystick">
            <div class="joystick-base">
                <div class="joystick-stick" id="move-stick"></div>
            </div>
        </div>
        <div id="btn-shoot" class="mobile-btn" data-ctrl="shoot"></div>
        <div id="btn-jump" class="mobile-btn" data-ctrl="jump"></div>
        <div id="btn-reload" class="mobile-btn" data-ctrl="reload"></div>
        <div id="btn-grenade" class="mobile-btn" data-ctrl="grenade"></div>
        <div id="btn-weapon" class="mobile-btn" data-ctrl="weapon"></div>
        <div id="btn-scope" class="mobile-btn" data-ctrl="scope"></div>
        <div id="btn-bomb" class="mobile-btn" data-ctrl="bomb">?</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
    <script>

// ==================== MOBILE DETECTION ====================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) 
    || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);

if (isMobile) {
    document.body.classList.add('mobile');
}

// ==================== GAME CONFIG ====================
const CONFIG = {
    player: {
        height: 1.7,
        speed: 8,
        sprintMultiplier: 1.5,
        jumpForce: 8,
        gravity: 25,
        health: 100
    },
    weapon: {
        damage: 25,
        fireRate: 100,
        recoil: 0.008,
        magazineSize: 30,
        reserveAmmo: 90,
        reloadTime: 2000
    },
    sniper: {
        damage: 200,
        fireRate: 1500,
        recoil: 0.025,
        magazineSize: 5,
        reserveAmmo: 20,
        reloadTime: 3000,
        scopeZoom: 3
    },
    knife: {
        damage: 55,
        fireRate: 500,
        range: 2.5
    },
    enemy: {
        health: 80,
        speed: 2.5,
        damage: 6,
        fireRate: 1200,
        accuracy: 0.4,
        attackRange: 30,
        detectionRange: 35
    },
    map: {
        size: 40
    }
};

const DEFAULT_MAP_SIZE = CONFIG.map.size;
const AIM_MAP_SIZE = 24;
const AIM_SPAWNS = [
    { x: -12, z: -10 },
    { x: 12, z: 10 }
];

// ==================== GAME STATE ====================
const state = {
    isPlaying: false,
    isMultiplayer: false,
    isSearchingMatch: false,
    mpSpawnIndex: 0,
    mpOpponentId: null,
    mpRoom: null,
    health: CONFIG.player.health,
    currentweapon: '1/2', // rifle or sniper
    ammo: CONFIG.weapon.magazineSize,
    reserveAmmo: CONFIG.weapon.reserveAmmo,
    sniperAmmo: CONFIG.sniper.magazineSize,
    sniperReserve: CONFIG.sniper.reserveAmmo,
    grenades: 3,
    kills: 0,
    isReloading: false,
    canShoot: true,
    canThrowGrenade: true,
    isScoped: false,
    velocity: new THREE.Vector3(),
    isGrounded: true,
    moveForward: false,
    moveBackward: false,
    moveLeft: false,
    moveRight: false,
    isMoving: false,
    isSprinting: false,
    jumpHeld: false,
    crosshairSpread: 0,
    // Bomb state
    bombPlanted: false,
    bombPosition: null,
    bombTimer: 0,
    bombDefuseTimer: 0,
    enemyDefusing: false,
    regenTimer: 0
};

// ==================== THREE.JS SETUP ====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0xd4a574, 20, 80);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, CONFIG.player.height, 15);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('game-container').appendChild(renderer.domElement);

// ==================== POINTER LOCK CONTROLS ====================
class FPSControls {
    constructor(camera, domElement) {
        this.camera = camera;
        this.domElement = domElement;
        this.isLocked = false;
        this.euler = new THREE.Euler(0, 0, 0, 'YXZ');
        this.sensitivity = 0.002;
        this.maxStep = 0.05; // clamp per-event to avoid acceleration spikes
        
        this.connect();
    }
    
    connect() {
        document.addEventListener('pointerlockchange', () => {
            this.isLocked = document.pointerLockElement === this.domElement;
            if (!this.isLocked && state.isPlaying && !isMobile) {
                document.getElementById('menu').style.display = 'flex';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('crosshair').style.display = 'none';
            }
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!this.isLocked || isMobile) return;
            
            this.euler.setFromQuaternion(this.camera.quaternion);
            const stepX = THREE.MathUtils.clamp(e.movementX * this.sensitivity, -this.maxStep, this.maxStep);
            const stepY = THREE.MathUtils.clamp(e.movementY * this.sensitivity, -this.maxStep, this.maxStep);
            this.euler.y -= stepX;
            this.euler.x -= stepY;
            this.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.euler.x));
            this.camera.quaternion.setFromEuler(this.euler);
        });
    }
    
    lock() {
        if (!isMobile) {
            this.domElement.requestPointerLock();
        }
    }
    
    getDirection() {
        const direction = new THREE.Vector3(0, 0, -1);
        return direction.applyQuaternion(this.camera.quaternion);
    }
}

const controls = new FPSControls(camera, renderer.domElement);

// ==================== LIGHTING ====================
const ambientLight = new THREE.AmbientLight(0xffeedd, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffffff, 1);
sunLight.position.set(50, 100, 50);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 200;
sunLight.shadow.camera.left = -100;
sunLight.shadow.camera.right = 100;
sunLight.shadow.camera.top = 100;
sunLight.shadow.camera.bottom = -100;
scene.add(sunLight);

// ==================== MATERIALS ====================
const materials = {
    sand: new THREE.MeshLambertMaterial({ color: 0xdcc08a }),
    sandDark: new THREE.MeshLambertMaterial({ color: 0xc8a56c }),
    stone: new THREE.MeshLambertMaterial({ color: 0xb98d58 }),
    concrete: new THREE.MeshLambertMaterial({ color: 0xa07a54 }),
    plaster: new THREE.MeshLambertMaterial({ color: 0xddd8cf }),
    metal: new THREE.MeshLambertMaterial({ color: 0x555555 }),
    wood: new THREE.MeshLambertMaterial({ color: 0x8b4513 }),
    enemy: new THREE.MeshLambertMaterial({ color: 0xe94560 })
};

// ==================== MAP CREATION ====================
const mapGroup = new THREE.Group();
scene.add(mapGroup);
const colliders = [];

function clearMap() {
    colliders.length = 0;
    while (mapGroup.children.length > 0) {
        const child = mapGroup.children.pop();
        mapGroup.remove(child);
        if (child.geometry && child.geometry.dispose) {
            child.geometry.dispose();
        }
    }
}

function createBox(w, h, d, x, y, z, material, isCollider = true) {
    const geometry = new THREE.BoxGeometry(w, h, d);
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.set(x, y, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    mapGroup.add(mesh);
    
    if (isCollider) {
        colliders.push({
            mesh,
            box: new THREE.Box3().setFromObject(mesh)
        });
    }
    return mesh;
}

function createDefaultMap() {
    CONFIG.map.size = DEFAULT_MAP_SIZE;
    clearMap();
    const S = CONFIG.map.size;

    // Ground
    const groundGeo = new THREE.PlaneGeometry(S * 2, S * 2);
    const ground = new THREE.Mesh(groundGeo, materials.sand);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    mapGroup.add(ground);

    // Outer walls (sandstone perimeter)
    createBox(S * 2, 5.5, 1, 0, 2.75, -S, materials.stone);
    createBox(S * 2, 5.5, 1, 0, 2.75, S, materials.stone);
    createBox(1, 5.5, S * 2, -S, 2.75, 0, materials.stone);
    createBox(1, 5.5, S * 2, S, 2.75, 0, materials.stone);

    // White plaster houses on edges for contrast
    createBox(12, 6, 10, -32, 3, 10, materials.plaster);
    createBox(10, 5, 8, 30, 2.5, -6, materials.plaster);
    createBox(12, 5, 10, 18, 2.5, 30, materials.plaster);
    createBox(10, 5, 10, -18, 2.5, -30, materials.plaster);

    // Spawn platforms (CT / T)
    createBox(14, 0.4, 14, -30, 0.2, -24, materials.sandDark);
    createBox(14, 0.4, 14,  30, 0.2,  24, materials.sandDark);
    createBox(3, 1.5, 3, -32, 0.75, -22, materials.wood);
    createBox(3, 1.5, 3,  32, 0.75,  22, materials.wood);

    // Mid double-door corridor
    createBox(1, 4, 26, -7, 2, 0, materials.stone);
    createBox(1, 4, 26,  7, 2, 0, materials.stone);
    createBox(4, 3, 2, 0, 1.5, -13, materials.stone);
    createBox(4, 3, 2, 0, 1.5,  13, materials.stone);

    // Mid boxes / cover
    createBox(3, 2, 2, -1, 1, -2, materials.concrete);
    createBox(2.2, 1.2, 2.2, 2, 0.6, 3, materials.wood);
    createBox(2.2, 1.2, 2.2, -3, 0.6, 5, materials.wood);

    // Catwalk to A (elevated)
    createBox(16, 0.6, 4, -12, 0.3, 14, materials.sandDark);
    createBox(1, 3, 8, -20, 1.5, 14, materials.stone); // rail wall
    createBox(4, 3.5, 2, -12, 1.75, 18, materials.stone); // small arch facade

    // A site plaza with arches and crates
    createBox(12, 0.4, 12, -22, 0.2, 20, materials.sandDark);
    createBox(3, 3, 2, -24, 1.5, 24, materials.stone); // arch stub
    createBox(3, 3, 2, -20, 1.5, 24, materials.stone);
    createBox(2.6, 2.2, 2.6, -22, 1.1, 18, materials.concrete);
    createBox(2.2, 1.2, 2.2, -24, 0.6, 22, materials.wood);
    createBox(2.2, 1.2, 2.2, -20, 0.6, 22, materials.wood);
    // planter feel
    createBox(4, 0.6, 4, -18, 0.3, 20, materials.sandDark);

    // Short to A (archway)
    createBox(1, 4, 8, -14, 2, 8, materials.stone);
    createBox(3, 3, 2, -14, 1.5, 4, materials.stone);

    // Mid to B connector (arches)
    createBox(1, 4, 12, 10, 2, -6, materials.stone);
    createBox(3, 3, 2, 10, 1.5, -12, materials.stone);

    // B tunnels (low ceiling feel)
    createBox(1, 3.5, 16, 20, 1.75, -12, materials.stone);
    createBox(1, 3.5, 16, 24, 1.75, -12, materials.stone);
    createBox(4, 3, 2, 22, 1.5, -20, materials.stone);

    // B site plateau with stairs
    createBox(14, 0.5, 14, 28, 0.25, -18, materials.sandDark);
    createBox(3, 2, 3, 30, 1, -18, materials.concrete);
    createBox(2, 1.4, 2, 26, 0.7, -16, materials.wood);
    createBox(2, 1.4, 2, 26, 0.7, -20, materials.wood);
    // stairs up to plateau (stepped boxes)
    createBox(6, 0.4, 2, 22, 0.2, -14, materials.sandDark);
    createBox(6, 0.8, 2, 22, 0.4, -12, materials.sandDark);
    createBox(6, 1.2, 2, 22, 0.6, -10, materials.sandDark);

    // Palm planters / small covers for flavor
    createBox(2.5, 1, 2.5, -30, 0.5, 8, materials.sandDark);
    createBox(2.5, 1, 2.5, 30, 0.5, -8, materials.sandDark);

    // Extra boundary props
    const props = [
        [12, 1.2, 3, -30, 0.6, -30, materials.metal],
        [10, 1.0, 2,  30, 0.5,  30, materials.metal]
    ];
    props.forEach(([w,h,d,x,y,z,mat]) => createBox(w,h,d,x,y,z,mat));
}

function createAimMap() {
    CONFIG.map.size = AIM_MAP_SIZE;
    clearMap();
    const S = CONFIG.map.size;

    const groundGeo = new THREE.PlaneGeometry(S * 2, S * 2);
    const ground = new THREE.Mesh(groundGeo, materials.sandDark);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    mapGroup.add(ground);

    // Perimeter walls to keep players inside
    createBox(S * 2, 3.5, 1, 0, 1.75, -S, materials.plaster);
    createBox(S * 2, 3.5, 1, 0, 1.75, S, materials.plaster);
    createBox(1, 3.5, S * 2, -S, 1.75, 0, materials.plaster);
    createBox(1, 3.5, S * 2, S, 1.75, 0, materials.plaster);

    // Slightly raised mid to echo aim maps
    createBox(8, 0.4, 8, 0, 0.2, 0, materials.sand);

    const stack = (x, z, levels = 1, w = 2.2, h = 1.6, d = 2.2) => {
        for (let i = 0; i < levels; i++) {
            createBox(w, h, d, x, h / 2 + i * h, z, materials.wood);
        }
    };

    // Central stacks
    stack(0, 0, 3);
    stack(-3, 0, 2);
    stack(3, 0, 2);
    stack(0, -4, 2);
    stack(0, 4, 2);

    // Side covers
    stack(-8, -6, 1);
    stack(-8, 6, 1);
    stack(8, -6, 1);
    stack(8, 6, 1);

    // Long lane crates
    stack(-5, -10, 1, 2.4, 1.4, 2.4);
    stack(5, 10, 1, 2.4, 1.4, 2.4);

    // Small boxes scatter for peeking
    stack(-2, -8, 1, 1.4, 1.2, 1.4);
    stack(2, 8, 1, 1.4, 1.2, 1.4);
    stack(-10, 0, 1, 1.6, 1.4, 1.6);
    stack(10, 0, 1, 1.6, 1.4, 1.6);
}

createDefaultMap();

// ==================== WEAPON MODEL ====================
const weaponGroup = new THREE.Group();
const sniperGroup = new THREE.Group();
const knifeGroup = new THREE.Group();
const weaponPivot = new THREE.Group();

function createWeapon() {
    // === AK-47 (Rifle) ===
    // Main body
    const bodyGeo = new THREE.BoxGeometry(0.08, 0.12, 0.6);
    const body = new THREE.Mesh(bodyGeo, materials.metal);
    body.position.set(0, 0, -0.2);
    weaponGroup.add(body);
    
    // Barrel
    const barrelGeo = new THREE.CylinderGeometry(0.02, 0.025, 0.4, 8);
    const barrel = new THREE.Mesh(barrelGeo, materials.metal);
    barrel.rotation.x = Math.PI / 2;
    barrel.position.set(0, 0.02, -0.7);
    weaponGroup.add(barrel);
    
    // Stock
    const stockGeo = new THREE.BoxGeometry(0.06, 0.1, 0.25);
    const stock = new THREE.Mesh(stockGeo, materials.wood);
    stock.position.set(0, -0.02, 0.15);
    weaponGroup.add(stock);
    
    // Magazine
    const magGeo = new THREE.BoxGeometry(0.04, 0.15, 0.08);
    const mag = new THREE.Mesh(magGeo, materials.metal);
    mag.position.set(0, -0.12, -0.15);
    mag.rotation.x = 0.2;
    weaponGroup.add(mag);
    
    // Grip
    const gripGeo = new THREE.BoxGeometry(0.05, 0.1, 0.06);
    const grip = new THREE.Mesh(gripGeo, materials.wood);
    grip.position.set(0, -0.1, 0);
    grip.rotation.x = 0.3;
    weaponGroup.add(grip);
    
    // Front grip
    const frontGripGeo = new THREE.BoxGeometry(0.04, 0.08, 0.04);
    const frontGrip = new THREE.Mesh(frontGripGeo, materials.metal);
    frontGrip.position.set(0, -0.08, -0.4);
    weaponGroup.add(frontGrip);
    
    // Sight
    const sightGeo = new THREE.BoxGeometry(0.03, 0.04, 0.06);
    const sight = new THREE.Mesh(sightGeo, materials.metal);
    sight.position.set(0, 0.08, -0.1);
    weaponGroup.add(sight);
    
    // Muzzle flash light
    const muzzleFlash = new THREE.PointLight(0xffaa00, 0, 5);
    muzzleFlash.position.set(0, 0.02, -0.9);
    muzzleFlash.name = 'muzzleFlash';
    weaponGroup.add(muzzleFlash);
    
    weaponGroup.position.set(0.25, -0.2, -0.5);
    weaponPivot.add(weaponGroup);
    
    // === AWP (Sniper) ===
    // Long body
    const sniperBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.06, 0.1, 0.9),
        materials.metal
    );
    sniperBody.position.set(0, 0, -0.3);
    sniperGroup.add(sniperBody);
    
    // Long barrel
    const sniperBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.02, 0.6, 8),
        materials.metal
    );
    sniperBarrel.rotation.x = Math.PI / 2;
    sniperBarrel.position.set(0, 0.02, -1.0);
    sniperGroup.add(sniperBarrel);
    
    // Scope
    const scopeBody = new THREE.Mesh(
        new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8),
        materials.metal
    );
    scopeBody.rotation.x = Math.PI / 2;
    scopeBody.position.set(0, 0.1, -0.2);
    sniperGroup.add(scopeBody);
    
    // Scope lens front
    const scopeLens = new THREE.Mesh(
        new THREE.CircleGeometry(0.025, 8),
        new THREE.MeshBasicMaterial({ color: 0x4488ff })
    );
    scopeLens.position.set(0, 0.1, -0.1);
    sniperGroup.add(scopeLens);
    
    // Stock
    const sniperStock = new THREE.Mesh(
        new THREE.BoxGeometry(0.05, 0.12, 0.3),
        materials.wood
    );
    sniperStock.position.set(0, -0.02, 0.25);
    sniperGroup.add(sniperStock);
    
    // Grip
    const sniperGrip = new THREE.Mesh(
        new THREE.BoxGeometry(0.04, 0.1, 0.05),
        materials.wood
    );
    sniperGrip.position.set(0, -0.1, 0.05);
    sniperGrip.rotation.x = 0.3;
    sniperGroup.add(sniperGrip);
    
    // Magazine
    const sniperMag = new THREE.Mesh(
        new THREE.BoxGeometry(0.03, 0.1, 0.06),
        materials.metal
    );
    sniperMag.position.set(0, -0.1, -0.1);
    sniperGroup.add(sniperMag);
    
    // Muzzle flash
    const sniperFlash = new THREE.PointLight(0xffaa00, 0, 8);
    sniperFlash.position.set(0, 0.02, -1.3);
    sniperFlash.name = 'muzzleFlash';
    sniperGroup.add(sniperFlash);
    
    sniperGroup.position.set(0.25, -0.2, -0.5);
    sniperGroup.visible = false;
    weaponPivot.add(sniperGroup);
    

    
    // === KNIFE ===
    const bladeGeo = new THREE.BoxGeometry(0.02, 0.04, 0.25);
    const bladeMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
    const blade = new THREE.Mesh(bladeGeo, bladeMat);
    blade.position.set(0, 0, -0.15);
    knifeGroup.add(blade);
    
    const edgeGeo = new THREE.BoxGeometry(0.005, 0.045, 0.25);
    const edgeMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
    const edge = new THREE.Mesh(edgeGeo, edgeMat);
    edge.position.set(-0.01, 0, -0.15);
    knifeGroup.add(edge);
    
    const handleGeo = new THREE.BoxGeometry(0.03, 0.05, 0.12);
    const handle = new THREE.Mesh(handleGeo, materials.wood);
    handle.position.set(0, 0, 0.05);
    knifeGroup.add(handle);
    
    const guardGeo = new THREE.BoxGeometry(0.05, 0.06, 0.015);
    const guard = new THREE.Mesh(guardGeo, materials.metal);
    guard.position.set(0, 0, -0.02);
    knifeGroup.add(guard);
    
    knifeGroup.position.set(0.3, -0.15, -0.3);
    knifeGroup.rotation.x = -0.3;
    knifeGroup.visible = false;
    weaponPivot.add(knifeGroup);
    camera.add(weaponPivot);
}

function switchWeapon(weapon) {
    if (state.isReloading) return;
    if (state.currentWeapon === weapon) return;
    
    state.currentWeapon = weapon;
    state.isScoped = false;
    document.getElementById('scope-overlay').classList.remove('active');
    document.getElementById('crosshair').style.display = 'block';
    camera.fov = 75;
    camera.updateProjectionMatrix();
    
    // Hide all weapons
    weaponGroup.visible = false;
    sniperGroup.visible = false;
    knifeGroup.visible = false;
    
    if (weapon === 'rifle') {
        weaponGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'AK-47';
        document.getElementById('current-ammo').textContent = state.ammo;
        document.getElementById('reserve-ammo').textContent = state.reserveAmmo;
        document.getElementById('ammo').style.display = 'block';
    } else if (weapon === 'sniper') {
        sniperGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'AWP';
        document.getElementById('current-ammo').textContent = state.sniperAmmo;
        document.getElementById('reserve-ammo').textContent = state.sniperReserve;
        document.getElementById('ammo').style.display = 'block';
    } else if (weapon === 'knife') {
        knifeGroup.visible = true;
        document.getElementById('weapon-name').textContent = 'НОЖ';
        document.getElementById('ammo').style.display = 'none';
    }
}

function toggleScope() {
    if (state.currentWeapon !== 'sniper') return;
    
    state.isScoped = !state.isScoped;
    
    if (state.isScoped) {
        document.getElementById('scope-overlay').classList.add('active');
        document.getElementById('crosshair').style.display = 'none';
        sniperGroup.visible = false;
        camera.fov = 75 / CONFIG.sniper.scopeZoom;
    } else {
        document.getElementById('scope-overlay').classList.remove('active');
        document.getElementById('crosshair').style.display = 'block';
        sniperGroup.visible = true;
        camera.fov = 75;
    }
    camera.updateProjectionMatrix();
}

createWeapon();
scene.add(camera);

// Weapon sway variables
let weaponSwayTime = 0;
let weaponRecoil = 0;
let targetWeaponRecoil = 0;

// ==================== ENEMIES ====================
const enemies = [];

class Enemy {
    constructor(x, z) {
        this.health = CONFIG.enemy.health;
        this.maxHealth = CONFIG.enemy.health;
        this.speed = CONFIG.enemy.speed;
        this.isAlive = true;
        this.lastShot = 0;
        this.state = 'idle'; // idle, patrol, chase, attack, cover
        this.stateTimer = 0;
        this.coverPos = null;
        this.patrolTarget = new THREE.Vector3(x, 0, z);
        
        // Body
        this.group = new THREE.Group();
        
        // Torso
        const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.1, 8);
        this.mesh = new THREE.Mesh(torsoGeo, materials.enemy);
        this.mesh.position.y = 1;
        this.mesh.castShadow = true;
        this.group.add(this.mesh);
        
        // Head (хитбокс)
        const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
        this.head = new THREE.Mesh(headGeo, materials.enemy);
        this.head.position.y = 1.8;
        this.head.castShadow = true;
        this.head.name = 'head';
        this.group.add(this.head);
        
        // Weapon
        this.weaponGroup = new THREE.Group();
        const gunBody = new THREE.Mesh(
            new THREE.BoxGeometry(0.06, 0.08, 0.4),
            materials.metal
        );
        gunBody.position.z = -0.2;
        this.weaponGroup.add(gunBody);
        
        const gunBarrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.015, 0.02, 0.25, 6),
            materials.metal
        );
        gunBarrel.rotation.x = Math.PI / 2;
        gunBarrel.position.z = -0.5;
        this.weaponGroup.add(gunBarrel);
        
        // Muzzle flash for enemy
        this.muzzleFlash = new THREE.PointLight(0xffaa00, 0, 3);
        this.muzzleFlash.position.z = -0.6;
        this.weaponGroup.add(this.muzzleFlash);
        
        this.weaponGroup.position.set(0.3, 1.1, 0);
        this.group.add(this.weaponGroup);
        
        // Health bar background
        const hbBgGeo = new THREE.PlaneGeometry(0.8, 0.08);
        const hbBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
        this.healthBarBg = new THREE.Mesh(hbBgGeo, hbBgMat);
        this.healthBarBg.position.y = 2.3;
        this.group.add(this.healthBarBg);
        
        // Health bar fill
        const hbFillGeo = new THREE.PlaneGeometry(0.78, 0.06);
        const hbFillMat = new THREE.MeshBasicMaterial({ color: 0xe94560, side: THREE.DoubleSide });
        this.healthBarFill = new THREE.Mesh(hbFillGeo, hbFillMat);
        this.healthBarFill.position.y = 2.3;
        this.healthBarFill.position.z = 0.01;
        this.group.add(this.healthBarFill);
        
        this.group.position.set(x, 0, z);
        scene.add(this.group);
        
        this.velocity = new THREE.Vector3();
    }
    
    canSeePlayer(playerPos) {
        const dir = new THREE.Vector3().subVectors(playerPos, this.group.position).normalize();
        const ray = new THREE.Raycaster(
            new THREE.Vector3(this.group.position.x, 1.5, this.group.position.z),
            dir
        );
        const hits = ray.intersectObjects(colliders.map(c => c.mesh));
        const distToPlayer = this.group.position.distanceTo(playerPos);
        
        if (hits.length === 0 || hits[0].distance > distToPlayer) {
            return true;
        }
        return false;
    }
    
    findCover(playerPos) {
        let bestCover = null;
        let bestScore = -Infinity;
        
        colliders.forEach(c => {
            const coverPos = c.mesh.position.clone();
            const dirFromPlayer = new THREE.Vector3().subVectors(coverPos, playerPos).normalize();
            const testPos = coverPos.clone().add(dirFromPlayer.multiplyScalar(2));
            testPos.y = 0;
            
            const distToPlayer = testPos.distanceTo(playerPos);
            const distToSelf = testPos.distanceTo(this.group.position);
            
            if (distToPlayer > 8 && distToPlayer < 30) {
                const score = distToPlayer - distToSelf * 0.5;
                if (score > bestScore) {
                    bestScore = score;
                    bestCover = testPos;
                }
            }
        });
        
        return bestCover;
    }
    
    shoot(playerPos) {
        const now = Date.now();
        if (now - this.lastShot < CONFIG.enemy.fireRate) return;
        
        this.lastShot = now;
        
        // Muzzle flash
        this.muzzleFlash.intensity = 2;
        setTimeout(() => { this.muzzleFlash.intensity = 0; }, 50);
        
        // Accuracy check
        if (Math.random() < CONFIG.enemy.accuracy) {
            applyPlayerDamage(CONFIG.enemy.damage);
        }
        
        // Tracer from enemy
        const start = this.group.position.clone();
        start.y = 1.5;
        const spread = (1 - CONFIG.enemy.accuracy) * 0.3;
        const end = playerPos.clone();
        end.x += (Math.random() - 0.5) * spread * 5;
        end.y += (Math.random() - 0.5) * spread * 5;
        end.z += (Math.random() - 0.5) * spread * 5;
        createTracer(start, end);
    }
    
    update(delta, playerPos) {
        if (!this.isAlive) return;
        
        // Face health bar to camera
        this.healthBarBg.lookAt(camera.position);
        this.healthBarFill.lookAt(camera.position);
        
        // Update health bar
        const healthPercent = this.health / this.maxHealth;
        this.healthBarFill.scale.x = healthPercent;
        this.healthBarFill.position.x = (1 - healthPercent) * -0.39;
        
        const distToPlayer = this.group.position.distanceTo(playerPos);
        const canSee = this.canSeePlayer(playerPos);
        
        this.stateTimer -= delta;
        
        // AI State Machine - prioritize bomb if planted
        if (state.bombPlanted && state.bombPosition) {
            const distToBomb = this.group.position.distanceTo(state.bombPosition);
            if (distToBomb < 3) {
                this.state = 'defuse';
            } else if (distToBomb > 5) {
                this.state = 'go_bomb';
            }
        } else if (canSee && distToPlayer < CONFIG.enemy.detectionRange) {
            if (distToPlayer < CONFIG.enemy.attackRange) {
                this.state = 'attack';
            } else {
                this.state = 'chase';
            }
        } else if (this.state === 'attack' || this.state === 'chase') {
            this.state = 'cover';
            this.coverPos = this.findCover(playerPos);
            this.stateTimer = 3;
        } else if (this.stateTimer <= 0) {
            this.state = 'patrol';
            this.patrolTarget.set(
                (Math.random() - 0.5) * CONFIG.map.size * 1.2,
                0,
                (Math.random() - 0.5) * CONFIG.map.size * 1.2
            );
            this.stateTimer = 3 + Math.random() * 2;
        }
        
        // Execute state behavior
        let targetPos = null;
        let moveSpeed = this.speed;
        
        switch (this.state) {
            case 'defuse':
                targetPos = null;
                break;
                
            case 'go_bomb':
                targetPos = state.bombPosition.clone();
                moveSpeed = this.speed * 1.5;
                break;
            
            case 'attack':
                // Move towards player, slight strafe
                targetPos = playerPos.clone();
                if (distToPlayer > 8) {
                    // Get closer first
                    moveSpeed = this.speed * 0.8;
                } else {
                    // Strafe when close
                    moveSpeed = this.speed * 0.3;
                }
                this.shoot(playerPos);
                break;
                
            case 'chase':
                targetPos = playerPos.clone();
                moveSpeed = this.speed;
                break;
                
            case 'cover':
                if (this.coverPos) {
                    targetPos = this.coverPos;
                    if (this.group.position.distanceTo(this.coverPos) < 2) {
                        this.stateTimer = 0;
                    }
                }
                break;
                
            case 'patrol':
            default:
                targetPos = this.patrolTarget;
                if (this.group.position.distanceTo(this.patrolTarget) < 3) {
                    this.stateTimer = 0; // Pick new target
                }
                moveSpeed = this.speed * 0.4;
                break;
        }
        
        // Movement
        if (targetPos) {
            const dir = new THREE.Vector3()
                .subVectors(targetPos, this.group.position);
            dir.y = 0;
            
            if (dir.length() > 0.5) {
                dir.normalize();
                this.velocity.x = dir.x * moveSpeed;
                this.velocity.z = dir.z * moveSpeed;
                
                // Check collision before moving
                const newX = this.group.position.x + this.velocity.x * delta;
                const newZ = this.group.position.z + this.velocity.z * delta;
                const enemyBox = new THREE.Box3().setFromCenterAndSize(
                    new THREE.Vector3(newX, this.group.position.y + 1, newZ),
                    new THREE.Vector3(1.2, 2, 1.2)
                );
                let canMove = true;
                for (const collider of colliders) {
                    if (enemyBox.intersectsBox(collider.box)) {
                        canMove = false;
                        break;
                    }
                }
                if (canMove) {
                    this.group.position.x = newX;
                    this.group.position.z = newZ;
                } else {
                    // Try moving only X or only Z
                    const xOnlyBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(newX, this.group.position.y + 1, this.group.position.z),
                        new THREE.Vector3(1.2, 2, 1.2)
                    );
                    let canMoveX = true;
                    for (const collider of colliders) {
                        if (xOnlyBox.intersectsBox(collider.box)) { canMoveX = false; break; }
                    }
                    if (canMoveX) this.group.position.x = newX;
                    const zOnlyBox = new THREE.Box3().setFromCenterAndSize(
                        new THREE.Vector3(this.group.position.x, this.group.position.y + 1, newZ),
                        new THREE.Vector3(1.2, 2, 1.2)
                    );
                    let canMoveZ = true;
                    for (const collider of colliders) {
                        if (zOnlyBox.intersectsBox(collider.box)) { canMoveZ = false; break; }
                    }
                    if (canMoveZ) this.group.position.z = newZ;
                }
            }
        }
        
        // Keep in bounds
        const bound = CONFIG.map.size - 2;
        this.group.position.x = Math.max(-bound, Math.min(bound, this.group.position.x));
        this.group.position.z = Math.max(-bound, Math.min(bound, this.group.position.z));
        
        // Face player when attacking, bomb when defusing, otherwise face movement
        if (this.state === 'attack' || this.state === 'chase') {
            const lookDir = new THREE.Vector3().subVectors(playerPos, this.group.position);
            this.group.rotation.y = Math.atan2(lookDir.x, lookDir.z);
        } else if (this.velocity.length() > 0.1) {
            this.group.rotation.y = Math.atan2(this.velocity.x, this.velocity.z);
        }
    }
    
    takeDamage(amount, isHeadshot = false) {
        this.health -= amount;
        showHitmarker(isHeadshot);
        
        // React to damage - become aggressive
        this.state = 'chase';
        
        if (this.health <= 0) {
            this.die();
        }
    }
    
    die() {
        this.isAlive = false;
        state.kills++;
        updateHUD();
        
        // Death particles
        for (let i = 0; i < 12; i++) {
            createParticle(
                this.group.position.x,
                this.group.position.y + 1,
                this.group.position.z,
                0xe94560
            );
        }
        
        scene.remove(this.group);
        
        // Respawn after delay
        setTimeout(() => {
            this.respawn();
        }, 5000);
    }
    
    respawn() {
        this.health = this.maxHealth;
        this.isAlive = true;
        this.state = 'patrol';
        this.stateTimer = 2;
        const bound = CONFIG.map.size - 10;
        this.group.position.set(
            (Math.random() - 0.5) * bound * 2,
            0,
            (Math.random() - 0.5) * bound * 2
        );
        scene.add(this.group);
    }
}

// Spawn enemies
function spawnEnemies() {
    const spawnPoints = [[32, 32], [-32, -32], [32, -32], [-32, 32]];
    
    spawnPoints.forEach(pos => {
        enemies.push(new Enemy(pos[0], pos[1]));
    });
}

spawnEnemies();

// ==================== PARTICLES ====================
const particles = [];

function createParticle(x, y, z, color) {
    const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const mat = new THREE.MeshBasicMaterial({ color });
    const particle = new THREE.Mesh(geo, mat);
    particle.position.set(x, y, z);
    particle.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 10,
        Math.random() * 8,
        (Math.random() - 0.5) * 10
    );
    particle.life = 1;
    scene.add(particle);
    particles.push(particle);
}

function updateParticles(delta) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.velocity.y -= 20 * delta;
        p.position.add(p.velocity.clone().multiplyScalar(delta));
        p.life -= delta * 2;
        p.material.opacity = p.life;
        p.scale.multiplyScalar(0.98);
        
        if (p.life <= 0) {
            scene.remove(p);
            particles.splice(i, 1);
        }
    }
}

// ==================== TRACERS ====================
const tracers = [];

function createTracer(start, end) {
    const points = [start.clone(), end.clone()];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({ color: 0xffff00, transparent: true, opacity: 1 });
    const line = new THREE.Line(geo, mat);
    line.life = 0.1;
    scene.add(line);
    tracers.push(line);
}

function updateTracers(delta) {
    for (let i = tracers.length - 1; i >= 0; i--) {
        const t = tracers[i];
        t.life -= delta;
        t.material.opacity = t.life * 10;
        
        if (t.life <= 0) {
            scene.remove(t);
            tracers.splice(i, 1);
        }
    }
}

// ==================== GRENADES ====================
const grenades = [];
const grenadeMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5a27 });

function throwGrenade() {
    if (!state.canThrowGrenade || state.grenades <= 0) return;
    
    state.grenades--;
    state.canThrowGrenade = false;
    updateHUD();
    
    // Create grenade mesh
    const grenadeGeo = new THREE.SphereGeometry(0.15, 8, 8);
    const grenade = new THREE.Mesh(grenadeGeo, grenadeMaterial);
    
    // Start position (from player)
    grenade.position.copy(camera.position);
    
    // Throw direction
    const throwDir = new THREE.Vector3();
    camera.getWorldDirection(throwDir);
    throwDir.y += 0.3; // Arc upward
    throwDir.normalize();
    
    grenade.velocity = throwDir.multiplyScalar(25);
    grenade.life = 2.5; // Explodes after 2.5 seconds
    grenade.bounces = 0;
    
    scene.add(grenade);
    grenades.push(grenade);
    
    // Cooldown
    setTimeout(() => {
        state.canThrowGrenade = true;
    }, 500);
}

function explodeGrenade(grenade) {
    const explosionPos = grenade.position.clone();
    const explosionRadius = 8;
    const maxDamage = 80;
    
    // Damage enemies
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        const dist = enemy.group.position.distanceTo(explosionPos);
        if (dist < explosionRadius) {
            const damage = maxDamage * (1 - dist / explosionRadius);
            enemy.takeDamage(damage);
        }
    });
    
    // Damage player
    const playerDist = camera.position.distanceTo(explosionPos);
    if (playerDist < explosionRadius) {
        const damage = maxDamage * 0.5 * (1 - playerDist / explosionRadius);
        applyPlayerDamage(damage);
    }
    
    // Explosion particles
    for (let i = 0; i < 30; i++) {
        createParticle(explosionPos.x, explosionPos.y, explosionPos.z, 0xff6600);
    }
    for (let i = 0; i < 20; i++) {
        createParticle(explosionPos.x, explosionPos.y, explosionPos.z, 0xffff00);
    }
    
    // Explosion flash
    const flash = new THREE.PointLight(0xff6600, 5, 15);
    flash.position.copy(explosionPos);
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 100);
    
    // Remove grenade
    scene.remove(grenade);
}

function updateGrenades(delta) {
    for (let i = grenades.length - 1; i >= 0; i--) {
        const g = grenades[i];
        
        // Gravity
        g.velocity.y -= 20 * delta;
        
        // Move
        const newPos = g.position.clone().add(g.velocity.clone().multiplyScalar(delta));
        
        // Ground bounce
        if (newPos.y < 0.15) {
            newPos.y = 0.15;
            g.velocity.y *= -0.4;
            g.velocity.x *= 0.7;
            g.velocity.z *= 0.7;
            g.bounces++;
        }
        
        // Wall collision (simple bounds check)
        const bound = CONFIG.map.size - 1;
        if (Math.abs(newPos.x) > bound) {
            g.velocity.x *= -0.5;
            newPos.x = Math.sign(newPos.x) * bound;
        }
        if (Math.abs(newPos.z) > bound) {
            g.velocity.z *= -0.5;
            newPos.z = Math.sign(newPos.z) * bound;
        }
        
        g.position.copy(newPos);
        
        // Timer
        g.life -= delta;
        if (g.life <= 0) {
            explodeGrenade(g);
            grenades.splice(i, 1);
        }
    }
}

// ==================== BOMB SYSTEM ====================
let bombMesh = null;
let bombLight = null;

function plantBomb() {
    if (state.isMultiplayer) return;
    if (state.bombPlanted) return;
    
    state.bombPlanted = true;
    state.bombTimer = 15;
    state.bombPosition = camera.position.clone();
    state.bombPosition.y = 0;
    
    // Create bomb mesh
    const bombGeo = new THREE.BoxGeometry(0.6, 0.3, 0.4);
    const bombMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
    bombMesh = new THREE.Mesh(bombGeo, bombMat);
    bombMesh.position.copy(state.bombPosition);
    bombMesh.position.y = 0.15;
    bombMesh.castShadow = true;
    scene.add(bombMesh);
    
    // Blinking light
    bombLight = new THREE.PointLight(0xff0000, 1, 5);
    bombLight.position.copy(bombMesh.position);
    bombLight.position.y = 0.4;
    scene.add(bombLight);
    
    // Screen indicator
    const bombStatus = document.getElementById('bomb-status');
    bombStatus.style.display = 'block';
    bombStatus.classList.add('success');
    bombStatus.classList.remove('danger');
}

function updateBomb(delta) {
    if (!state.bombPlanted) return;
    
    const bombStatus = document.getElementById('bomb-status');
    
    // Blink light
    if (bombLight) {
        bombLight.intensity = Math.sin(Date.now() * 0.01) > 0 ? 2 : 0;
    }
    
    // Check if enemy is near bomb
    let enemyDefusing = false;
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        const dist = enemy.group.position.distanceTo(state.bombPosition);
        if (dist < 3) {
            enemyDefusing = true;
            enemy.state = 'defuse';
        }
    });
    
    if (enemyDefusing) {
        state.enemyDefusing = true;
        state.bombDefuseTimer += delta;
        bombStatus.textContent = `?? ВРАГ ОБЕЗВРЕЖИВАЕТ! ${(4 - state.bombDefuseTimer).toFixed(1)}s`;
        bombStatus.classList.add('danger');
        bombStatus.classList.remove('success');
        
        if (state.bombDefuseTimer >= 4) {
            // Enemy defused - player loses
            bombStatus.textContent = '💀 БОМБА ОБЕЗВРЕЖЕНА - ПОРАЖЕНИЕ';
            // Stop further updates to avoid UI flicker
            state.bombPlanted = false;
            state.bombTimer = 0;
            state.bombDefuseTimer = 0;
            if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
            if (bombLight) { scene.remove(bombLight); bombLight = null; }
            setTimeout(() => gameOver(), 300);
            return;
        }
    } else {
        state.enemyDefusing = false;
        state.bombDefuseTimer = 0;
        bombStatus.classList.remove('danger');
        bombStatus.classList.add('success');
    }
    
    // Countdown
    state.bombTimer -= delta;
    
    if (!enemyDefusing) {
        bombStatus.textContent = `💣 БОМБА: ${state.bombTimer.toFixed(1)}s`;
    }
    
    if (state.bombTimer <= 0) {
        // Bomb explodes - player wins!
        
        // Big explosion
        for (let i = 0; i < 50; i++) {
            createParticle(state.bombPosition.x, 2, state.bombPosition.z, 0xff6600);
            createParticle(state.bombPosition.x, 2, state.bombPosition.z, 0xffff00);
        }
        
        // Flash
        const flash = new THREE.PointLight(0xff6600, 10, 50);
        flash.position.copy(state.bombPosition);
        flash.position.y = 2;
        scene.add(flash);
        setTimeout(() => scene.remove(flash), 200);
        
        // Kill all enemies
        enemies.forEach(e => {
            if (e.isAlive) e.die();
        });
        
        // Remove bomb
        if (bombMesh) scene.remove(bombMesh);
        if (bombLight) scene.remove(bombLight);
        
        state.bombPlanted = false;
        
        // Show win screen
        setTimeout(() => gameWin('bomb'), 500);
    }
}

// ==================== SHOOTING ====================
const raycaster = new THREE.Raycaster();

function shoot() {
    // Handle knife attack separately
    if (state.currentWeapon === 'knife') {
        knifeAttack();
        return;
    }
    const isSniper = state.currentWeapon === 'sniper';
    const currentAmmo = isSniper ? state.sniperAmmo : state.ammo;
    
    if (!state.canShoot || state.isReloading || currentAmmo <= 0) return;
    
    state.canShoot = false;
    
    if (state.isMultiplayer && mpSocket && mpSocket.connected) {
        mpSocket.emit('shoot', {});
    }
    
    if (isSniper) {
        state.sniperAmmo--;
    } else {
        state.ammo--;
    }
    updateHUD();
    
    // Muzzle flash
    const activeWeapon = isSniper ? sniperGroup : weaponGroup;
    const muzzleFlash = activeWeapon.getObjectByName('muzzleFlash');
    muzzleFlash.intensity = isSniper ? 5 : 3;
    setTimeout(() => { muzzleFlash.intensity = 0; }, 50);
    
    // Recoil
    const cfg = isSniper ? CONFIG.sniper : CONFIG.weapon;
    targetWeaponRecoil = isSniper ? 0.1 : 0.05;
    const recoilX = cfg.recoil * (0.8 + Math.random() * 0.4);
    controls.euler.x = Math.min(Math.PI / 2, controls.euler.x + recoilX);
    camera.quaternion.setFromEuler(controls.euler);
    
    // Crosshair spread (less for scoped sniper)
    if (!state.isScoped) {
        state.crosshairSpread = Math.min(state.crosshairSpread + (isSniper ? 15 : 8), 30);
    }
    
    // Raycast
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    
    // Get shoot direction with spread (no spread when scoped)
    const spread = state.isScoped ? 0 : state.crosshairSpread * 0.001;
    const direction = raycaster.ray.direction.clone();
    direction.x += (Math.random() - 0.5) * spread;
    direction.y += (Math.random() - 0.5) * spread;
    direction.z += (Math.random() - 0.5) * spread;
    raycaster.ray.direction.copy(direction.normalize());
    
    // Check enemy hits (body + head) and remote players
    const enemyParts = [];
    if (!state.isMultiplayer) {
        enemies.filter(e => e.isAlive).forEach(e => {
            enemyParts.push(e.mesh);
            enemyParts.push(e.head);
        });
    }
    const remoteParts = [];
    remotePlayers.forEach(p => {
        if (p.isAlive) {
            remoteParts.push(p.body);
            remoteParts.push(p.head);
        }
    });
    const hits = raycaster.intersectObjects([...enemyParts, ...remoteParts], true);
    
    // Tracer
    const start = camera.position.clone();
    start.add(direction.clone().multiplyScalar(1));
    let end;
    
    if (hits.length > 0) {
        const hit = hits[0];
        end = hit.point;
        
        // Find which enemy was hit
        const hitEnemy = (!state.isMultiplayer)
            ? enemies.find(e => e.isAlive && (e.mesh === hit.object || e.head === hit.object))
            : null;
        if (hitEnemy) {
            // Sniper = instant kill, otherwise headshot = 2.5x
            const isHeadshot = hit.object.name === 'head';
            let damage;
            if (isSniper) {
                damage = cfg.damage; // 200 = instant kill
            } else {
                damage = isHeadshot ? cfg.damage * 2.5 : cfg.damage;
            }
            hitEnemy.takeDamage(damage, isHeadshot || isSniper);
            
            // Impact particles
            for (let i = 0; i < 5; i++) {
                createParticle(hit.point.x, hit.point.y, hit.point.z, (isHeadshot || isSniper) ? 0xffff00 : 0xe94560);
            }
        } else {
            const remoteEntry = Array.from(remotePlayers.entries()).find(([, p]) => p.body === hit.object || p.head === hit.object);
            if (remoteEntry) {
                const [remoteId] = remoteEntry;
                const isHeadshot = hit.object.name === 'head';
                let damage;
                if (isSniper) {
                    damage = cfg.damage;
                } else {
                    damage = isHeadshot ? cfg.damage * 2.5 : cfg.damage;
                }
                applyRemoteDamage(remoteId, damage, isHeadshot || isSniper);
                if (mpSocket && mpSocket.connected) {
                    mpSocket.emit('hit', { targetId: remoteId, damage, isHeadshot: isHeadshot || isSniper });
                }
                showHitmarker(isHeadshot || isSniper);
                for (let i = 0; i < 5; i++) {
                    createParticle(hit.point.x, hit.point.y, hit.point.z, (isHeadshot || isSniper) ? 0xffff00 : 0xe94560);
                }
            }
        }
    } else {
        // Check wall hits
        const wallHits = raycaster.intersectObjects(colliders.map(c => c.mesh));
        if (wallHits.length > 0) {
            end = wallHits[0].point;
            for (let i = 0; i < 3; i++) {
                createParticle(end.x, end.y, end.z, 0xd4a574);
            }
        } else {
            end = camera.position.clone().add(direction.multiplyScalar(100));
        }
    }
    
    createTracer(start, end);
    
    // Fire rate cooldown
    setTimeout(() => {
        state.canShoot = true;
    }, cfg.fireRate);
    
    // Auto reload
    const reserve = isSniper ? state.sniperReserve : state.reserveAmmo;
    const ammoNow = isSniper ? state.sniperAmmo : state.ammo;
    if (ammoNow <= 0 && reserve > 0) {
        reload();
    }
}


// Knife attack function
function knifeAttack() {
    if (!state.canShoot) return;
    
    state.canShoot = false;
    
    // Knife swing animation
    const originalRot = knifeGroup.rotation.x;
    knifeGroup.rotation.x = -1;
    setTimeout(() => { knifeGroup.rotation.x = originalRot; }, 200);
    
    // Check for enemies in range
    const knifeRange = CONFIG.knife.range;
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);
    
    enemies.forEach(enemy => {
        if (!enemy.isAlive) return;
        
        const enemyPos = enemy.group.position.clone();
        enemyPos.y = 1;
        const playerPos = camera.position.clone();
        
        const dist = playerPos.distanceTo(enemyPos);
        if (dist > knifeRange) return;
        
        // Check if enemy is in front of player
        const toEnemy = enemyPos.clone().sub(playerPos).normalize();
        const dot = cameraDir.dot(toEnemy);
        
        if (dot > 0.5) {
            enemy.takeDamage(CONFIG.knife.damage, true);
            
            // Blood particles
            for (let i = 0; i < 8; i++) {
                createParticle(enemyPos.x, enemyPos.y, enemyPos.z, 0xe94560);
            }
        }
    });
    
    // Remote players in MP
    remotePlayers.forEach((p, id) => {
        if (!p.isAlive) return;
        
        const targetPos = p.group.position.clone();
        targetPos.y = 1;
        const playerPos = camera.position.clone();
        
        const dist = playerPos.distanceTo(targetPos);
        if (dist > knifeRange) return;
        
        const toEnemy = targetPos.clone().sub(playerPos).normalize();
        const dot = cameraDir.dot(toEnemy);
        if (dot > 0.5) {
            applyRemoteDamage(id, CONFIG.knife.damage, true);
            if (mpSocket && mpSocket.connected) {
                mpSocket.emit('hit', { targetId: id, damage: CONFIG.knife.damage, isHeadshot: true });
            }
            for (let i = 0; i < 8; i++) {
                createParticle(targetPos.x, targetPos.y, targetPos.z, 0xe94560);
            }
        }
    });
    
    // Cooldown
    setTimeout(() => {
        state.canShoot = true;
    }, CONFIG.knife.fireRate);
}
function reload() {
    const isSniper = state.currentWeapon === 'sniper';
    const cfg = isSniper ? CONFIG.sniper : CONFIG.weapon;
    const currentAmmo = isSniper ? state.sniperAmmo : state.ammo;
    const reserve = isSniper ? state.sniperReserve : state.reserveAmmo;
    
    if (state.isReloading || currentAmmo === cfg.magazineSize || reserve <= 0) return;
    
    state.isReloading = true;
    
    setTimeout(() => {
        const needed = cfg.magazineSize - currentAmmo;
        const available = Math.min(needed, reserve);
        
        if (isSniper) {
            state.sniperAmmo += available;
            state.sniperReserve -= available;
        } else {
            state.ammo += available;
            state.reserveAmmo -= available;
        }
        state.isReloading = false;
        updateHUD();
    }, cfg.reloadTime);
}

// ==================== COLLISION DETECTION ====================
function checkCollision(position, radius = 0.5) {
    const playerBox = new THREE.Box3(
        new THREE.Vector3(position.x - radius, position.y - CONFIG.player.height, position.z - radius),
        new THREE.Vector3(position.x + radius, position.y + 0.2, position.z + radius)
    );
    const playerMinY = position.y - CONFIG.player.height;
    
    for (const collider of colliders) {
        if (playerBox.intersectsBox(collider.box)) {
            // Если стоим на верхней поверхности, не считаем это коллизией
            const colliderTop = collider.box.max.y;
            if (playerMinY >= colliderTop - 0.2) {
                continue;
            }
            return true;
        }
    }
    return false;
}

function getGroundHeight(x, z) {
    const ray = new THREE.Raycaster(
        new THREE.Vector3(x, 50, z),
        new THREE.Vector3(0, -1, 0)
    );
    
    const hits = ray.intersectObjects(colliders.map(c => c.mesh));
    if (hits.length > 0) {
        return hits[0].point.y;
    }
    return 0;
}

// ==================== PLAYER MOVEMENT ====================
function updatePlayer(delta) {
    if (!controls.isLocked) return;
    
    const speed = CONFIG.player.speed * (state.isSprinting ? CONFIG.player.sprintMultiplier : 1);
    
    // Get movement direction
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    right.crossVectors(forward, new THREE.Vector3(0, 1, 0));
    
    // Calculate movement
    const moveDir = new THREE.Vector3();
    if (state.moveForward) moveDir.add(forward);
    if (state.moveBackward) moveDir.sub(forward);
    if (state.moveRight) moveDir.add(right);
    if (state.moveLeft) moveDir.sub(right);
    moveDir.normalize();
    
    state.isMoving = moveDir.length() > 0;
    
    // Apply horizontal movement
    const newPos = camera.position.clone();
    newPos.x += moveDir.x * speed * delta;
    newPos.z += moveDir.z * speed * delta;
    
    // Check collision for X
    if (!checkCollision(new THREE.Vector3(newPos.x, camera.position.y, camera.position.z))) {
        camera.position.x = newPos.x;
    }
    
    // Check collision for Z
    if (!checkCollision(new THREE.Vector3(camera.position.x, camera.position.y, newPos.z))) {
        camera.position.z = newPos.z;
    }
    
    // Gravity and jumping
    state.velocity.y -= CONFIG.player.gravity * delta;
    camera.position.y += state.velocity.y * delta;
    
    // Ground check
    const groundY = getGroundHeight(camera.position.x, camera.position.z) + CONFIG.player.height;
    if (camera.position.y <= groundY) {
        camera.position.y = groundY;
        state.velocity.y = 0;
        state.isGrounded = true;
        
        // Авто-прыжок при удержании пробела и движении по земле
        if (state.jumpHeld) {
            state.velocity.y = CONFIG.player.jumpForce;
            state.isGrounded = false;
        }
    } else {
        state.isGrounded = false;
    }
    
    // Keep in bounds
    const bound = CONFIG.map.size - 2;
    camera.position.x = Math.max(-bound, Math.min(bound, camera.position.x));
    camera.position.z = Math.max(-bound, Math.min(bound, camera.position.z));
}

// ==================== WEAPON ANIMATION ====================
function updateWeapon(delta) {
    // Weapon sway
    if (state.isMoving) {
        weaponSwayTime += delta * 10;
    }
    
    const swayX = Math.sin(weaponSwayTime) * 0.01 * (state.isMoving ? 1 : 0.2);
    const swayY = Math.abs(Math.cos(weaponSwayTime * 2)) * 0.008 * (state.isMoving ? 1 : 0.2);
    
    // Recoil recovery
    weaponRecoil = THREE.MathUtils.lerp(weaponRecoil, targetWeaponRecoil, delta * 20);
    targetWeaponRecoil = THREE.MathUtils.lerp(targetWeaponRecoil, 0, delta * 10);
    
    // Apply transforms
    weaponGroup.position.x = 0.25 + swayX;
    weaponGroup.position.y = -0.2 + swayY - weaponRecoil;
    weaponGroup.rotation.x = -weaponRecoil * 0.5;
    
    // Reload animation
    if (state.isReloading) {
        weaponGroup.rotation.x = Math.sin(Date.now() * 0.005) * 0.3 - 0.3;
    }
}

// ==================== CROSSHAIR ====================
function updateCrosshair(delta) {
    // Spread recovery
    if (!state.isMoving) {
        state.crosshairSpread = Math.max(0, state.crosshairSpread - delta * 50);
    } else {
        state.crosshairSpread = Math.max(5, state.crosshairSpread - delta * 30);
    }
    
    const baseGap = crosshairConfig.gap;
    const spread = baseGap + state.crosshairSpread;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    
    const top = document.querySelector('.cross-top');
    const bottom = document.querySelector('.cross-bottom');
    const left = document.querySelector('.cross-left');
    const right = document.querySelector('.cross-right');
    
    if (top) top.style.top = (-spread - len) + 'px';
    if (bottom) bottom.style.top = spread + 'px';
    if (left) left.style.left = (-spread - len) + 'px';
    if (right) right.style.left = spread + 'px';
}

// ==================== UI FUNCTIONS ====================
function updateHUD() {
    document.getElementById('health-fill').style.width = `${Math.max(0, state.health)}%`;
    
    if (state.currentWeapon === 'sniper') {
        document.getElementById('current-ammo').textContent = state.sniperAmmo;
        document.getElementById('reserve-ammo').textContent = state.sniperReserve;
    } else {
        document.getElementById('current-ammo').textContent = state.ammo;
        document.getElementById('reserve-ammo').textContent = state.reserveAmmo;
    }
    
    document.getElementById('kill-count').textContent = state.kills + '/30';
    document.getElementById('grenade-num').textContent = state.grenades;
    
    // Check win by kills
    if (state.isPlaying && state.kills >= 30) {
        gameWin('kills');
    }
}

function showHitmarker(isHeadshot = false) {
    const hitmarker = document.getElementById('hitmarker');
    hitmarker.style.opacity = '1';
    if (isHeadshot) {
        hitmarker.querySelectorAll('.hit-line').forEach(l => l.style.background = '#ffff00');
    } else {
        hitmarker.querySelectorAll('.hit-line').forEach(l => l.style.background = '#e94560');
    }
    setTimeout(() => { hitmarker.style.opacity = '0'; }, 100);
}

function showDamageOverlay() {
    state.regenTimer = 0; // Reset regen timer on damage
    const overlay = document.getElementById('damage-overlay');
    overlay.style.opacity = '1';
    setTimeout(() => { overlay.style.opacity = '0'; }, 200);
}

const defeatMessages = [
    '💀 УБИТ В БОЮ',
    '💀 МИССИЯ ПРОВАЛЕНА',
    '💔 ТЫ ПОГИБ',
    '💀 КОНЕЦ ПУТИ',
    '👿 ВРАГИ ПОБЕДИЛИ'
];

const victoryMessages = [
    '🏆 ПОБЕДА!',
    '🎖 МИССИЯ ВЫПОЛНЕНА!',
    '⭐ ОТЛИЧНАЯ РАБОТА!',
    '🥇 ТЫ ЛУЧШИЙ!',
    '💪 ВРАГИ УНИЧТОЖЕНЫ!'
];

function gameOver() {
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    
    // Clean up bomb state to avoid flicker after defuse
    state.bombPlanted = false;
    state.bombTimer = 0;
    state.bombDefuseTimer = 0;
    if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
    if (bombLight) { scene.remove(bombLight); bombLight = null; }
    
    const msg = defeatMessages[Math.floor(Math.random() * defeatMessages.length)];
    
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('menu').querySelector('h1').textContent = msg;
    document.getElementById('menu').querySelector('p').textContent = `Убито врагов: ${state.kills}`;
    document.getElementById('play-btn').textContent = 'ИГРАТЬ СНОВА';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    document.getElementById('bomb-status').style.display = 'none';
}

function gameWin(reason) {
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    
    const msg = victoryMessages[Math.floor(Math.random() * victoryMessages.length)];
    let subtext = '';
    
    if (reason === 'bomb') {
        subtext = '\u{1F4A3} Бомба взорвалась!';
    } else if (reason === 'kills') {
        subtext = `?? ${state.kills} врагов уничтожено!`;
    }
    
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('menu').querySelector('h1').textContent = msg;
    document.getElementById('menu').querySelector('p').textContent = subtext;
    document.getElementById('play-btn').textContent = 'ИГРАТЬ СНОВА';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    document.getElementById('bomb-status').style.display = 'none';
}

function checkWinCondition() {
    if (state.kills >= 30) {
        gameWin('kills');
        return true;
    }
    return false;
}

let mpRespawnTimeout = null;

function resetPlayerStats() {
    state.health = CONFIG.player.health;
    state.ammo = CONFIG.weapon.magazineSize;
    state.reserveAmmo = CONFIG.weapon.reserveAmmo;
    state.sniperAmmo = CONFIG.sniper.magazineSize;
    state.sniperReserve = CONFIG.sniper.reserveAmmo;
    state.grenades = 3;
    state.isReloading = false;
    state.currentWeapon = 'rifle';
    state.isScoped = false;
    state.regenTimer = 0;
    state.canShoot = true;
    state.canThrowGrenade = true;
    weaponGroup.visible = true;
    sniperGroup.visible = false;
    document.getElementById('weapon-name').textContent = 'AK-47';
    document.getElementById('scope-overlay').classList.remove('active');
    camera.fov = 75;
    camera.updateProjectionMatrix();
    updateHUD();
}

function placePlayer(position) {
    camera.position.copy(position);
    state.velocity.set(0, 0, 0);
    state.isGrounded = true;
}

function getAimSpawn(index = 0) {
    const spawn = AIM_SPAWNS[index % AIM_SPAWNS.length];
    return new THREE.Vector3(spawn.x, CONFIG.player.height, spawn.z);
}

function respawnLocalPlayer() {
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    resetPlayerStats();
    const spawn = getAimSpawn(state.mpSpawnIndex || 0);
    placePlayer(spawn);
    if (mpSocket && mpSocket.connected) {
        mpSocket.emit('respawn', { x: spawn.x, y: spawn.y, z: spawn.z });
    }
}

function applyPlayerDamage(amount) {
    state.health -= amount;
    updateHUD();
    showDamageOverlay();
    if (state.health <= 0) {
        if (state.isMultiplayer) {
            state.health = 0;
            updateHUD();
            if (mpRespawnTimeout) clearTimeout(mpRespawnTimeout);
            mpRespawnTimeout = setTimeout(respawnLocalPlayer, 1200);
        } else {
            gameOver();
        }
    }
}

function resetGame(options = {}) {
    const { skipEnemies = false, position = null } = options;
    
    resetPlayerStats();
    state.kills = 0;
    state.bombPlanted = false;
    state.bombTimer = 0;
    state.bombDefuseTimer = 0;
    state.bombPosition = null;
    state.regenTimer = 0;
    state.enemyDefusing = false;
    
    // Remove bomb if exists
    if (bombMesh) { scene.remove(bombMesh); bombMesh = null; }
    if (bombLight) { scene.remove(bombLight); bombLight = null; }
    
    const spawnPos = position || new THREE.Vector3(0, CONFIG.player.height, 20);
    placePlayer(spawnPos);
    
    // Reset enemies
    if (!skipEnemies) {
        enemies.forEach(e => {
            if (!scene.children.includes(e.group)) scene.add(e.group);
            if (!e.isAlive) {
                e.respawn();
            }
            e.health = e.maxHealth;
            e.state = 'patrol';
            e.group.visible = true;
        });
    } else {
        enemies.forEach(e => e.group.visible = false);
    }
    
    document.getElementById('bomb-status').style.display = 'none';
}

// ==================== INPUT HANDLING ====================
document.addEventListener('keydown', (e) => {
    if (!controls.isLocked) return;
    
    switch (e.code) {
        case 'KeyW': state.moveForward = true; break;
        case 'KeyS': state.moveBackward = true; break;
        case 'KeyA': state.moveLeft = true; break;
        case 'KeyD': state.moveRight = true; break;
        case 'Space':
            state.jumpHeld = true;
            if (state.isGrounded) {
                state.velocity.y = CONFIG.player.jumpForce;
                state.isGrounded = false;
            }
            break;
        case 'ShiftLeft': state.isSprinting = true; break;
        case 'KeyR': reload(); break;
        case 'KeyG': throwGrenade(); break;
        case 'KeyB': plantBomb(); break;
        case 'Digit1': switchWeapon('rifle'); break;
        case 'Digit2': switchWeapon('sniper'); break;
        case 'Digit3': switchWeapon('knife'); break;
    }
});

document.addEventListener('keyup', (e) => {
    switch (e.code) {
        case 'KeyW': state.moveForward = false; break;
        case 'KeyS': state.moveBackward = false; break;
        case 'KeyA': state.moveLeft = false; break;
        case 'KeyD': state.moveRight = false; break;
        case 'ShiftLeft': state.isSprinting = false; break;
        case 'Space': state.jumpHeld = false; break;
    }
});

let isMouseDown = false;
document.addEventListener('mousedown', (e) => {
    if (!controls.isLocked) return;
    
    if (e.button === 0) {
        isMouseDown = true;
        shoot();
    } else if (e.button === 2) {
        toggleScope();
    }
});

document.addEventListener('mouseup', (e) => {
    if (e.button === 0) {
        isMouseDown = false;
    }
});

// Prevent context menu on right click
document.addEventListener('contextmenu', (e) => e.preventDefault());

// Auto-fire while holding (only for rifle)
setInterval(() => {
    if (isMouseDown && controls.isLocked && state.currentWeapon === 'rifle') {
        shoot();
    }
}, CONFIG.weapon.fireRate);

function enterGameUI() {
    if (isMobile) {
        controls.isLocked = true;
        state.isPlaying = true;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('crosshair').style.display = 'block';
        document.getElementById('mobile-controls').classList.add('active');
    } else {
        controls.lock();
        state.isPlaying = true;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('hud').style.display = 'block';
        document.getElementById('crosshair').style.display = 'block';
    }
}

// Play button
document.getElementById('play-btn').addEventListener('click', () => {
    state.isMultiplayer = false;
    state.isSearchingMatch = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    disconnectMultiplayer();
    resetRemotePlayers();
    createDefaultMap();
    resetGame();
    
    // Reset menu text
    document.getElementById('menu').querySelector('h1').textContent = 'Standoff';
    document.getElementById('menu').querySelector('p').textContent = 'Browser FPS Prototype';
    document.getElementById('play-btn').textContent = 'ИГРАТЬ';
    const mpBtn = document.getElementById('mp-btn');
    if (mpBtn) mpBtn.textContent = 'Играть мультиплеер 1v1';
    
    enterGameUI();
});

function ensureMatchmaking() {
    if (mpSocket) {
        if (mpSocket.connected) joinMatchmaking();
        return; // если идёт connect, дождёмся штатного on('connect')
    }
    connectMultiplayer();
}

function startMultiplayer() {
    state.isMultiplayer = true;
    state.isSearchingMatch = true;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    createAimMap();
    resetRemotePlayers();
    resetGame({ skipEnemies: true, position: getAimSpawn(state.mpSpawnIndex || 0) });
    document.getElementById('menu').querySelector('h1').textContent = 'Standoff 1v1';
    document.getElementById('menu').querySelector('p').textContent = 'Aim карта для дуэлей';
    const btn = document.getElementById('mp-btn');
    if (btn) btn.textContent = 'Поиск соперника...';
    enterGameUI();
    ensureMatchmaking();
}

function leaveMultiplayer() {
    state.isMultiplayer = false;
    state.isSearchingMatch = false;
    state.mpOpponentId = null;
    state.mpRoom = null;
    state.mpSpawnIndex = 0;
    if (mpRespawnTimeout) {
        clearTimeout(mpRespawnTimeout);
        mpRespawnTimeout = null;
    }
    disconnectMultiplayer();
    resetRemotePlayers();
    createDefaultMap();
    resetGame();
    enemies.forEach(e => e.group.visible = true);
    const menu = document.getElementById('menu');
    menu.querySelector('h1').textContent = 'Standoff';
    menu.querySelector('p').textContent = 'Браузерный шутер';
    state.isPlaying = false;
    if (!isMobile) document.exitPointerLock();
    document.getElementById('menu').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('crosshair').style.display = 'none';
    document.getElementById('mobile-controls').classList.remove('active');
    const btn = document.getElementById('mp-btn');
    if (btn) btn.textContent = 'Играть мультиплеер 1v1';
}

// Multiplayer button
document.getElementById('mp-btn').addEventListener('click', () => {
    if (state.isMultiplayer) {
        leaveMultiplayer();
    } else {
        startMultiplayer();
    }
});

// Debug toggle
document.getElementById('debug-btn').addEventListener('click', () => {
    const panel = document.getElementById('debug-panel');
    panel.classList.toggle('active');
    updateDebugPanel();
});

function updateDebugPanel() {
    const panel = document.getElementById('debug-panel');
    if (!panel || !panel.classList.contains('active')) return;
    const pos = camera.position;
    const data = {
        mpUrl: MP_URL,
        connected: !!(mpSocket && mpSocket.connected),
        socketId: mpSocket ? mpSocket.id : null,
        lastError: mpLastError,
        isMultiplayer: state.isMultiplayer,
        isSearching: state.isSearchingMatch,
        room: state.mpRoom,
        opponentId: state.mpOpponentId,
        pos: { x: pos.x.toFixed(2), y: pos.y.toFixed(2), z: pos.z.toFixed(2) },
        kills: state.kills
    };
    panel.textContent = JSON.stringify(data, null, 2);
}

setInterval(updateDebugPanel, 1000);

// Window resize
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ==================== GAME LOOP ====================
const clock = new THREE.Clock();

function animate() {
    requestAnimationFrame(animate);
    
    const delta = Math.min(clock.getDelta(), 0.1);
    
    if (state.isPlaying && controls.isLocked) {
        updatePlayer(delta);
        updateWeapon(delta);
        updateCrosshair(delta);
        
        // Health regeneration (2 HP per second, starts after 3 seconds without damage)
        if (state.health < CONFIG.player.health && state.health > 0) {
            state.regenTimer = (state.regenTimer || 0) + delta;
            if (state.regenTimer > 3) {
                state.health = Math.min(CONFIG.player.health, state.health + 2 * delta);
                updateHUD();
            }
        }
        
        // Update enemies (singleplayer only)
        if (!state.isMultiplayer) {
            enemies.forEach(enemy => {
                enemy.update(delta, camera.position);
            });
        }
    }
    
    updateParticles(delta);
    updateTracers(delta);
    updateGrenades(delta);
    if (!state.isMultiplayer) {
        updateBomb(delta);
    }
    updateRemotePlayers(delta);
    
    // Mobile joystick movement
    if (isMobile && controls.isLocked) {
        updateMobileMovement();
    }
    
    renderer.render(scene, camera);
}

// ==================== MOBILE CONTROLS ====================
// Default control positions
const defaultControls = {
    joystick: { x: 30, y: 30, size: 100 },
    shoot: { y: 40, size: 70, right: 30 },
    jump: { y: 120, size: 55, right: 30 },
    reload: { y: 40, size: 45, right: 120 },
    grenade: { y: 100, size: 45, right: 110 },
    weapon: { y: 160, size: 45, right: 110 },
    scope: { y: 190, size: 45, right: 30 },
    bomb: { y: 250, size: 45, right: 30 }
};

function loadControlsConfig() {
    try {
        const saved = localStorage.getItem('standoffControls');
        if (saved) {
            return JSON.parse(saved);
        }
    } catch (e) {
        console.log('Failed to load controls config');
    }
    return JSON.parse(JSON.stringify(defaultControls));
}

let controlsConfig = loadControlsConfig();

function applyControlsConfig() {
    Object.keys(controlsConfig).forEach(key => {
        const el = document.querySelector(`[data-ctrl="${key}"]`);
        if (!el) return;
        
        const cfg = controlsConfig[key];
        el.style.width = cfg.size + 'px';
        el.style.height = cfg.size + 'px';
        el.style.fontSize = (cfg.size * 0.35) + 'px';
        
        if (cfg.right !== undefined && cfg.right !== null) {
            el.style.right = cfg.right + 'px';
            el.style.left = 'auto';
        } else if (cfg.x !== undefined && cfg.x !== null) {
            el.style.left = cfg.x + 'px';
            el.style.right = 'auto';
        }
        el.style.bottom = cfg.y + 'px';
    });
}

// Button emoji labels
var btnEmoji={shoot:String.fromCodePoint(0x1F52B),jump:String.fromCodePoint(0x2B06,0xFE0F),reload:String.fromCodePoint(0x1F504),grenade:String.fromCodePoint(0x1F4A5),weapon:String.fromCodePoint(0x1F500),scope:String.fromCodePoint(0x1F3AF),bomb:String.fromCodePoint(0x1F4A3)};function setButtonLabels(){for(var k in btnEmoji){var b=document.getElementById('btn-'+k);if(b)b.textContent=btnEmoji[k];}}
// Apply on load
if(isMobile){window.addEventListener('load',function(){setButtonLabels();applyControlsConfig();});}

// ==================== CONTROLS EDITOR ====================
let editorActive = false;
let selectedBtn = null;
let dragOffset = { x: 0, y: 0 };
let isResizing = false;

if (isMobile) {
    document.getElementById('edit-controls-btn').addEventListener('click', openEditor);
    document.getElementById('save-controls').addEventListener('click', saveControls);
    document.getElementById('reset-controls').addEventListener('click', resetControls);
}

function openEditor() {
    editorActive = true;
    document.getElementById('controls-editor').classList.add('active');
    const area = document.getElementById('editor-area');
    area.innerHTML = '';
    
    // Wait for area to render
    setTimeout(() => {
        const areaRect = area.getBoundingClientRect();
        
        // Create editor buttons
        Object.keys(controlsConfig).forEach(key => {
            const cfg = controlsConfig[key];
            const btn = document.createElement('div');
            btn.className = 'editor-btn';
            btn.dataset.ctrl = key;
            btn.style.width = cfg.size + 'px';
            btn.style.height = cfg.size + 'px';
            btn.style.fontSize = (cfg.size * 0.35) + 'px';
            
            // Position from bottom
            let left;
            if (cfg.right !== undefined && cfg.right !== null) {
                left = areaRect.width - cfg.right - cfg.size;
            } else {
                left = cfg.x || 30;
            }
            btn.style.left = left + 'px';
            // Position vertically
            if (cfg.top !== undefined && cfg.top !== null) {
                btn.style.top = cfg.top + 'px';
            } else if (cfg.y !== undefined && cfg.y !== null) {
                btn.style.top = (areaRect.height - cfg.y - cfg.size) + 'px';
            }
            
            // Label
            const labels = {
                joystick: 'MOVE',
                shoot: 'FIRE',
                jump: 'UP',
                reload: 'R',
                grenade: 'G',
                weapon: '1/2',
                scope: 'AIM',
                bomb: 'B'
            };
            btn.textContent = labels[key] || key;
            
            // Resize handle
            const handle = document.createElement('div');
            handle.className = 'resize-handle';
            btn.appendChild(handle);
            
            area.appendChild(btn);
            
            // Touch events for dragging
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = btn.getBoundingClientRect();
                const handleRect = handle.getBoundingClientRect();
                
                // Check if touching resize handle
                if (touch.clientX >= handleRect.left && touch.clientY >= handleRect.top) {
                    isResizing = true;
                } else {
                    isResizing = false;
                    dragOffset.x = touch.clientX - rect.left;
                    dragOffset.y = touch.clientY - rect.top;
                }
                
                // Select this button
                document.querySelectorAll('.editor-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedBtn = btn;
            });
            
            btn.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!selectedBtn || selectedBtn !== btn) return;
                
                const touch = e.touches[0];
                const areaRect = area.getBoundingClientRect();
                
                if (isResizing) {
                    // Resize
                    const rect = btn.getBoundingClientRect();
                    const newSize = Math.max(40, Math.min(300, touch.clientX - rect.left + 10));
                    btn.style.width = newSize + 'px';
                    btn.style.height = newSize + 'px';
                    btn.style.fontSize = (newSize * 0.35) + 'px';
                    
                    document.getElementById('size-indicator').style.display = 'block';
                    document.getElementById('size-value').textContent = Math.round(newSize);
                } else {
                    // Drag
                    let newX = touch.clientX - areaRect.left - dragOffset.x;
                    let newY = touch.clientY - areaRect.top - dragOffset.y;
                    
                    // Clamp to area
                    newX = Math.max(0, Math.min(areaRect.width - btn.offsetWidth, newX));
                    newY = Math.max(0, Math.min(areaRect.height - btn.offsetHeight, newY));
                    
                    btn.style.left = newX + 'px';
                    btn.style.top = newY + 'px';
                }
            });
            
            btn.addEventListener('touchend', () => {
                isResizing = false;
                document.getElementById('size-indicator').style.display = 'none';
            });
        });
    }, 100);
}

function saveControls() {
    const area = document.getElementById('editor-area');
    const areaRect = area.getBoundingClientRect();
    
    document.querySelectorAll('.editor-btn').forEach(btn => {
        const key = btn.dataset.ctrl;
        const rect = btn.getBoundingClientRect();
        const size = btn.offsetWidth;
        
        // Convert to bottom-right coordinates
        const bottomY = areaRect.height - (rect.top - areaRect.top) - size;
        const rightX = areaRect.width - (rect.left - areaRect.left) - size;
        const leftX = rect.left - areaRect.left;
        
        // Decide if right or left positioning
        if (leftX > areaRect.width / 2) {
            controlsConfig[key] = { right: Math.round(rightX), y: Math.round(bottomY), size: Math.round(size) };
        } else {
            controlsConfig[key] = { x: Math.round(leftX), y: Math.round(bottomY), size: Math.round(size) };
        }
    });
    
    try {
        localStorage.setItem('standoffControls', JSON.stringify(controlsConfig));
    } catch (e) {
        console.log('Failed to save controls');
    }
    applyControlsConfig();
    closeEditor();
}

function resetControls() {
    controlsConfig = JSON.parse(JSON.stringify(defaultControls));
    localStorage.removeItem('standoffControls');
    applyControlsConfig();
    openEditor(); // Refresh editor
}

function closeEditor() {
    editorActive = false;
    document.getElementById('controls-editor').classList.remove('active');
}

// ==================== MOBILE GAME CONTROLS ====================
let moveJoystick = { active: false, id: null, startX: 0, startY: 0, currentX: 0, currentY: 0 };
let lookTouch = { active: false, id: null, lastX: 0, lastY: 0 };
let mobileShootInterval = null;

function setupMobileControls() {
    if (!isMobile) return;
    
    const joystickMove = document.getElementById('joystick-move');
    const moveStick = document.getElementById('move-stick');
    const lookArea = document.getElementById('look-area');
    
    // Movement joystick
    // --- Improved multi-touch joystick handling ---
    joystickMove.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0]; // use changedTouches to get the initiating finger only
        const rect = joystickMove.getBoundingClientRect();
        moveJoystick.active = true;
        moveJoystick.id = touch.identifier; // remember which finger controls the stick
        moveJoystick.startX = rect.left + rect.width / 2;
        moveJoystick.startY = rect.top + rect.height / 2;
    }, { passive: false });
    
    // Listen on document so that movement continues even if the finger leaves the joystick element
    document.addEventListener('touchmove', (e) => {
        if (!moveJoystick.active) return;
        const touch = Array.from(e.touches).find(t => t.identifier === moveJoystick.id);
        if (!touch) return;
        const rect = joystickMove.getBoundingClientRect();
        const maxDist = rect.width * 0.35;
        let dx = touch.clientX - moveJoystick.startX;
        let dy = touch.clientY - moveJoystick.startY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist > maxDist) {
            dx = dx / dist * maxDist;
            dy = dy / dist * maxDist;
        }
        moveJoystick.currentX = dx / maxDist;
        moveJoystick.currentY = dy / maxDist;
        moveStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    }, { passive: false });
    
    document.addEventListener('touchend', (e) => {
        if (!moveJoystick.active) return;
        // Check if the finger that ended is the joystick finger
        const ended = Array.from(e.changedTouches).some(t => t.identifier === moveJoystick.id);
        if (!ended) return;
        moveJoystick.active = false;
        moveJoystick.currentX = 0;
        moveJoystick.currentY = 0;
        moveStick.style.transform = 'translate(-50%, -50%)';
    });
    
    // Look area
    lookArea.addEventListener('touchstart', (e) => {
        e.preventDefault();
        // Не перехватываем второй палец, если уже крутим камерой
        if (lookTouch.active) return;
        const touch = e.changedTouches[0];
        lookTouch.active = true;
        lookTouch.id = touch.identifier;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
    }, { passive: false });
    
    // Use document-level listener so camera keeps rotating even if finger leaves the look area
    document.addEventListener('touchmove', (e) => {
        if (!lookTouch.active || !controls.isLocked) return;
        const touch = Array.from(e.touches).find(t => t.identifier === lookTouch.id);
        if (!touch) return;
        const dx = touch.clientX - lookTouch.lastX;
        const dy = touch.clientY - lookTouch.lastY;
        lookTouch.lastX = touch.clientX;
        lookTouch.lastY = touch.clientY;
        
        const sens = 0.0035;
        const maxStep = 0.06;
        const stepYaw = THREE.MathUtils.clamp(dx * sens, -maxStep, maxStep);
        const stepPitch = THREE.MathUtils.clamp(dy * sens, -maxStep, maxStep);
        controls.euler.y -= stepYaw;
        controls.euler.x -= stepPitch;
        controls.euler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, controls.euler.x));
        camera.quaternion.setFromEuler(controls.euler);
    }, { passive: false });
    
    const clearLookTouch = (e) => {
        if (!lookTouch.active) return;
        const ended = Array.from(e.changedTouches || []).some(t => t.identifier === lookTouch.id);
        if (ended) {
            lookTouch.active = false;
            lookTouch.id = null;
        }
    };
    document.addEventListener('touchend', clearLookTouch);
    document.addEventListener('touchcancel', clearLookTouch);
    
    // Action buttons
    document.getElementById('btn-shoot').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!controls.isLocked) return;
        shoot();
        if (state.currentWeapon === 'rifle') {
            mobileShootInterval = setInterval(shoot, CONFIG.weapon.fireRate);
        }
    }, { passive: false });
    
    document.getElementById('btn-shoot').addEventListener('touchend', () => {
        if (mobileShootInterval) {
            clearInterval(mobileShootInterval);
            mobileShootInterval = null;
        }
    });
    
    document.getElementById('btn-jump').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (!controls.isLocked) return;
        if (state.isGrounded) {
            state.velocity.y = CONFIG.player.jumpForce;
            state.isGrounded = false;
        }
    }, { passive: false });
    
    document.getElementById('btn-reload').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) reload();
    }, { passive: false });
    
    document.getElementById('btn-grenade').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) throwGrenade();
    }, { passive: false });
    
    document.getElementById('btn-weapon').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) {
            if (state.currentWeapon === 'rifle') switchWeapon('sniper');
            else if (state.currentWeapon === 'sniper') switchWeapon('knife');
            else switchWeapon('rifle');
        }
    }, { passive: false });
    
    document.getElementById('btn-scope').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) toggleScope();
    }, { passive: false });
    
    document.getElementById('btn-bomb').addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (controls.isLocked) plantBomb();
    }, { passive: false });
}

setupMobileControls();

function updateMobileMovement() {
    if (!moveJoystick.active) {
        state.moveForward = false;
        state.moveBackward = false;
        state.moveLeft = false;
        state.moveRight = false;
        return;
    }
    
    state.moveForward = moveJoystick.currentY < -0.3;
    state.moveBackward = moveJoystick.currentY > 0.3;
    state.moveLeft = moveJoystick.currentX < -0.3;
    state.moveRight = moveJoystick.currentX > 0.3;
}


// ==================== HUD EDITOR ====================
const defaultHudConfig = {
    kills: { top: 30, left: 30 },
    health: { bottom: 30, left: 30 },
    ammo: { bottom: 30, right: 30 },
    grenades: { bottom: 70, right: 30 },
    weaponName: { bottom: 110, right: 30 }
};
let hudConfig = JSON.parse(JSON.stringify(defaultHudConfig));
try { const s = localStorage.getItem('standoffHud'); if(s) hudConfig = JSON.parse(s); } catch(e){}

function applyHudConfig() {
    const els = {kills:document.getElementById('kills'),health:document.getElementById('health-bar'),ammo:document.getElementById('ammo'),grenades:document.getElementById('grenades-count'),weaponName:document.getElementById('weapon-name')};
    Object.keys(hudConfig).forEach(k => {
        const el = els[k]; if(!el) return;
        const c = hudConfig[k];
        el.style.position = 'fixed';
        el.style.top = c.top !== undefined ? c.top+'px' : 'auto';
        el.style.bottom = c.bottom !== undefined ? c.bottom+'px' : 'auto';
        el.style.left = c.left !== undefined ? c.left+'px' : 'auto';
        el.style.right = c.right !== undefined ? c.right+'px' : 'auto';
    });
    const ht = document.getElementById('health-text');
    if(ht && hudConfig.health) {
        ht.style.position = 'fixed';
        ht.style.bottom = ((hudConfig.health.bottom||0)+15)+'px';
        ht.style.left = hudConfig.health.left !== undefined ? hudConfig.health.left+'px' : 'auto';
    }
}

let draggedHud = null, hudOff = {x:0,y:0};
function openHudEditor() {
    const ed = document.getElementById('hud-editor'); ed.classList.add('active');
    ed.querySelectorAll('.hud-draggable').forEach(e => e.remove());
    [{k:'kills',l:'Убийства'},{k:'health',l:'Здоровье'},{k:'ammo',l:'Патроны'},{k:'grenades',l:'Гранаты'},{k:'weaponName',l:'Оружие'}].forEach(item => {
        const el = document.createElement('div'); el.className = 'hud-draggable'; el.dataset.hudKey = item.k; el.textContent = item.l;
        const c = hudConfig[item.k];
        if(c.top !== undefined) el.style.top = c.top+'px';
        if(c.bottom !== undefined) el.style.bottom = c.bottom+'px';
        if(c.left !== undefined) el.style.left = c.left+'px';
        if(c.right !== undefined) el.style.right = c.right+'px';
        el.onmousedown = (e) => { draggedHud = el; el.classList.add('dragging'); const r = el.getBoundingClientRect(); hudOff = {x:e.clientX-r.left,y:e.clientY-r.top}; };
        el.ontouchstart = (e) => { e.preventDefault(); draggedHud = el; el.classList.add('dragging'); const r = el.getBoundingClientRect(); const t = e.touches[0]; hudOff = {x:t.clientX-r.left,y:t.clientY-r.top}; };
        ed.appendChild(el);
    });
}
document.addEventListener('mousemove', (e) => {
    if(!draggedHud) return;
    e.preventDefault();
    const x = e.clientX - hudOff.x, y = e.clientY - hudOff.y, mx = window.innerWidth/2, my = window.innerHeight/2;
    draggedHud.style.left = x < mx ? x+'px' : 'auto';
    draggedHud.style.right = x >= mx ? (window.innerWidth-x-draggedHud.offsetWidth)+'px' : 'auto';
    draggedHud.style.top = y < my ? y+'px' : 'auto';
    draggedHud.style.bottom = y >= my ? (window.innerHeight-y-draggedHud.offsetHeight)+'px' : 'auto';
});
document.addEventListener('mouseup', () => { if(draggedHud) { draggedHud.classList.remove('dragging'); draggedHud = null; } });

// Touch support for mobile HUD editor
document.addEventListener('touchmove', (e) => {
    if(!draggedHud) return;
    e.preventDefault();
    const touch = e.touches[0];
    const x = touch.clientX - hudOff.x, y = touch.clientY - hudOff.y;
    const mx = window.innerWidth/2, my = window.innerHeight/2;
    draggedHud.style.left = x < mx ? x+'px' : 'auto';
    draggedHud.style.right = x >= mx ? (window.innerWidth-x-draggedHud.offsetWidth)+'px' : 'auto';
    draggedHud.style.top = y < my ? y+'px' : 'auto';
    draggedHud.style.bottom = y >= my ? (window.innerHeight-y-draggedHud.offsetHeight)+'px' : 'auto';
}, {passive: false});

document.addEventListener('touchend', () => { if(draggedHud) { draggedHud.classList.remove('dragging'); draggedHud = null; } });

function saveHudConfig() {
    document.querySelectorAll('.hud-draggable').forEach(el => {
        const k = el.dataset.hudKey, s = el.style; hudConfig[k] = {};
        if(s.top && s.top !== 'auto') hudConfig[k].top = parseInt(s.top);
        if(s.bottom && s.bottom !== 'auto') hudConfig[k].bottom = parseInt(s.bottom);
        if(s.left && s.left !== 'auto') hudConfig[k].left = parseInt(s.left);
        if(s.right && s.right !== 'auto') hudConfig[k].right = parseInt(s.right);
    });
    localStorage.setItem('standoffHud', JSON.stringify(hudConfig));
    applyHudConfig();
    document.getElementById('hud-editor').classList.remove('active');
}
function resetHudConfig() { hudConfig = JSON.parse(JSON.stringify(defaultHudConfig)); localStorage.removeItem('standoffHud'); applyHudConfig(); openHudEditor(); }

document.getElementById('edit-hud-btn').addEventListener('click', openHudEditor);
document.getElementById('save-hud').addEventListener('click', saveHudConfig);
document.getElementById('reset-hud').addEventListener('click', resetHudConfig);
applyHudConfig();

// ==================== CROSSHAIR EDITOR ====================
const defaultCrosshair = { 
    style: 'cross', // cross, dot, circle, t
    length: 12, 
    thickness: 2, 
    gap: 20, 
    color: '#ffffff', 
    dot: true,
    dotSize: 4
};

function loadCrosshairConfig() {
    try {
        const s = localStorage.getItem('standoffCrosshair');
        if (s) return { ...defaultCrosshair, ...JSON.parse(s) };
    } catch (e) {}
    return { ...defaultCrosshair };
}
let crosshairConfig = loadCrosshairConfig();

// ==================== MULTIPLAYER (1v1 AIM) ====================
// Фиксированный адрес сокет-сервера (Railway)
const MP_URL = 'wss://standoff2-production.up.railway.app';
let mpLastError = null;
let mpSocket = null;
let mpSendInterval = null;
const remotePlayers = new Map();

function createRemotePlayer(color = 0x4ade80) {
    const group = new THREE.Group();
    
    const torsoGeo = new THREE.CylinderGeometry(0.35, 0.4, 1.1, 8);
    const body = new THREE.Mesh(torsoGeo, new THREE.MeshLambertMaterial({ color }));
    body.position.y = 1;
    body.castShadow = true;
    group.add(body);
    
    const headGeo = new THREE.SphereGeometry(0.25, 8, 8);
    const head = new THREE.Mesh(headGeo, new THREE.MeshLambertMaterial({ color: 0xffffff }));
    head.position.y = 1.8;
    head.castShadow = true;
    head.name = 'head';
    group.add(head);
    
    // Weapon
    const weaponGroup = new THREE.Group();
    const gunBody = new THREE.Mesh(
        new THREE.BoxGeometry(0.06, 0.08, 0.4),
        materials.metal
    );
    gunBody.position.z = -0.2;
    weaponGroup.add(gunBody);
    
    const gunBarrel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.02, 0.25, 6),
        materials.metal
    );
    gunBarrel.rotation.x = Math.PI / 2;
    gunBarrel.position.z = -0.5;
    weaponGroup.add(gunBarrel);
    
    const muzzleFlash = new THREE.PointLight(0xffaa00, 0, 3);
    muzzleFlash.position.z = -0.6;
    weaponGroup.add(muzzleFlash);
    weaponGroup.position.set(0.3, 1.1, 0);
    group.add(weaponGroup);
    
    // Health bar
    const hbBgGeo = new THREE.PlaneGeometry(0.8, 0.08);
    const hbBgMat = new THREE.MeshBasicMaterial({ color: 0x333333, side: THREE.DoubleSide });
    const healthBarBg = new THREE.Mesh(hbBgGeo, hbBgMat);
    healthBarBg.position.y = 2.3;
    group.add(healthBarBg);
    
    const hbFillGeo = new THREE.PlaneGeometry(0.78, 0.06);
    const hbFillMat = new THREE.MeshBasicMaterial({ color: 0x4ade80, side: THREE.DoubleSide });
    const healthBarFill = new THREE.Mesh(hbFillGeo, hbFillMat);
    healthBarFill.position.y = 2.3;
    healthBarFill.position.z = 0.01;
    group.add(healthBarFill);
    
    group.position.y = 0;
    scene.add(group);
    
    return {
        group,
        body,
        head,
        healthBarBg,
        healthBarFill,
        muzzleFlash,
        target: { pos: new THREE.Vector3(), rotY: 0 },
        health: CONFIG.player.health,
        maxHealth: CONFIG.player.health,
        isAlive: true
    };
}

function getRemotePlayer(id) {
    let p = remotePlayers.get(id);
    if (!p) {
        p = createRemotePlayer();
        remotePlayers.set(id, p);
    }
    return p;
}

function removeRemotePlayer(id) {
    const p = remotePlayers.get(id);
    if (p) {
        scene.remove(p.group);
        remotePlayers.delete(id);
    }
}

function resetRemotePlayers() {
    Array.from(remotePlayers.keys()).forEach(id => removeRemotePlayer(id));
}

function applyRemoteDamage(id, damage, isHeadshot = false) {
    const p = remotePlayers.get(id);
    if (!p || !p.isAlive) return;
    p.health = Math.max(0, p.health - damage);
    const healthPercent = p.health / p.maxHealth;
    p.healthBarFill.scale.x = Math.max(0, healthPercent);
    p.healthBarFill.position.x = (1 - healthPercent) * -0.39;
    if (p.health <= 0) {
        p.isAlive = false;
        p.group.visible = false;
        state.kills++;
        updateHUD();
    }
}

function handleHitEvent({ shooterId, targetId, damage }) {
    if (!state.isMultiplayer) return;
    const dmg = Number(damage) || 0;
    if (mpSocket && targetId === mpSocket.id) {
        applyPlayerDamage(dmg);
    } else {
        applyRemoteDamage(targetId, dmg);
    }
}

function handleRemoteRespawn({ id, x, y, z }) {
    const p = getRemotePlayer(id);
    p.health = p.maxHealth;
    p.isAlive = true;
    p.group.visible = true;
    p.healthBarFill.scale.x = 1;
    p.healthBarFill.position.x = 0;
    p.group.position.set(x, y, z);
    p.target.pos.set(x, y, z);
    p.target.rotY = 0;
}

function handleRemoteState(data) {
    if (!state.isMultiplayer) return;
    const { id, x, y, z, rotY } = data;
    if (mpSocket && id === mpSocket.id) return;
    const p = getRemotePlayer(id);
    p.target.pos.set(x, y, z);
    p.target.rotY = rotY || 0;
}

function handleRemoteShoot({ id }) {
    if (!state.isMultiplayer) return;
    if (mpSocket && id === mpSocket.id) return;
    const p = remotePlayers.get(id);
    if (!p) return;
    p.muzzleFlash.intensity = 2;
    setTimeout(() => { p.muzzleFlash.intensity = 0; }, 60);
}

function connectMultiplayer() {
    if (mpSocket) return;
    if (!window.io) { console.warn('Socket.IO client not loaded'); return; }
    mpSocket = io(MP_URL, { transports: ['websocket'], path: '/socket.io' });

    mpSocket.on('connect', () => {
        if (mpSendInterval) clearInterval(mpSendInterval);
        mpSendInterval = setInterval(sendPlayerState, 50); // 20 tps
        if (state.isMultiplayer) {
            joinMatchmaking();
        }
    });

    mpSocket.on('connect_error', (err) => {
        console.warn('MP connect_error', err.message);
        mpLastError = err?.message || String(err);
        const btn = document.getElementById('mp-btn');
        if (btn) btn.textContent = 'Ошибка подключения';
    });
    mpSocket.on('error', (err) => {
        console.warn('MP error', err);
        mpLastError = err?.message || String(err);
    });

    mpSocket.on('disconnect', () => {
        if (mpSendInterval) { clearInterval(mpSendInterval); mpSendInterval = null; }
        resetRemotePlayers();
        state.isSearchingMatch = false;
        const btn = document.getElementById('mp-btn');
        if (btn) btn.textContent = 'Играть мультиплеер 1v1';
        mpSocket = null;
    });

    mpSocket.on('waiting', () => {
        state.isSearchingMatch = true;
        const btn = document.getElementById('mp-btn');
        if (btn) btn.textContent = 'Поиск соперника...';
    });

    mpSocket.on('matchFound', ({ room, spawnIndex = 0, opponentId }) => {
        state.mpRoom = room;
        state.mpSpawnIndex = spawnIndex;
        state.mpOpponentId = opponentId || null;
        state.isSearchingMatch = false;
        const spawn = getAimSpawn(spawnIndex);
        resetGame({ skipEnemies: true, position: spawn });
        const btn = document.getElementById('mp-btn');
        if (btn) btn.textContent = 'Играем 1v1';
    });

    mpSocket.on('state', handleRemoteState);
    mpSocket.on('shoot', handleRemoteShoot);
    mpSocket.on('hit', handleHitEvent);
    mpSocket.on('respawn', handleRemoteRespawn);
    mpSocket.on('leave', ({ id }) => removeRemotePlayer(id));
}

function disconnectMultiplayer() {
    if (mpSendInterval) { clearInterval(mpSendInterval); mpSendInterval = null; }
    if (mpSocket) { mpSocket.disconnect(); mpSocket = null; }
    resetRemotePlayers();
    const btn = document.getElementById('mp-btn');
    if (btn) btn.textContent = 'Играть мультиплеер 1v1';
}

function joinMatchmaking() {
    if (!mpSocket || !mpSocket.connected) return;
    state.isSearchingMatch = true;
    const btn = document.getElementById('mp-btn');
    if (btn) btn.textContent = 'Поиск соперника...';
    mpSocket.emit('join1v1');
}

function sendPlayerState() {
    if (!mpSocket || !mpSocket.connected || !state.isMultiplayer || !state.isPlaying) return;
    mpSocket.emit('state', {
        x: camera.position.x,
        y: camera.position.y,
        z: camera.position.z,
        rotY: camera.rotation.y,
    });
}

function updateRemotePlayers(delta) {
    if (!state.isMultiplayer) return;
    remotePlayers.forEach((p) => {
        p.group.position.lerp(p.target.pos, Math.min(1, delta * 10));
        p.group.rotation.y = THREE.MathUtils.lerp(p.group.rotation.y, p.target.rotY, Math.min(1, delta * 10));
        if (p.healthBarBg && p.healthBarFill) {
            p.healthBarBg.lookAt(camera.position);
            p.healthBarFill.lookAt(camera.position);
        }
    });
}

function applyCrosshairConfig() {
    const top = document.querySelector('.cross-top');
    const bottom = document.querySelector('.cross-bottom');
    const left = document.querySelector('.cross-left');
    const right = document.querySelector('.cross-right');
    const dot = document.getElementById('crosshair-dot');
    
    const style = crosshairConfig.style;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    const gap = crosshairConfig.gap;
    const color = crosshairConfig.color;
    const dotSize = crosshairConfig.dotSize;
    
    const showLines = style !== 'dot';
    const showTop = style === 'cross' || style === 'circle';
    
    // Top line (vertical)
    if (top) {
        top.style.width = thick + 'px';
        top.style.height = len + 'px';
        top.style.left = (-thick / 2) + 'px';
        top.style.top = (-gap - len) + 'px';
        top.style.bottom = 'auto';
        top.style.right = 'auto';
        top.style.background = color;
        top.style.display = (showLines && showTop) ? 'block' : 'none';
    }
    
    // Bottom line (vertical)
    if (bottom) {
        bottom.style.width = thick + 'px';
        bottom.style.height = len + 'px';
        bottom.style.left = (-thick / 2) + 'px';
        bottom.style.top = gap + 'px';
        bottom.style.bottom = 'auto';
        bottom.style.right = 'auto';
        bottom.style.background = color;
        bottom.style.display = showLines ? 'block' : 'none';
    }
    
    // Left line (horizontal)
    if (left) {
        left.style.width = len + 'px';
        left.style.height = thick + 'px';
        left.style.top = (-thick / 2) + 'px';
        left.style.left = (-gap - len) + 'px';
        left.style.bottom = 'auto';
        left.style.right = 'auto';
        left.style.background = color;
        left.style.display = showLines ? 'block' : 'none';
    }
    
    // Right line (horizontal)
    if (right) {
        right.style.width = len + 'px';
        right.style.height = thick + 'px';
        right.style.top = (-thick / 2) + 'px';
        right.style.left = gap + 'px';
        right.style.bottom = 'auto';
        right.style.right = 'auto';
        right.style.background = color;
        right.style.display = showLines ? 'block' : 'none';
    }
    
    // Dot
    if (dot) {
        dot.style.background = color;
        dot.style.display = crosshairConfig.dot ? 'block' : 'none';
        dot.style.width = dotSize + 'px';
        dot.style.height = dotSize + 'px';
        dot.style.top = (-dotSize / 2) + 'px';
        dot.style.left = (-dotSize / 2) + 'px';
    }
    
    // Update preview
    updateCrosshairPreview();
}

function updateCrosshairPreview() {
    const previewTop = document.querySelector('.preview-top');
    const previewBottom = document.querySelector('.preview-bottom');
    const previewLeft = document.querySelector('.preview-left');
    const previewRight = document.querySelector('.preview-right');
    const previewDot = document.querySelector('.preview-dot');
    
    if (!previewTop) return;
    
    const style = crosshairConfig.style;
    const len = crosshairConfig.length;
    const thick = crosshairConfig.thickness;
    const gap = crosshairConfig.gap;
    const color = crosshairConfig.color;
    const dotSize = crosshairConfig.dotSize;
    
    const showLines = style !== 'dot';
    const showTop = style === 'cross' || style === 'circle';
    
    // Vertical lines (top/bottom)
    previewTop.style.width = thick + 'px';
    previewTop.style.height = len + 'px';
    previewTop.style.left = (-thick/2) + 'px';
    previewTop.style.top = (-gap - len) + 'px';
    previewTop.style.background = color;
    previewTop.style.display = (showLines && showTop) ? 'block' : 'none';
    
    previewBottom.style.width = thick + 'px';
    previewBottom.style.height = len + 'px';
    previewBottom.style.left = (-thick/2) + 'px';
    previewBottom.style.top = gap + 'px';
    previewBottom.style.background = color;
    previewBottom.style.display = showLines ? 'block' : 'none';
    
    // Horizontal lines (left/right)
    previewLeft.style.height = thick + 'px';
    previewLeft.style.width = len + 'px';
    previewLeft.style.top = (-thick/2) + 'px';
    previewLeft.style.left = (-gap - len) + 'px';
    previewLeft.style.background = color;
    previewLeft.style.display = showLines ? 'block' : 'none';
    
    previewRight.style.height = thick + 'px';
    previewRight.style.width = len + 'px';
    previewRight.style.top = (-thick/2) + 'px';
    previewRight.style.left = gap + 'px';
    previewRight.style.background = color;
    previewRight.style.display = showLines ? 'block' : 'none';
    
    // Dot
    previewDot.style.background = color;
    previewDot.style.display = crosshairConfig.dot ? 'block' : 'none';
    previewDot.style.width = dotSize + 'px';
    previewDot.style.height = dotSize + 'px';
    previewDot.style.top = (-dotSize/2) + 'px';
    previewDot.style.left = (-dotSize/2) + 'px';
    
    // Update value labels
    const lenVal = document.getElementById('cross-length-val');
    const thickVal = document.getElementById('cross-thickness-val');
    const gapVal = document.getElementById('cross-gap-val');
    const dotSizeVal = document.getElementById('cross-dot-size-val');
    if (lenVal) lenVal.textContent = len + 'px';
    if (thickVal) thickVal.textContent = thick + 'px';
    if (gapVal) gapVal.textContent = gap + 'px';
    if (dotSizeVal) dotSizeVal.textContent = dotSize + 'px';
    
    // Update toggle state
    const dotToggle = document.getElementById('cross-dot-toggle');
    if (dotToggle) {
        dotToggle.classList.toggle('active', crosshairConfig.dot);
    }
    
    // Update style presets
    document.querySelectorAll('.preset-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.style === crosshairConfig.style);
    });
    
    // Show/hide lines controls based on style
    const linesControls = document.getElementById('lines-controls');
    if (linesControls) {
        linesControls.style.opacity = style === 'dot' ? '0.4' : '1';
        linesControls.style.pointerEvents = style === 'dot' ? 'none' : 'auto';
    }
}

applyCrosshairConfig();

// Open editor
function openCrosshairEditor() {
    document.getElementById('crosshair-editor').classList.add('active');
    document.getElementById('cross-length').value = crosshairConfig.length;
    document.getElementById('cross-thickness').value = crosshairConfig.thickness;
    document.getElementById('cross-gap').value = crosshairConfig.gap;
    document.getElementById('cross-color').value = crosshairConfig.color;
    document.getElementById('cross-dot-size').value = crosshairConfig.dotSize;
    updateCrosshairPreview();
}

function closeCrosshairEditor() {
    document.getElementById('crosshair-editor').classList.remove('active');
}

function saveCrosshair() {
    localStorage.setItem('standoffCrosshair', JSON.stringify(crosshairConfig));
    applyCrosshairConfig();
    closeCrosshairEditor();
}

function resetCrosshair() {
    crosshairConfig = { ...defaultCrosshair };
    localStorage.removeItem('standoffCrosshair');
    applyCrosshairConfig();
    openCrosshairEditor();
}

// Style presets
document.querySelectorAll('.preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        crosshairConfig.style = btn.dataset.style;
        // Auto-enable dot for dot style
        if (btn.dataset.style === 'dot') {
            crosshairConfig.dot = true;
        }
        applyCrosshairConfig();
    });
});

// Toggle switch for dot
document.getElementById('cross-dot-toggle').addEventListener('click', function() {
    crosshairConfig.dot = !crosshairConfig.dot;
    this.classList.toggle('active', crosshairConfig.dot);
    applyCrosshairConfig();
});

// Live preview for sliders
['cross-length', 'cross-thickness', 'cross-gap', 'cross-dot-size'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('input', () => {
        const key = id.replace('cross-', '').replace('-', '');
        if (id === 'cross-dot-size') {
            crosshairConfig.dotSize = parseInt(el.value);
        } else {
            crosshairConfig[id.split('-')[1]] = parseInt(el.value);
        }
        applyCrosshairConfig();
    });
});

// Color picker
document.getElementById('cross-color').addEventListener('input', (e) => {
    crosshairConfig.color = e.target.value;
    applyCrosshairConfig();
});

document.getElementById('edit-crosshair-btn').addEventListener('click', openCrosshairEditor);
document.getElementById('save-crosshair').addEventListener('click', saveCrosshair);
document.getElementById('reset-crosshair').addEventListener('click', resetCrosshair);

document.addEventListener('keydown', (e) => {
    if (e.code === 'Escape' && document.getElementById('crosshair-editor').classList.contains('active')) {
        closeCrosshairEditor();
    }
});

animate();
    </script>
</body>
</html>
